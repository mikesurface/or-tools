<!-- Good morning, Mr. Phelps. -->
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
    <title>or-tools/src/constraint_solver/routing.h Source File - Doxy</title>
    <link rel="shortcut icon" href="../../../favicon.ico">
    <!-- Both stylesheets are supplied by Doxygen, with maybe minor tweaks from Google. -->
    <link href="../../../doxygen.css" rel="stylesheet" type="text/css">
    <link href="../../../tabs.css" rel="stylesheet" type="text/css">
  </head>

  <body topmargin=0 leftmargin=20 bottommargin=0 rightmargin=20 marginwidth=20 marginheight=0>
  <!-- Second part of the secret behind Doxy logo always having the word "Doxy" with the color of the day. -->
  <style>
    a.doxy_logo:hover {
      background-color: #287003
    }
  </style>

  <table width=100% cellpadding=0 cellspacing=0 border=0>
    <!-- Top horizontal line with the color of the day. -->
    <tr valign=top>
      <td colspan=3 bgcolor=#287003 height=3></td>
    </tr>

    <!-- Header row with the links at the right. -->
    <tr valign=top>
      <td colspan=3 align=right>
        <font size=-1>
          Generated on: <font color=#287003><b>Thu Mar 29 07:46:58 PDT 2012</b></font>
            for <b>custom file set</b>
        </font>
      </td>
    </tr>

    <!-- Header row with the logo and the search form. -->
    <tr valign=top>
      <!-- Logo. -->
      <td align=left width=150>
        <table width=150 height=54 cellpadding=0 cellspacing=0 border=0>
          <tr valign=top>
            <!-- First part of the secret behind Doxy logo always having the word "Doxy" with the color of the day. -->
            <td bgcolor=#287003>
              <a class="doxy_logo" href="../../../index.html"><img src="../../../doxy_logo.png" alt="Doxy" border=0></a>
            </td>
          </tr>
        </table>
      </td>
    </tr>

    <!-- Tiny vertical space below the form. -->
    <tr valign=top>
      <td colspan=3 height=3></td>
    </tr>
  </table>

  <!-- Header navigation row. -->
  <div class="memproto">
    <table width=100% cellpadding=0 cellspacing=0 border=0>
      <tr>
        <td align=left style="padding-left: 20px"><font size=+1><b><tt><font color=#333333>//
            <a href="../../../index.html"><font color=#287003>doxy</font></a>/</font>
            <a href="../../../or-tools/index.html">or-tools</a>/
            <a href="../../../or-tools/src/index.html">src</a>/
            <a href="../../../or-tools/src/constraint_solver/index.html">constraint_solver</a>/
            </tt></b></font>
        </td>
      </tr>
    </table>
  </div>
  <br />
    <!-- No subdirs found. -->
  <!-- End of header. -->
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
<h1>or-tools/src/constraint_solver/routing.h</h1><a href="routing_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">// Copyright 2010-2012 Google</span>
<a name="l00002"></a>00002 <span class="comment">// Licensed under the Apache License, Version 2.0 (the "License");</span>
<a name="l00003"></a>00003 <span class="comment">// you may not use this file except in compliance with the License.</span>
<a name="l00004"></a>00004 <span class="comment">// You may obtain a copy of the License at</span>
<a name="l00005"></a>00005 <span class="comment">//</span>
<a name="l00006"></a>00006 <span class="comment">//     http://www.apache.org/licenses/LICENSE-2.0</span>
<a name="l00007"></a>00007 <span class="comment">//</span>
<a name="l00008"></a>00008 <span class="comment">// Unless required by applicable law or agreed to in writing, software</span>
<a name="l00009"></a>00009 <span class="comment">// distributed under the License is distributed on an "AS IS" BASIS,</span>
<a name="l00010"></a>00010 <span class="comment">// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<a name="l00011"></a>00011 <span class="comment">// See the License for the specific language governing permissions and</span>
<a name="l00012"></a>00012 <span class="comment">// limitations under the License.</span>
<a name="l00013"></a>00013 
<a name="l00014"></a>00014 <span class="comment">// The vehicle routing library lets one model and solve generic vehicle routing</span>
<a name="l00015"></a>00015 <span class="comment">// problems ranging from the Traveling Salesman Problem to more complex</span>
<a name="l00016"></a>00016 <span class="comment">// problems such as the Capacitated Vehicle Routing Problem with Time Windows.</span>
<a name="l00017"></a>00017 <span class="comment">// The objective of a vehicle routing problem is to build routes covering a set</span>
<a name="l00018"></a>00018 <span class="comment">// of nodes minimizing the overall cost of the routes (usually proportional to</span>
<a name="l00019"></a>00019 <span class="comment">// the sum of the lengths of each segment of the routes) while respecting some</span>
<a name="l00020"></a>00020 <span class="comment">// problem-specific constraints (such as the length of a route). A route is</span>
<a name="l00021"></a>00021 <span class="comment">// equivalent to a path connecting nodes, starting/ending at specific</span>
<a name="l00022"></a>00022 <span class="comment">// starting/ending nodes.</span>
<a name="l00023"></a>00023 <span class="comment">// The term "vehicle routing" is historical and the category of problems solved</span>
<a name="l00024"></a>00024 <span class="comment">// is not limited to the routing of vehicles: any problem involving finding</span>
<a name="l00025"></a>00025 <span class="comment">// routes visiting a given number of nodes optimally falls under this category</span>
<a name="l00026"></a>00026 <span class="comment">// of problems, such as finding the optimal sequence in a playlist.</span>
<a name="l00027"></a>00027 <span class="comment">// The literature around vehicle routing problems is extremelly dense but one</span>
<a name="l00028"></a>00028 <span class="comment">// can find some basic introductions in the following links:</span>
<a name="l00029"></a>00029 <span class="comment">// http://en.wikipedia.org/wiki/Travelling_salesman_problem</span>
<a name="l00030"></a>00030 <span class="comment">// http://www.tsp.gatech.edu/history/index.html</span>
<a name="l00031"></a>00031 <span class="comment">// http://en.wikipedia.org/wiki/Vehicle_routing_problem</span>
<a name="l00032"></a>00032 <span class="comment">//</span>
<a name="l00033"></a>00033 <span class="comment">// The vehicle routing library is a vertical layer above the constraint</span>
<a name="l00034"></a>00034 <span class="comment">// programming library (constraint_programming:cp).</span>
<a name="l00035"></a>00035 <span class="comment">// One has access to all underlying constrained variables of the vehicle</span>
<a name="l00036"></a>00036 <span class="comment">// routing model which can therefore be enriched by adding any constraint</span>
<a name="l00037"></a>00037 <span class="comment">// available in the constraint programming library.</span>
<a name="l00038"></a>00038 <span class="comment">// There are two sets of variables available:</span>
<a name="l00039"></a>00039 <span class="comment">// - path variables:</span>
<a name="l00040"></a>00040 <span class="comment">//   * "next(i)" variables representing the immediate successor of the node</span>
<a name="l00041"></a>00041 <span class="comment">//     corresponding to i; use IndexToNode() to get the node corresponding to</span>
<a name="l00042"></a>00042 <span class="comment">//     a "next" variable value; note that node indices are strongly typed</span>
<a name="l00043"></a>00043 <span class="comment">//     integers (cf. base/int-type.h);</span>
<a name="l00044"></a>00044 <span class="comment">//   * "vehicle(i)" variables representing the vehicle route to which the</span>
<a name="l00045"></a>00045 <span class="comment">//     node corresponding to i belongs;</span>
<a name="l00046"></a>00046 <span class="comment">//   * "active(i)" boolean variables, true if the node corresponding to i is</span>
<a name="l00047"></a>00047 <span class="comment">//     visited and false if not; this can be false when nodes are either</span>
<a name="l00048"></a>00048 <span class="comment">//     optional or part of a disjunction;</span>
<a name="l00049"></a>00049 <span class="comment">// - dimension variables, used when one is accumulating quantities along routes,</span>
<a name="l00050"></a>00050 <span class="comment">//   such as weight or volume carried, distance or time:</span>
<a name="l00051"></a>00051 <span class="comment">//   * "cumul(i,d)" variables representing the quantity of dimension d when</span>
<a name="l00052"></a>00052 <span class="comment">//     arriving at the node corresponding to i;</span>
<a name="l00053"></a>00053 <span class="comment">//   * "transit(i,d)" variables representing the quantity of dimension d added</span>
<a name="l00054"></a>00054 <span class="comment">//     after visiting the node corresponding to i.</span>
<a name="l00055"></a>00055 <span class="comment">// Solving the vehicle routing problems is mainly done using approximate methods</span>
<a name="l00056"></a>00056 <span class="comment">// (namely local search,</span>
<a name="l00057"></a>00057 <span class="comment">// cf. http://en.wikipedia.org/wiki/Local_search_(optimization)), potentially</span>
<a name="l00058"></a>00058 <span class="comment">// combined with exact techniques based on dynamic programming and exhaustive</span>
<a name="l00059"></a>00059 <span class="comment">// tree search.</span>
<a name="l00060"></a>00060 <span class="comment">//</span>
<a name="l00061"></a>00061 <span class="comment">// Advanced tips: Flags are available to tune the search used to solve routing</span>
<a name="l00062"></a>00062 <span class="comment">// problems. Here is a quick overview of the ones one might want to modify:</span>
<a name="l00063"></a>00063 <span class="comment">// - Limiting the search for solutions:</span>
<a name="l00064"></a>00064 <span class="comment">//   * routing_solution_limit (default: kint64max): stop the search after</span>
<a name="l00065"></a>00065 <span class="comment">//     finding 'routing_solution_limit' improving solutions;</span>
<a name="l00066"></a>00066 <span class="comment">//   * routing_time_limit (default: kint64max): stop the search after</span>
<a name="l00067"></a>00067 <span class="comment">//     'routing_time_limit' milliseconds;</span>
<a name="l00068"></a>00068 <span class="comment">// - Customizing search:</span>
<a name="l00069"></a>00069 <span class="comment">//   * routing_first_solution (default: select the first node with an unbound</span>
<a name="l00070"></a>00070 <span class="comment">//     successor and connect it to the first available node): selects the</span>
<a name="l00071"></a>00071 <span class="comment">//     heuristic to build a first solution which will then be improved by local</span>
<a name="l00072"></a>00072 <span class="comment">//     search; possible values are GlobalCheapestArc (iteratively connect two</span>
<a name="l00073"></a>00073 <span class="comment">//     nodes which produce the cheapest route segment), LocalCheapestArc (select</span>
<a name="l00074"></a>00074 <span class="comment">//     the first node with an unbound successor and connect it to the node</span>
<a name="l00075"></a>00075 <span class="comment">//     which produces the cheapest route segment), PathCheapestArc (starting</span>
<a name="l00076"></a>00076 <span class="comment">//     from a route "start" node, connect it to the node which produces the</span>
<a name="l00077"></a>00077 <span class="comment">//     cheapest route segment, then extend the route by iterating on the last</span>
<a name="l00078"></a>00078 <span class="comment">//     node added to the route).</span>
<a name="l00079"></a>00079 <span class="comment">//   * Local search neighborhoods:</span>
<a name="l00080"></a>00080 <span class="comment">//     - routing_no_lns (default: false): forbids the use of Large Neighborhood</span>
<a name="l00081"></a>00081 <span class="comment">//       Search (LNS); LNS can find good solutions but is usually very slow.</span>
<a name="l00082"></a>00082 <span class="comment">//       Refer to the description of PATHLNS in the LocalSearchOperators enum</span>
<a name="l00083"></a>00083 <span class="comment">//       in constraint_solver.h for more information.</span>
<a name="l00084"></a>00084 <span class="comment">//     - routing_no_tsp (default: true): forbids the use of exact methods to</span>
<a name="l00085"></a>00085 <span class="comment">//       solve "sub"-traveling salesman problems (TSPs) of the current model</span>
<a name="l00086"></a>00086 <span class="comment">//       (such as sub-parts of a route, or one route in a multiple route</span>
<a name="l00087"></a>00087 <span class="comment">//       problem). Uses dynamic programming to solve such TSPs with a maximum</span>
<a name="l00088"></a>00088 <span class="comment">//       size (in number of nodes) up to cp_local_search_tsp_opt_size (flag with</span>
<a name="l00089"></a>00089 <span class="comment">//       a default value of 13 nodes). It is not activated by default because it</span>
<a name="l00090"></a>00090 <span class="comment">//       can slow down the search.</span>
<a name="l00091"></a>00091 <span class="comment">//   * Meta-heuritics: used to guide the search out of local minima found by</span>
<a name="l00092"></a>00092 <span class="comment">//     local search. Note that, in general, a search with metaheuristics</span>
<a name="l00093"></a>00093 <span class="comment">//     activated never stops, therefore one must specify a search limit.</span>
<a name="l00094"></a>00094 <span class="comment">//     Several types of metaheuristics are provided:</span>
<a name="l00095"></a>00095 <span class="comment">//     - routing_guided_local_search (default: false): activates guided local</span>
<a name="l00096"></a>00096 <span class="comment">//       search (cf. http://en.wikipedia.org/wiki/Guided_Local_Search);</span>
<a name="l00097"></a>00097 <span class="comment">//       this is generally the most efficient metaheuristic for vehicle</span>
<a name="l00098"></a>00098 <span class="comment">//       routing;</span>
<a name="l00099"></a>00099 <span class="comment">//     - routing_simulated_annealing (default: false): activates simulated</span>
<a name="l00100"></a>00100 <span class="comment">//       annealing (cf. http://en.wikipedia.org/wiki/Simulated_annealing);</span>
<a name="l00101"></a>00101 <span class="comment">//     - routing_tabu_search (default: false): activates tabu search (cf.</span>
<a name="l00102"></a>00102 <span class="comment">//       http://en.wikipedia.org/wiki/Tabu_search).</span>
<a name="l00103"></a>00103 <span class="comment">//</span>
<a name="l00104"></a>00104 <span class="comment">// Code sample:</span>
<a name="l00105"></a>00105 <span class="comment">// Here is a simple example solving a traveling salesman problem given a cost</span>
<a name="l00106"></a>00106 <span class="comment">// function callback (returns the cost of a route segment):</span>
<a name="l00107"></a>00107 <span class="comment">//</span>
<a name="l00108"></a>00108 <span class="comment">// - Define a custom distance/cost function from a node to another; in this</span>
<a name="l00109"></a>00109 <span class="comment">//   example just returns the sum of the node indices (note the conversion from</span>
<a name="l00110"></a>00110 <span class="comment">//   the strongly-typed indices to integers):</span>
<a name="l00111"></a>00111 <span class="comment">//</span>
<a name="l00112"></a>00112 <span class="comment">//     int64 MyDistance(RoutingModel::NodeIndex from,</span>
<a name="l00113"></a>00113 <span class="comment">//                      RoutingModel::NodeIndex to) {</span>
<a name="l00114"></a>00114 <span class="comment">//       return (from + to).value();</span>
<a name="l00115"></a>00115 <span class="comment">//     }</span>
<a name="l00116"></a>00116 <span class="comment">//</span>
<a name="l00117"></a>00117 <span class="comment">// - Create a routing model for a given problem size (int number of nodes) and</span>
<a name="l00118"></a>00118 <span class="comment">//   number of routes (here 1):</span>
<a name="l00119"></a>00119 <span class="comment">//</span>
<a name="l00120"></a>00120 <span class="comment">//     RoutingModel routing(...number of nodes..., 1);</span>
<a name="l00121"></a>00121 <span class="comment">//</span>
<a name="l00122"></a>00122 <span class="comment">// - Set the cost function by passing a permanent callback to the distance</span>
<a name="l00123"></a>00123 <span class="comment">//   accessor here. The callback has the following signature:</span>
<a name="l00124"></a>00124 <span class="comment">//   ResultCallback2&lt;int64, int64, int64&gt;.</span>
<a name="l00125"></a>00125 <span class="comment">//</span>
<a name="l00126"></a>00126 <span class="comment">//    routing.SetCost(NewPermanentCallback(MyDistance));</span>
<a name="l00127"></a>00127 <span class="comment">//</span>
<a name="l00128"></a>00128 <span class="comment">// - Find a solution using Solve(), returns a solution if any (owned by</span>
<a name="l00129"></a>00129 <span class="comment">//   routing):</span>
<a name="l00130"></a>00130 <span class="comment">//</span>
<a name="l00131"></a>00131 <span class="comment">//    const Assignment* solution = routing.Solve();</span>
<a name="l00132"></a>00132 <span class="comment">//    CHECK(solution != NULL);</span>
<a name="l00133"></a>00133 <span class="comment">//</span>
<a name="l00134"></a>00134 <span class="comment">// - Inspect the solution cost and route (only one route here:</span>
<a name="l00135"></a>00135 <span class="comment">//</span>
<a name="l00136"></a>00136 <span class="comment">//    LG &lt;&lt; "Cost " &lt;&lt; solution-&gt;ObjectiveValue();</span>
<a name="l00137"></a>00137 <span class="comment">//    const int route_number = 0;</span>
<a name="l00138"></a>00138 <span class="comment">//    for (int64 node = routing.Start(route_number);</span>
<a name="l00139"></a>00139 <span class="comment">//         !routing.IsEnd(node);</span>
<a name="l00140"></a>00140 <span class="comment">//         node = solution-&gt;Value(routing.NextVar(node))) {</span>
<a name="l00141"></a>00141 <span class="comment">//      LG &lt;&lt; routing.IndexToNode(node);</span>
<a name="l00142"></a>00142 <span class="comment">//    }</span>
<a name="l00143"></a>00143 <span class="comment">//</span>
<a name="l00144"></a>00144 <span class="comment">// More information on the usage of the routing library can be found here:</span>
<a name="l00145"></a>00145 <span class="comment">// More information on the range of vehicle routing problems the library can</span>
<a name="l00146"></a>00146 <span class="comment">// tackle can be found here:</span>
<a name="l00147"></a>00147 <span class="comment">// Keywords: Vehicle Routing, Traveling Salesman Problem, TSP, VRP, CVRPTW, PDP.</span>
<a name="l00148"></a>00148 
<a name="l00149"></a>00149 <span class="preprocessor">#ifndef OR_TOOLS_CONSTRAINT_SOLVER_ROUTING_H_</span>
<a name="l00150"></a>00150 <span class="preprocessor"></span><span class="preprocessor">#define OR_TOOLS_CONSTRAINT_SOLVER_ROUTING_H_</span>
<a name="l00151"></a>00151 <span class="preprocessor"></span>
<a name="l00152"></a>00152 <span class="preprocessor">#include &lt;stddef.h&gt;</span>
<a name="l00153"></a>00153 <span class="preprocessor">#include "base/hash.h"</span>
<a name="l00154"></a>00154 <span class="preprocessor">#include "base/hash.h"</span>
<a name="l00155"></a>00155 <span class="preprocessor">#include &lt;string&gt;</span>
<a name="l00156"></a>00156 <span class="preprocessor">#include &lt;utility&gt;</span>
<a name="l00157"></a>00157 <span class="preprocessor">#include &lt;vector&gt;</span>
<a name="l00158"></a>00158 
<a name="l00159"></a>00159 <span class="preprocessor">#include "base/callback-types.h"</span>
<a name="l00160"></a>00160 <span class="preprocessor">#include "base/commandlineflags.h"</span>
<a name="l00161"></a>00161 <span class="preprocessor">#include "base/integral_types.h"</span>
<a name="l00162"></a>00162 <span class="preprocessor">#include "base/macros.h"</span>
<a name="l00163"></a>00163 <span class="preprocessor">#include "base/scoped_ptr.h"</span>
<a name="l00164"></a>00164 <span class="preprocessor">#include "base/int-type-indexed-vector.h"</span>
<a name="l00165"></a>00165 <span class="preprocessor">#include "base/int-type.h"</span>
<a name="l00166"></a>00166 <span class="preprocessor">#include "base/hash.h"</span>
<a name="l00167"></a>00167 <span class="preprocessor">#include "<a class="code" href="constraint__solver_8h.html">constraint_solver/constraint_solver.h</a>"</span>
<a name="l00168"></a>00168 
<a name="l00169"></a>00169 <span class="keyword">namespace </span>operations_research {
<a name="l00170"></a>00170 
<a name="l00171"></a>00171 <span class="keyword">class </span>LocalSearchOperator;
<a name="l00172"></a>00172 <span class="keyword">class </span>RoutingCache;
<a name="l00173"></a>00173 
<a name="l00174"></a>00174 <span class="comment">// The type must be defined outside the class RoutingModel, SWIG does not parse</span>
<a name="l00175"></a>00175 <span class="comment">// it correctly if it's inside.</span>
<a name="l00176"></a>00176 <a class="code" href="namespaceoperations__research.html#30cd29caf636315c7dff36737342b4f8" title="The type must be defined outside the class RoutingModel, SWIG does not parse it correctly...">DEFINE_INT_TYPE</a>(_RoutingModel_NodeIndex, <span class="keywordtype">int</span>);
<a name="l00177"></a>00177 
<a name="l00178"></a><a class="code" href="classoperations__research_1_1RoutingModel.html">00178</a> <span class="keyword">class </span><a class="code" href="classoperations__research_1_1RoutingModel.html">RoutingModel</a> {
<a name="l00179"></a>00179  <span class="keyword">public</span>:
<a name="l00180"></a>00180   <span class="comment">// First solution strategies, used as starting point of local search.</span>
<a name="l00181"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#6f38b3ff9a2e455677856d97e339da6d">00181</a>   <span class="keyword">enum</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#6f38b3ff9a2e455677856d97e339da6d" title="First solution strategies, used as starting point of local search.">RoutingStrategy</a> {
<a name="l00182"></a>00182     <span class="comment">// Select the first node with an unbound successor and connect it to the</span>
<a name="l00183"></a>00183     <span class="comment">// first available node.</span>
<a name="l00184"></a>00184     <span class="comment">// This is equivalent to the CHOOSE_FIRST_UNBOUND strategy combined with</span>
<a name="l00185"></a>00185     <span class="comment">// ASSIGN_MIN_VALUE (cf. constraint_solver.h).</span>
<a name="l00186"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#6f38b3ff9a2e455677856d97e339da6d6f1cf5f6e92490db44f50b647f90f56c">00186</a>     <a class="code" href="classoperations__research_1_1RoutingModel.html#6f38b3ff9a2e455677856d97e339da6d6f1cf5f6e92490db44f50b647f90f56c" title="Select the first node with an unbound successor and connect it to the first available...">ROUTING_DEFAULT_STRATEGY</a>,
<a name="l00187"></a>00187     <span class="comment">// Iteratively connect two nodes which produce the cheapest route segment.</span>
<a name="l00188"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#6f38b3ff9a2e455677856d97e339da6dbb864ec796188b14106446600fd330f8">00188</a>     <a class="code" href="classoperations__research_1_1RoutingModel.html#6f38b3ff9a2e455677856d97e339da6dbb864ec796188b14106446600fd330f8" title="Iteratively connect two nodes which produce the cheapest route segment.">ROUTING_GLOBAL_CHEAPEST_ARC</a>,
<a name="l00189"></a>00189     <span class="comment">// Select the first node with an unbound successor and connect it to the</span>
<a name="l00190"></a>00190     <span class="comment">// node which produces the cheapest route segment.</span>
<a name="l00191"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#6f38b3ff9a2e455677856d97e339da6d4c2534a4236ed8b1c937467da71a55a7">00191</a>     <a class="code" href="classoperations__research_1_1RoutingModel.html#6f38b3ff9a2e455677856d97e339da6d4c2534a4236ed8b1c937467da71a55a7" title="Select the first node with an unbound successor and connect it to the node which...">ROUTING_LOCAL_CHEAPEST_ARC</a>,
<a name="l00192"></a>00192     <span class="comment">// Starting from a route "start" node, connect it to the node which produces</span>
<a name="l00193"></a>00193     <span class="comment">// the cheapest route segment, then extend the route by iterating on the</span>
<a name="l00194"></a>00194     <span class="comment">// last node added to the route.</span>
<a name="l00195"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#6f38b3ff9a2e455677856d97e339da6db84d29872d22f4d9cf1a1fd21c05dcf4">00195</a>     <a class="code" href="classoperations__research_1_1RoutingModel.html#6f38b3ff9a2e455677856d97e339da6db84d29872d22f4d9cf1a1fd21c05dcf4" title="Starting from a route &amp;quot;start&amp;quot; node, connect it to the node which produces...">ROUTING_PATH_CHEAPEST_ARC</a>,
<a name="l00196"></a>00196     <span class="comment">// Same as ROUTING_PATH_CHEAPEST_ARC, except that arc costs are evaluated</span>
<a name="l00197"></a>00197     <span class="comment">// using the function passed to RoutingModel::SetFirstSolutionEvaluator().</span>
<a name="l00198"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#6f38b3ff9a2e455677856d97e339da6da62cb62928ab4fdd761e7568e8737083">00198</a>     <a class="code" href="classoperations__research_1_1RoutingModel.html#6f38b3ff9a2e455677856d97e339da6da62cb62928ab4fdd761e7568e8737083" title="Same as ROUTING_PATH_CHEAPEST_ARC, except that arc costs are evaluated using the...">ROUTING_EVALUATOR_STRATEGY</a>,
<a name="l00199"></a>00199     <span class="comment">// Make all node inactive. Only finds a solution if nodes are optional (are</span>
<a name="l00200"></a>00200     <span class="comment">// element of a disjunction constraint with a finite penalty cost).</span>
<a name="l00201"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#6f38b3ff9a2e455677856d97e339da6de11807c0a7813e4ace23425911f4c582">00201</a>     <a class="code" href="classoperations__research_1_1RoutingModel.html#6f38b3ff9a2e455677856d97e339da6de11807c0a7813e4ace23425911f4c582" title="Make all node inactive.">ROUTING_ALL_UNPERFORMED</a>,
<a name="l00202"></a>00202     <span class="comment">// Iteratively build a solution by inserting nodes at their cheapest (best)</span>
<a name="l00203"></a>00203     <span class="comment">// position. As of 2/2012, only works on models with optional nodes</span>
<a name="l00204"></a>00204     <span class="comment">// (with finite penalty costs).</span>
<a name="l00205"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#6f38b3ff9a2e455677856d97e339da6d9d13a87ad6a77f4fc63f28af90451c6e">00205</a>     <a class="code" href="classoperations__research_1_1RoutingModel.html#6f38b3ff9a2e455677856d97e339da6d9d13a87ad6a77f4fc63f28af90451c6e" title="Iteratively build a solution by inserting nodes at their cheapest (best) position...">ROUTING_BEST_INSERTION</a>
<a name="l00206"></a>00206   };
<a name="l00207"></a>00207 
<a name="l00208"></a>00208   <span class="comment">// Metaheuristics used to guide the search. Apart greedy descent, they will</span>
<a name="l00209"></a>00209   <span class="comment">// try to escape local minima.</span>
<a name="l00210"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#0f0bd97e25af059ab2e8e7f263afc8e1">00210</a>   <span class="keyword">enum</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#0f0bd97e25af059ab2e8e7f263afc8e1" title="Metaheuristics used to guide the search.">RoutingMetaheuristic</a> {
<a name="l00211"></a>00211     <span class="comment">// Accepts improving (cost-reducing) local search neighbors until a local</span>
<a name="l00212"></a>00212     <span class="comment">// minimum is reached. This is the default heuristic.</span>
<a name="l00213"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#0f0bd97e25af059ab2e8e7f263afc8e1582d58f88269611b1065f8c4c5e58fed">00213</a>     <a class="code" href="classoperations__research_1_1RoutingModel.html#0f0bd97e25af059ab2e8e7f263afc8e1582d58f88269611b1065f8c4c5e58fed" title="Accepts improving (cost-reducing) local search neighbors until a local minimum is...">ROUTING_GREEDY_DESCENT</a>,
<a name="l00214"></a>00214     <span class="comment">// Uses guided local search to escape local minima</span>
<a name="l00215"></a>00215     <span class="comment">// (cf. http://en.wikipedia.org/wiki/Guided_Local_Search); this is</span>
<a name="l00216"></a>00216     <span class="comment">// generally the most efficient metaheuristic for vehicle routing.</span>
<a name="l00217"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#0f0bd97e25af059ab2e8e7f263afc8e189a5042196881240e6b78a52c87b1588">00217</a>     <a class="code" href="classoperations__research_1_1RoutingModel.html#0f0bd97e25af059ab2e8e7f263afc8e189a5042196881240e6b78a52c87b1588" title="Uses guided local search to escape local minima (cf.">ROUTING_GUIDED_LOCAL_SEARCH</a>,
<a name="l00218"></a>00218     <span class="comment">// Uses simulated annealing to escape local minima</span>
<a name="l00219"></a>00219     <span class="comment">// (cf. http://en.wikipedia.org/wiki/Simulated_annealing).</span>
<a name="l00220"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#0f0bd97e25af059ab2e8e7f263afc8e1a166bff87b6170318a34b1af38fc98fe">00220</a>     <a class="code" href="classoperations__research_1_1RoutingModel.html#0f0bd97e25af059ab2e8e7f263afc8e1a166bff87b6170318a34b1af38fc98fe" title="Uses simulated annealing to escape local minima (cf.">ROUTING_SIMULATED_ANNEALING</a>,
<a name="l00221"></a>00221     <span class="comment">// Uses tabu search to escape local minima</span>
<a name="l00222"></a>00222     <span class="comment">// (cf. http://en.wikipedia.org/wiki/Tabu_search).</span>
<a name="l00223"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#0f0bd97e25af059ab2e8e7f263afc8e10dd042e16dd28cfdd370382de2f51a35">00223</a>     <a class="code" href="classoperations__research_1_1RoutingModel.html#0f0bd97e25af059ab2e8e7f263afc8e10dd042e16dd28cfdd370382de2f51a35" title="Uses tabu search to escape local minima (cf.">ROUTING_TABU_SEARCH</a>
<a name="l00224"></a>00224   };
<a name="l00225"></a>00225 
<a name="l00226"></a>00226   <span class="comment">// Status of the search.</span>
<a name="l00227"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#328a19213729eec49288128061bc2044">00227</a>   <span class="keyword">enum</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#328a19213729eec49288128061bc2044" title="Status of the search.">Status</a> {
<a name="l00228"></a>00228     <span class="comment">// Problem not solved yet (before calling RoutingModel::Solve()).</span>
<a name="l00229"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#328a19213729eec49288128061bc204473b2e79d6934957ec86f60a69036e055">00229</a>     <a class="code" href="classoperations__research_1_1RoutingModel.html#328a19213729eec49288128061bc204473b2e79d6934957ec86f60a69036e055" title="Problem not solved yet (before calling RoutingModel::Solve()).">ROUTING_NOT_SOLVED</a>,
<a name="l00230"></a>00230     <span class="comment">// Problem solved successfully after calling RoutingModel::Solve().</span>
<a name="l00231"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#328a19213729eec49288128061bc2044fb2bbe1690a8f9be1575ade98e4e61dd">00231</a>     <a class="code" href="classoperations__research_1_1RoutingModel.html#328a19213729eec49288128061bc2044fb2bbe1690a8f9be1575ade98e4e61dd" title="Problem solved successfully after calling RoutingModel::Solve().">ROUTING_SUCCESS</a>,
<a name="l00232"></a>00232     <span class="comment">// No solution found to the problem after calling RoutingModel::Solve().</span>
<a name="l00233"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#328a19213729eec49288128061bc2044caf3d0fb83c0c1be4881362c0e2e0592">00233</a>     <a class="code" href="classoperations__research_1_1RoutingModel.html#328a19213729eec49288128061bc2044caf3d0fb83c0c1be4881362c0e2e0592" title="No solution found to the problem after calling RoutingModel::Solve().">ROUTING_FAIL</a>,
<a name="l00234"></a>00234     <span class="comment">// Time limit reached before finding a solution with RoutingModel::Solve().</span>
<a name="l00235"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#328a19213729eec49288128061bc2044a8b79310730408de7bae61835301a93e">00235</a>     <a class="code" href="classoperations__research_1_1RoutingModel.html#328a19213729eec49288128061bc2044a8b79310730408de7bae61835301a93e" title="Time limit reached before finding a solution with RoutingModel::Solve().">ROUTING_FAIL_TIMEOUT</a>
<a name="l00236"></a>00236   };
<a name="l00237"></a>00237 
<a name="l00238"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#2e9f7da1126111a69ee0b7bcf7edeffe">00238</a>   <span class="keyword">typedef</span> _RoutingModel_NodeIndex <a class="code" href="classoperations__research_1_1RoutingModel.html#2e9f7da1126111a69ee0b7bcf7edeffe">NodeIndex</a>;
<a name="l00239"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#5ad22b1565f2e5b1735601a824629289">00239</a>   <span class="keyword">typedef</span> ResultCallback2&lt;int64, NodeIndex, NodeIndex&gt; <a class="code" href="classoperations__research_1_1RoutingModel.html#5ad22b1565f2e5b1735601a824629289">NodeEvaluator2</a>;
<a name="l00240"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#4251c2ca5b1558dc69e696991c853ae3">00240</a>   <span class="keyword">typedef</span> std::vector&lt;std::pair&lt;int, int&gt; &gt; <a class="code" href="classoperations__research_1_1RoutingModel.html#4251c2ca5b1558dc69e696991c853ae3">NodePairs</a>;
<a name="l00241"></a>00241 
<a name="l00242"></a>00242   <span class="comment">// Constants with an index of the first node (to be used in for loops for</span>
<a name="l00243"></a>00243   <span class="comment">// iteration), and a special index to signalize an invalid/unused value.</span>
<a name="l00244"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#2fe3671c7bac6070d8c3f03a12722c70">00244</a>   <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#2e9f7da1126111a69ee0b7bcf7edeffe">NodeIndex</a> <a class="code" href="classoperations__research_1_1RoutingModel.html#2fe3671c7bac6070d8c3f03a12722c70" title="Constants with an index of the first node (to be used in for loops for iteration)...">kFirstNode</a>;
<a name="l00245"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#86465650deeb78a3ff59ac0fe5af60bf">00245</a>   <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#2e9f7da1126111a69ee0b7bcf7edeffe">NodeIndex</a> <a class="code" href="classoperations__research_1_1RoutingModel.html#86465650deeb78a3ff59ac0fe5af60bf">kInvalidNodeIndex</a>;
<a name="l00246"></a>00246 
<a name="l00247"></a>00247   <span class="comment">// Supposes a single depot. A depot is the start and end node of the route of</span>
<a name="l00248"></a>00248   <span class="comment">// a vehicle.</span>
<a name="l00249"></a>00249   <a class="code" href="classoperations__research_1_1RoutingModel.html#67e90b8e5fba64a285e2eed07a39b2ca" title="Supposes a single depot.">RoutingModel</a>(<span class="keywordtype">int</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#20c1bf5b1ac1353c9e132774f3f7e1df" title="Sizes and indices Returns the number of nodes in the model.">nodes</a>, <span class="keywordtype">int</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#9236103b3dca8a4112bd2a8be05b0b71" title="Returns the number of vehicle routes in the model.">vehicles</a>);
<a name="l00250"></a>00250   <span class="comment">// Constructor taking a vector of (start node, end node) pairs for each</span>
<a name="l00251"></a>00251   <span class="comment">// vehicle route. Used to model multiple depots.</span>
<a name="l00252"></a>00252   <a class="code" href="classoperations__research_1_1RoutingModel.html#67e90b8e5fba64a285e2eed07a39b2ca" title="Supposes a single depot.">RoutingModel</a>(<span class="keywordtype">int</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#20c1bf5b1ac1353c9e132774f3f7e1df" title="Sizes and indices Returns the number of nodes in the model.">nodes</a>,
<a name="l00253"></a>00253                <span class="keywordtype">int</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#9236103b3dca8a4112bd2a8be05b0b71" title="Returns the number of vehicle routes in the model.">vehicles</a>,
<a name="l00254"></a>00254                <span class="keyword">const</span> std::vector&lt;std::pair&lt;NodeIndex, NodeIndex&gt; &gt;&amp; start_end);
<a name="l00255"></a>00255   <span class="comment">// Constructor taking vectors of start nodes and end nodes for each</span>
<a name="l00256"></a>00256   <span class="comment">// vehicle route. Used to model multiple depots.</span>
<a name="l00257"></a>00257   <span class="comment">// TODO(user): added to simplify SWIG wrapping. Remove when swigging</span>
<a name="l00258"></a>00258   <span class="comment">// std::vector&lt;std::pair&lt;int, int&gt; &gt; is ok.</span>
<a name="l00259"></a>00259   <a class="code" href="classoperations__research_1_1RoutingModel.html#67e90b8e5fba64a285e2eed07a39b2ca" title="Supposes a single depot.">RoutingModel</a>(<span class="keywordtype">int</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#20c1bf5b1ac1353c9e132774f3f7e1df" title="Sizes and indices Returns the number of nodes in the model.">nodes</a>,
<a name="l00260"></a>00260                <span class="keywordtype">int</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#9236103b3dca8a4112bd2a8be05b0b71" title="Returns the number of vehicle routes in the model.">vehicles</a>,
<a name="l00261"></a>00261                <span class="keyword">const</span> std::vector&lt;NodeIndex&gt;&amp; starts,
<a name="l00262"></a>00262                <span class="keyword">const</span> std::vector&lt;NodeIndex&gt;&amp; ends);
<a name="l00263"></a>00263   <a class="code" href="classoperations__research_1_1RoutingModel.html#6ee4a1c4dda01e2138f79ed5ec913754">~RoutingModel</a>();
<a name="l00264"></a>00264 
<a name="l00265"></a>00265   <span class="comment">// Model creation</span>
<a name="l00266"></a>00266 
<a name="l00267"></a>00267   <span class="comment">// Methods to add dimensions to routes; dimensions represent quantities</span>
<a name="l00268"></a>00268   <span class="comment">// accumulated at nodes along the routes. They represent quantities such as</span>
<a name="l00269"></a>00269   <span class="comment">// weights or volumes carried along the route, or distance or times.</span>
<a name="l00270"></a>00270   <span class="comment">// Quantities at a node are represented by "cumul" variables and the increase</span>
<a name="l00271"></a>00271   <span class="comment">// or decrease of quantities between nodes are represented by "transit"</span>
<a name="l00272"></a>00272   <span class="comment">// variables. These variables are linked as follows:</span>
<a name="l00273"></a>00273   <span class="comment">// if j == next(i), cumul(j) = cumul(i) + transit(i) + slack(i)</span>
<a name="l00274"></a>00274   <span class="comment">// where slack is a positive slack variable (can represent waiting times for</span>
<a name="l00275"></a>00275   <span class="comment">// a time dimension).</span>
<a name="l00276"></a>00276 
<a name="l00277"></a>00277   <span class="comment">// Creates a dimension where the transit variable is constrained to be</span>
<a name="l00278"></a>00278   <span class="comment">// equal to evaluator(i, next(i)); 'slack_max' is the upper bound of the</span>
<a name="l00279"></a>00279   <span class="comment">// slack variable and 'capacity' is the upper bound of the cumul variables.</span>
<a name="l00280"></a>00280   <span class="comment">// 'name' is the name used to reference the dimension; this name is used to</span>
<a name="l00281"></a>00281   <span class="comment">// get cumul and transit variables from the routing model.</span>
<a name="l00282"></a>00282   <span class="keywordtype">void</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#0c519ba1ff5b906df2a576451feb379c" title="Model creation.">AddDimension</a>(<a class="code" href="classoperations__research_1_1RoutingModel.html#5ad22b1565f2e5b1735601a824629289">NodeEvaluator2</a>* evaluator,
<a name="l00283"></a>00283                     int64 slack_max,
<a name="l00284"></a>00284                     int64 capacity,
<a name="l00285"></a>00285                     <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; <a class="code" href="default__search_8cc.html#1848ae81740c68c2502b2f176cfadcef" title="A name for logging purposes.">name</a>);
<a name="l00286"></a>00286   <span class="comment">// Creates a dimension where the transit variable is constrained to be</span>
<a name="l00287"></a>00287   <span class="comment">// equal to 'value'; 'capacity' is the upper bound of the cumul variables.</span>
<a name="l00288"></a>00288   <span class="comment">// 'name' is the name used to reference the dimension; this name is used to</span>
<a name="l00289"></a>00289   <span class="comment">// get cumul and transit variables from the routing model.</span>
<a name="l00290"></a>00290   <span class="keywordtype">void</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#366617606fccc8017b91a5efeae6c4cf" title="Creates a dimension where the transit variable is constrained to be equal to &amp;#39;value&amp;#39;;...">AddConstantDimension</a>(int64 <a class="code" href="search_8cc.html#21edc7ca4cc5802c8779d68556bc09cf">value</a>, int64 capacity, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; <a class="code" href="default__search_8cc.html#1848ae81740c68c2502b2f176cfadcef" title="A name for logging purposes.">name</a>);
<a name="l00291"></a>00291   <span class="comment">// Creates a dimension where the transit variable is constrained to be</span>
<a name="l00292"></a>00292   <span class="comment">// equal to 'values[i]' for node i; 'capacity' is the upper bound of</span>
<a name="l00293"></a>00293   <span class="comment">// the cumul variables. 'name' is the name used to reference the dimension;</span>
<a name="l00294"></a>00294   <span class="comment">// this name is used to get cumul and transit variables from the routing</span>
<a name="l00295"></a>00295   <span class="comment">// model.</span>
<a name="l00296"></a>00296   <span class="keywordtype">void</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#665b56459ca82c4d791477466b8e621c" title="Creates a dimension where the transit variable is constrained to be equal to &amp;#39;values[i]&amp;#39;...">AddVectorDimension</a>(<span class="keyword">const</span> int64* values,
<a name="l00297"></a>00297                           int64 capacity,
<a name="l00298"></a>00298                           <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; <a class="code" href="default__search_8cc.html#1848ae81740c68c2502b2f176cfadcef" title="A name for logging purposes.">name</a>);
<a name="l00299"></a>00299   <span class="comment">// Creates a dimension where the transit variable is constrained to be</span>
<a name="l00300"></a>00300   <span class="comment">// equal to 'values[i][next[i]' for node i; 'capacity' is the upper bound of</span>
<a name="l00301"></a>00301   <span class="comment">// the cumul variables. 'name' is the name used to reference the dimension;</span>
<a name="l00302"></a>00302   <span class="comment">// this name is used to get cumul and transit variables from the routing</span>
<a name="l00303"></a>00303   <span class="comment">// model.</span>
<a name="l00304"></a>00304   <span class="keywordtype">void</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#7d00a87827f4216f9d209a82034e220a" title="Creates a dimension where the transit variable is constrained to be equal to &amp;#39;values[i][next[i]&amp;...">AddMatrixDimension</a>(<span class="keyword">const</span> int64* <span class="keyword">const</span>* values,
<a name="l00305"></a>00305                           int64 capacity,
<a name="l00306"></a>00306                           <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; <a class="code" href="default__search_8cc.html#1848ae81740c68c2502b2f176cfadcef" title="A name for logging purposes.">name</a>);
<a name="l00307"></a>00307   <span class="comment">// Constrains all nodes to be active (to belong to a route).</span>
<a name="l00308"></a>00308   <span class="keywordtype">void</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#fa5489925a39e8484fea85ad916ab72b" title="Constrains all nodes to be active (to belong to a route).">AddAllActive</a>();
<a name="l00309"></a>00309   <span class="comment">// Adds a disjunction constraint on the nodes: exactly one of the nodes is</span>
<a name="l00310"></a>00310   <span class="comment">// active. Start and end nodes of any vehicle cannot be part of a disjunction.</span>
<a name="l00311"></a>00311   <span class="keywordtype">void</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#c2388945ac0d9e706b72c75a82f4baf0" title="Adds a disjunction constraint on the nodes: exactly one of the nodes is active.">AddDisjunction</a>(<span class="keyword">const</span> std::vector&lt;NodeIndex&gt;&amp; <a class="code" href="classoperations__research_1_1RoutingModel.html#20c1bf5b1ac1353c9e132774f3f7e1df" title="Sizes and indices Returns the number of nodes in the model.">nodes</a>);
<a name="l00312"></a>00312   <span class="comment">// Adds a penalized disjunction constraint on the nodes: at most one of the</span>
<a name="l00313"></a>00313   <span class="comment">// nodes is active; if none are active a penalty cost is applied (this cost</span>
<a name="l00314"></a>00314   <span class="comment">// is added to the global cost function).</span>
<a name="l00315"></a>00315   <span class="comment">// This is equivalent to adding the constraint:</span>
<a name="l00316"></a>00316   <span class="comment">// p + Sum(i)active[i] == 1, where p is a boolean variable</span>
<a name="l00317"></a>00317   <span class="comment">// and the following cost to the cost function:</span>
<a name="l00318"></a>00318   <span class="comment">// p * penalty.</span>
<a name="l00319"></a>00319   <span class="comment">// "penalty" must be positive.</span>
<a name="l00320"></a>00320   <span class="comment">// Note: passing a vector with a single node will model an optional node</span>
<a name="l00321"></a>00321   <span class="comment">// with a penalty cost if it is not visited.</span>
<a name="l00322"></a>00322   <span class="keywordtype">void</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#c2388945ac0d9e706b72c75a82f4baf0" title="Adds a disjunction constraint on the nodes: exactly one of the nodes is active.">AddDisjunction</a>(<span class="keyword">const</span> std::vector&lt;NodeIndex&gt;&amp; <a class="code" href="classoperations__research_1_1RoutingModel.html#20c1bf5b1ac1353c9e132774f3f7e1df" title="Sizes and indices Returns the number of nodes in the model.">nodes</a>, int64 penalty);
<a name="l00323"></a>00323 <span class="preprocessor">#if defined(SWIGPYTHON)</span>
<a name="l00324"></a>00324 <span class="preprocessor"></span>  <span class="keywordtype">void</span> AddDisjunctionWithPenalty(<span class="keyword">const</span> std::vector&lt;NodeIndex&gt;&amp; <a class="code" href="classoperations__research_1_1RoutingModel.html#20c1bf5b1ac1353c9e132774f3f7e1df" title="Sizes and indices Returns the number of nodes in the model.">nodes</a>,
<a name="l00325"></a>00325                                  int64 penalty) {
<a name="l00326"></a>00326     <a class="code" href="classoperations__research_1_1RoutingModel.html#c2388945ac0d9e706b72c75a82f4baf0" title="Adds a disjunction constraint on the nodes: exactly one of the nodes is active.">AddDisjunction</a>(nodes, penalty);
<a name="l00327"></a>00327   }
<a name="l00328"></a>00328 <span class="preprocessor">#endif  // SWIGPYTHON</span>
<a name="l00329"></a>00329 <span class="preprocessor"></span>  <span class="comment">// Notifies that node1 and node2 form a pair of nodes which should belong</span>
<a name="l00330"></a>00330   <span class="comment">// to the same route. This methods helps the search find better solutions,</span>
<a name="l00331"></a>00331   <span class="comment">// especially in the local search phase.</span>
<a name="l00332"></a>00332   <span class="comment">// It should be called each time you have an equality constraint linking</span>
<a name="l00333"></a>00333   <span class="comment">// the vehicle variables of two node (including for instance pickup and</span>
<a name="l00334"></a>00334   <span class="comment">// delivery problems):</span>
<a name="l00335"></a>00335   <span class="comment">//     Solver* const solver = routing.solver();</span>
<a name="l00336"></a>00336   <span class="comment">//     solver-&gt;AddConstraint(solver-&gt;MakeEquality(</span>
<a name="l00337"></a>00337   <span class="comment">//         routing.VehicleVar(routing.NodeToIndex(node1)),</span>
<a name="l00338"></a>00338   <span class="comment">//         routing.VehicleVar(routing.NodeToIndex(node2))));</span>
<a name="l00339"></a>00339   <span class="comment">//     solver-&gt;AddPickupAndDelivery(node1, node2);</span>
<a name="l00340"></a>00340   <span class="comment">//</span>
<a name="l00341"></a>00341   <span class="comment">// TODO(user): Remove this when model introspection detects linked nodes.</span>
<a name="l00342"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#646c16f383b852c39804223d77520e07">00342</a>   <span class="keywordtype">void</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#646c16f383b852c39804223d77520e07">AddPickupAndDelivery</a>(<a class="code" href="classoperations__research_1_1RoutingModel.html#2e9f7da1126111a69ee0b7bcf7edeffe">NodeIndex</a> node1, <a class="code" href="classoperations__research_1_1RoutingModel.html#2e9f7da1126111a69ee0b7bcf7edeffe">NodeIndex</a> node2) {
<a name="l00343"></a>00343     pickup_delivery_pairs_.push_back(std::make_pair(<a class="code" href="classoperations__research_1_1RoutingModel.html#6c88d9d5da962886bfe0924bc5ea6457" title="Returns the variable index from a node value.">NodeToIndex</a>(node1),
<a name="l00344"></a>00344                                                     <a class="code" href="classoperations__research_1_1RoutingModel.html#6c88d9d5da962886bfe0924bc5ea6457" title="Returns the variable index from a node value.">NodeToIndex</a>(node2)));
<a name="l00345"></a>00345   }
<a name="l00346"></a>00346   <span class="comment">// Makes 'depot' the starting node of all routes.</span>
<a name="l00347"></a>00347   <span class="keywordtype">void</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#fc62358888d00d45c4769cdc6e3d3cbb" title="Makes &amp;#39;depot&amp;#39; the starting node of all routes.">SetDepot</a>(<a class="code" href="classoperations__research_1_1RoutingModel.html#2e9f7da1126111a69ee0b7bcf7edeffe">NodeIndex</a> depot);
<a name="l00348"></a>00348   <span class="comment">// Sets the cost function of the model such that the cost of a segment of a</span>
<a name="l00349"></a>00349   <span class="comment">// route between node 'from' and 'to' is evaluator(from, to), whatever the</span>
<a name="l00350"></a>00350   <span class="comment">// route or vehicle performing the route.</span>
<a name="l00351"></a>00351   <span class="keywordtype">void</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#ad67d6674b1bbfd192b094a78b98ae00" title="Sets the cost function of the model such that the cost of a segment of a route between...">SetCost</a>(<a class="code" href="classoperations__research_1_1RoutingModel.html#5ad22b1565f2e5b1735601a824629289">NodeEvaluator2</a>* evaluator);
<a name="l00352"></a>00352   <span class="comment">// Sets the cost function for a given vehicle route.</span>
<a name="l00353"></a>00353   <span class="keywordtype">void</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#5acf5c0059bb744313072e90f9a6c13d" title="Sets the cost function for a given vehicle route.">SetVehicleCost</a>(<span class="keywordtype">int</span> vehicle, <a class="code" href="classoperations__research_1_1RoutingModel.html#5ad22b1565f2e5b1735601a824629289">NodeEvaluator2</a>* evaluator);
<a name="l00354"></a>00354   <span class="comment">// The fixed cost of a route is taken into account if the route is</span>
<a name="l00355"></a>00355   <span class="comment">// not empty, aka there's at least one node on the route other than the</span>
<a name="l00356"></a>00356   <span class="comment">// first and last nodes.</span>
<a name="l00357"></a>00357   <span class="comment">// Gets the fixed cost of all vehicle routes if they are all the same;</span>
<a name="l00358"></a>00358   <span class="comment">// otherwise returns the fixed cost of the first vehicle route.</span>
<a name="l00359"></a>00359   <span class="comment">// Deprecated by GetVehicleFixedCost().</span>
<a name="l00360"></a>00360   int64 <a class="code" href="classoperations__research_1_1RoutingModel.html#89f79076ce6ef6d5587f2ebe3439a073" title="The fixed cost of a route is taken into account if the route is not empty, aka there&amp;#39;s...">GetRouteFixedCost</a>() <span class="keyword">const</span>;
<a name="l00361"></a>00361   <span class="comment">// Sets the fixed cost of all vehicle routes. It is equivalent to calling</span>
<a name="l00362"></a>00362   <span class="comment">// SetVehicleFixedCost on all vehicle routes.</span>
<a name="l00363"></a>00363   <span class="keywordtype">void</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#f387904bbb3960d15461d10e307f28f5" title="Sets the fixed cost of all vehicle routes.">SetRouteFixedCost</a>(int64 cost);
<a name="l00364"></a>00364   <span class="comment">// Returns the route fixed cost taken into account if the route of the</span>
<a name="l00365"></a>00365   <span class="comment">// vehicle is not empty, aka there's at least one node on the route other than</span>
<a name="l00366"></a>00366   <span class="comment">// the first and last nodes.</span>
<a name="l00367"></a>00367   int64 <a class="code" href="classoperations__research_1_1RoutingModel.html#619c7630314932daf1b6338eb2285027" title="Returns the route fixed cost taken into account if the route of the vehicle is not...">GetVehicleFixedCost</a>(<span class="keywordtype">int</span> vehicle) <span class="keyword">const</span>;
<a name="l00368"></a>00368   <span class="comment">// Sets the fixed cost of one vehicle route.</span>
<a name="l00369"></a>00369   <span class="keywordtype">void</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#51249142dcbabc08d16ae7f8dac64ab7" title="Sets the fixed cost of one vehicle route.">SetVehicleFixedCost</a>(<span class="keywordtype">int</span> vehicle, int64 cost);
<a name="l00370"></a>00370 
<a name="l00371"></a>00371 
<a name="l00372"></a>00372   <span class="comment">// Search</span>
<a name="l00373"></a>00373   <span class="comment">// Returns the strategy used to build a first solution.</span>
<a name="l00374"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#0557e242e3fb2350c80576dc56f6e534">00374</a>   <a class="code" href="classoperations__research_1_1RoutingModel.html#6f38b3ff9a2e455677856d97e339da6d" title="First solution strategies, used as starting point of local search.">RoutingStrategy</a> <a class="code" href="classoperations__research_1_1RoutingModel.html#0557e242e3fb2350c80576dc56f6e534" title="Search Returns the strategy used to build a first solution.">first_solution_strategy</a>()<span class="keyword"> const </span>{
<a name="l00375"></a>00375     <span class="keywordflow">return</span> first_solution_strategy_;
<a name="l00376"></a>00376   }
<a name="l00377"></a>00377   <span class="comment">// Sets the strategy used to build a first solution.</span>
<a name="l00378"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#68b6f5c365d384256ff87eff7d8b4920">00378</a>   <span class="keywordtype">void</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#68b6f5c365d384256ff87eff7d8b4920" title="Sets the strategy used to build a first solution.">set_first_solution_strategy</a>(<a class="code" href="classoperations__research_1_1RoutingModel.html#6f38b3ff9a2e455677856d97e339da6d" title="First solution strategies, used as starting point of local search.">RoutingStrategy</a> strategy) {
<a name="l00379"></a>00379     first_solution_strategy_ = strategy;
<a name="l00380"></a>00380   }
<a name="l00381"></a>00381   <span class="comment">// Gets/sets the evaluator used when the first solution heuristic is set to</span>
<a name="l00382"></a>00382   <span class="comment">// ROUTING_EVALUATOR_STRATEGY (variant of ROUTING_PATH_CHEAPEST_ARC using</span>
<a name="l00383"></a>00383   <span class="comment">// 'evaluator' to sort node segments).</span>
<a name="l00384"></a>00384 <span class="preprocessor">#ifndef SWIG</span>
<a name="l00385"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#81b797890236948ef7aa87d781ad7ec7">00385</a> <span class="preprocessor"></span>  <a class="code" href="classoperations__research_1_1Solver.html#487b521ee809f0f4ee397b9f6ea06f59">Solver::IndexEvaluator2</a>* <a class="code" href="classoperations__research_1_1RoutingModel.html#81b797890236948ef7aa87d781ad7ec7" title="Gets/sets the evaluator used when the first solution heuristic is set to ROUTING_EVALUATOR_STRATEGY...">first_solution_evaluator</a>()<span class="keyword"> const </span>{
<a name="l00386"></a>00386     <span class="keywordflow">return</span> first_solution_evaluator_.get();
<a name="l00387"></a>00387   }
<a name="l00388"></a>00388 <span class="preprocessor">#endif</span>
<a name="l00389"></a>00389 <span class="preprocessor"></span>  <span class="comment">// Takes ownership of evaluator.</span>
<a name="l00390"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#5853301edd4fdc7f45cf38a7bb2ec049">00390</a>   <span class="keywordtype">void</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#5853301edd4fdc7f45cf38a7bb2ec049" title="Takes ownership of evaluator.">SetFirstSolutionEvaluator</a>(<a class="code" href="classoperations__research_1_1Solver.html#487b521ee809f0f4ee397b9f6ea06f59">Solver::IndexEvaluator2</a>* evaluator) {
<a name="l00391"></a>00391     first_solution_evaluator_.reset(evaluator);
<a name="l00392"></a>00392   }
<a name="l00393"></a>00393   <span class="comment">// If a first solution flag has been set (to a value different than Default),</span>
<a name="l00394"></a>00394   <span class="comment">// returns the corresponding strategy, otherwise returns the strategy which</span>
<a name="l00395"></a>00395   <span class="comment">// was set.</span>
<a name="l00396"></a>00396   <a class="code" href="classoperations__research_1_1RoutingModel.html#6f38b3ff9a2e455677856d97e339da6d" title="First solution strategies, used as starting point of local search.">RoutingStrategy</a> <a class="code" href="classoperations__research_1_1RoutingModel.html#da509d882b2aed55dc59021c3a149c7e" title="If a first solution flag has been set (to a value different than Default), returns...">GetSelectedFirstSolutionStrategy</a>() <span class="keyword">const</span>;
<a name="l00397"></a>00397   <span class="comment">// Adds a local search operator to the set of operators used to solve the</span>
<a name="l00398"></a>00398   <span class="comment">// vehicle routing problem.</span>
<a name="l00399"></a>00399   <span class="keywordtype">void</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#421504809966a6abc4cd725c48780060" title="Adds a local search operator to the set of operators used to solve the vehicle routing...">AddLocalSearchOperator</a>(<a class="code" href="classoperations__research_1_1LocalSearchOperator.html" title="&amp;lt; !defined(SWIG)">LocalSearchOperator</a>* ls_operator);
<a name="l00400"></a>00400   <span class="comment">// Returns the metaheuristic used.</span>
<a name="l00401"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#ac8ac681a6a334db9b808208d616235a">00401</a>   <a class="code" href="classoperations__research_1_1RoutingModel.html#0f0bd97e25af059ab2e8e7f263afc8e1" title="Metaheuristics used to guide the search.">RoutingMetaheuristic</a> <a class="code" href="classoperations__research_1_1RoutingModel.html#ac8ac681a6a334db9b808208d616235a" title="Returns the metaheuristic used.">metaheuristic</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> metaheuristic_; }
<a name="l00402"></a>00402   <span class="comment">// Sets the metaheuristic to be used.</span>
<a name="l00403"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#d38e1582f53db33bca76ff9c2a4ab0c1">00403</a>   <span class="keywordtype">void</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#d38e1582f53db33bca76ff9c2a4ab0c1" title="Sets the metaheuristic to be used.">set_metaheuristic</a>(<a class="code" href="classoperations__research_1_1RoutingModel.html#0f0bd97e25af059ab2e8e7f263afc8e1" title="Metaheuristics used to guide the search.">RoutingMetaheuristic</a> <a class="code" href="classoperations__research_1_1RoutingModel.html#ac8ac681a6a334db9b808208d616235a" title="Returns the metaheuristic used.">metaheuristic</a>) {
<a name="l00404"></a>00404     metaheuristic_ = metaheuristic;
<a name="l00405"></a>00405   }
<a name="l00406"></a>00406   <span class="comment">// If a metaheuristic flag has been set, returns the corresponding</span>
<a name="l00407"></a>00407   <span class="comment">// metaheuristic, otherwise returns the metaheuristic which was set.</span>
<a name="l00408"></a>00408   <a class="code" href="classoperations__research_1_1RoutingModel.html#0f0bd97e25af059ab2e8e7f263afc8e1" title="Metaheuristics used to guide the search.">RoutingMetaheuristic</a> <a class="code" href="classoperations__research_1_1RoutingModel.html#22f429a899b1c00cad6e6ff04a117ee4" title="If a metaheuristic flag has been set, returns the corresponding metaheuristic, otherwise...">GetSelectedMetaheuristic</a>() <span class="keyword">const</span>;
<a name="l00409"></a>00409   <span class="comment">// Adds a search monitor to the search used to solve the routing model.</span>
<a name="l00410"></a>00410   <span class="keywordtype">void</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#4928a8a9f21302a215a6f26dda90eef1" title="Adds a search monitor to the search used to solve the routing model.">AddSearchMonitor</a>(<a class="code" href="classoperations__research_1_1SearchMonitor.html" title="A search monitor is a simple set of callbacks to monitor all search events.">SearchMonitor</a>* <span class="keyword">const</span> monitor);
<a name="l00411"></a>00411   <span class="comment">// Closes the current routing model; after this method is called, no</span>
<a name="l00412"></a>00412   <span class="comment">// modification to the model can be done, but RoutesToAssignment becomes</span>
<a name="l00413"></a>00413   <span class="comment">// available. Note that CloseModel() is automatically called by Solve() and</span>
<a name="l00414"></a>00414   <span class="comment">// other methods that produce solution.</span>
<a name="l00415"></a>00415   <span class="keywordtype">void</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#e84602b98050ad382d725e35326aab3d" title="Closes the current routing model; after this method is called, no modification to...">CloseModel</a>();
<a name="l00416"></a>00416   <span class="comment">// Solves the current routing model; closes the current model.</span>
<a name="l00417"></a>00417   <span class="keyword">const</span> <a class="code" href="classoperations__research_1_1Assignment.html" title="Assignment.">Assignment</a>* <a class="code" href="classoperations__research_1_1RoutingModel.html#79e79d503b81e378485b402293a5828c" title="Solves the current routing model; closes the current model.">Solve</a>(<span class="keyword">const</span> <a class="code" href="classoperations__research_1_1Assignment.html" title="Assignment.">Assignment</a>* assignment = NULL);
<a name="l00418"></a>00418   <span class="comment">// Computes a lower bound to the routing problem solving a linear assignment</span>
<a name="l00419"></a>00419   <span class="comment">// problem. The routing model must be closed before calling this method.</span>
<a name="l00420"></a>00420   <span class="comment">// Note that problems with node disjunction constraints (including optional</span>
<a name="l00421"></a>00421   <span class="comment">// nodes) and non-homogenous costs are not supported (the method returns 0 in</span>
<a name="l00422"></a>00422   <span class="comment">// these cases).</span>
<a name="l00423"></a>00423   <span class="comment">// TODO(user): Add support for non-homogeneous costs and disjunctions.</span>
<a name="l00424"></a>00424   int64 <a class="code" href="classoperations__research_1_1RoutingModel.html#b94b51a3ffa939b647cc2fc0eeff8400" title="Computes a lower bound to the routing problem solving a linear assignment problem...">ComputeLowerBound</a>();
<a name="l00425"></a>00425   <span class="comment">// Returns the current status of the routing model.</span>
<a name="l00426"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#cc9cbc5c610da66a71220657d366c471">00426</a>   <a class="code" href="classoperations__research_1_1RoutingModel.html#328a19213729eec49288128061bc2044" title="Status of the search.">Status</a> <a class="code" href="classoperations__research_1_1RoutingModel.html#cc9cbc5c610da66a71220657d366c471" title="Returns the current status of the routing model.">status</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> status_; }
<a name="l00427"></a>00427   <span class="comment">// Applies a lock chain to the next search. 'locks' represents an ordered</span>
<a name="l00428"></a>00428   <span class="comment">// vector of nodes representing a partial route which will be fixed during the</span>
<a name="l00429"></a>00429   <span class="comment">// next search; it will constrain next variables such that:</span>
<a name="l00430"></a>00430   <span class="comment">// next[locks[i]] == locks[i+1].</span>
<a name="l00431"></a>00431   <span class="comment">// Returns the next variable at the end of the locked chain; this variable is</span>
<a name="l00432"></a>00432   <span class="comment">// not locked. An assignment containing the locks can be obtained by calling</span>
<a name="l00433"></a>00433   <span class="comment">// PreAssignment().</span>
<a name="l00434"></a>00434   <a class="code" href="classoperations__research_1_1IntVar.html" title="The class IntVar is a subset of IntExpr.">IntVar</a>* <a class="code" href="classoperations__research_1_1RoutingModel.html#4db46f77834dbcbbf4e54ec6b0e76047" title="Applies a lock chain to the next search.">ApplyLocks</a>(<span class="keyword">const</span> std::vector&lt;int&gt;&amp; locks);
<a name="l00435"></a>00435   <span class="comment">// Applies lock chains to all vehicles to the next search, such that locks[p]</span>
<a name="l00436"></a>00436   <span class="comment">// is the lock chain for route p. Returns false if the locks do not contain</span>
<a name="l00437"></a>00437   <span class="comment">// valid routes; expects that the routes do not contain the depots,</span>
<a name="l00438"></a>00438   <span class="comment">// i.e. there are empty vectors in place of empty routes.</span>
<a name="l00439"></a>00439   <span class="comment">// If close_routes is set to true, adds the end nodes to the route of each</span>
<a name="l00440"></a>00440   <span class="comment">// vehicle and deactivates other nodes.</span>
<a name="l00441"></a>00441   <span class="comment">// An assignment containing the locks can be obtained by calling</span>
<a name="l00442"></a>00442   <span class="comment">// PreAssignment().</span>
<a name="l00443"></a>00443   <span class="keywordtype">bool</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#1bde9342e06eb1d4d12986a8d3be5d30" title="Applies lock chains to all vehicles to the next search, such that locks[p] is the...">ApplyLocksToAllVehicles</a>(<span class="keyword">const</span> std::vector&lt;std::vector&lt;NodeIndex&gt; &gt;&amp; locks,
<a name="l00444"></a>00444                                <span class="keywordtype">bool</span> close_routes);
<a name="l00445"></a>00445   <span class="comment">// Returns an assignment used to fix some of the variables of the problem.</span>
<a name="l00446"></a>00446   <span class="comment">// In practice, this assignment locks partial routes of the problem. This</span>
<a name="l00447"></a>00447   <span class="comment">// can be used in the context of locking the parts of the routes which have</span>
<a name="l00448"></a>00448   <span class="comment">// already been driven in online routing problems.</span>
<a name="l00449"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#db8c703e9d29b2046db433b8c74e338c">00449</a>   <span class="keyword">const</span> <a class="code" href="classoperations__research_1_1Assignment.html" title="Assignment.">Assignment</a>* <span class="keyword">const</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#db8c703e9d29b2046db433b8c74e338c" title="Returns an assignment used to fix some of the variables of the problem.">PreAssignment</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> preassignment_; }
<a name="l00450"></a>00450   <span class="comment">// Writes the current solution to a file containing an AssignmentProto.</span>
<a name="l00451"></a>00451   <span class="comment">// Returns false if the file cannot be opened or if there is no current</span>
<a name="l00452"></a>00452   <span class="comment">// solution.</span>
<a name="l00453"></a>00453   <span class="keywordtype">bool</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#07804a0abc492e87498bb10f0aea0843" title="Writes the current solution to a file containing an AssignmentProto.">WriteAssignment</a>(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; file_name) <span class="keyword">const</span>;
<a name="l00454"></a>00454   <span class="comment">// Reads an assignment from a file and returns the current solution.</span>
<a name="l00455"></a>00455   <span class="comment">// Returns NULL if the file cannot be opened or if the assignment is not</span>
<a name="l00456"></a>00456   <span class="comment">// valid.</span>
<a name="l00457"></a>00457   <a class="code" href="classoperations__research_1_1Assignment.html" title="Assignment.">Assignment</a>* <a class="code" href="classoperations__research_1_1RoutingModel.html#d1201189a16e0c6dd658c2331f023d3c" title="Reads an assignment from a file and returns the current solution.">ReadAssignment</a>(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; file_name);
<a name="l00458"></a>00458   <span class="comment">// Restores an assignment as a solution in the routing model and returns the</span>
<a name="l00459"></a>00459   <span class="comment">// new solution. Returns NULL if the assignment is not valid.</span>
<a name="l00460"></a>00460   <a class="code" href="classoperations__research_1_1Assignment.html" title="Assignment.">Assignment</a>* <a class="code" href="classoperations__research_1_1RoutingModel.html#6bcbb26b40d556ec60449c93f81bc5d5" title="Restores an assignment as a solution in the routing model and returns the new solution...">RestoreAssignment</a>(<span class="keyword">const</span> <a class="code" href="classoperations__research_1_1Assignment.html" title="Assignment.">Assignment</a>&amp; solution);
<a name="l00461"></a>00461   <span class="comment">// Restores the routes as the current solution. Returns NULL if the solution</span>
<a name="l00462"></a>00462   <span class="comment">// cannot be restored (routes do not contain a valid solution).</span>
<a name="l00463"></a>00463   <span class="comment">// Note that calling this method will run the solver to assign values to the</span>
<a name="l00464"></a>00464   <span class="comment">// dimension variables; this may take considerable amount of time, especially</span>
<a name="l00465"></a>00465   <span class="comment">// when using dimensions with slack.</span>
<a name="l00466"></a>00466   <a class="code" href="classoperations__research_1_1Assignment.html" title="Assignment.">Assignment</a>* <a class="code" href="classoperations__research_1_1RoutingModel.html#6a9ea98665bf82cb8d542453ccf2ee9b" title="Restores the routes as the current solution.">ReadAssignmentFromRoutes</a>(<span class="keyword">const</span> std::vector&lt;std::vector&lt;NodeIndex&gt; &gt;&amp; routes,
<a name="l00467"></a>00467                                        <span class="keywordtype">bool</span> ignore_inactive_nodes);
<a name="l00468"></a>00468   <span class="comment">// Fills an assignment from a specification of the routes of the vehicles. The</span>
<a name="l00469"></a>00469   <span class="comment">// routes are specified as lists of nodes that appear on the routes of the</span>
<a name="l00470"></a>00470   <span class="comment">// vehicles. The indices of the outer vector in 'routes' correspond to</span>
<a name="l00471"></a>00471   <span class="comment">// vehicles IDs, the inner vector contain the nodes on the routes for the</span>
<a name="l00472"></a>00472   <span class="comment">// given vehicle. The inner vectors must not contain the start and end nodes,</span>
<a name="l00473"></a>00473   <span class="comment">// as these are determined by the routing model.</span>
<a name="l00474"></a>00474   <span class="comment">// Sets the value of NextVars in the assignment, adding the variables to the</span>
<a name="l00475"></a>00475   <span class="comment">// assignment if necessary. The method does not touch other variables in the</span>
<a name="l00476"></a>00476   <span class="comment">// assignment. The method can only be called after the model is closed.</span>
<a name="l00477"></a>00477   <span class="comment">// With ignore_inactive_nodes set to false, this method will fail (return</span>
<a name="l00478"></a>00478   <span class="comment">// NULL) in case some of the route contain nodes that are deactivated in the</span>
<a name="l00479"></a>00479   <span class="comment">// model; when set to true, these nodes will be skipped.</span>
<a name="l00480"></a>00480   <span class="comment">// Returns true if the route was successfully loaded. However, such assignment</span>
<a name="l00481"></a>00481   <span class="comment">// still might not be a valid solution to the routing problem due to more</span>
<a name="l00482"></a>00482   <span class="comment">// complex constraints; it is advisible to call solver()-&gt;CheckSolution()</span>
<a name="l00483"></a>00483   <span class="comment">// afterwards.</span>
<a name="l00484"></a>00484   <span class="keywordtype">bool</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#c7560ce4597182518954a502dea3c91d" title="Fills an assignment from a specification of the routes of the vehicles.">RoutesToAssignment</a>(<span class="keyword">const</span> std::vector&lt;std::vector&lt;NodeIndex&gt; &gt;&amp; routes,
<a name="l00485"></a>00485                           <span class="keywordtype">bool</span> ignore_inactive_nodes,
<a name="l00486"></a>00486                           <span class="keywordtype">bool</span> close_routes,
<a name="l00487"></a>00487                           <a class="code" href="classoperations__research_1_1Assignment.html" title="Assignment.">Assignment</a>* <span class="keyword">const</span> assignment) <span class="keyword">const</span>;
<a name="l00488"></a>00488   <span class="comment">// Converts the solution in the given assignment to routes for all vehicles.</span>
<a name="l00489"></a>00489   <span class="comment">// Expects that assignment contains a valid solution (i.e. routes for all</span>
<a name="l00490"></a>00490   <span class="comment">// vehicles end with an end node for that vehicle).</span>
<a name="l00491"></a>00491   <span class="keywordtype">void</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#67a2a68974ee09e85bba490c78bf4c0a" title="Converts the solution in the given assignment to routes for all vehicles.">AssignmentToRoutes</a>(<span class="keyword">const</span> <a class="code" href="classoperations__research_1_1Assignment.html" title="Assignment.">Assignment</a>&amp; assignment,
<a name="l00492"></a>00492                           std::vector&lt;std::vector&lt;NodeIndex&gt; &gt;* <span class="keyword">const</span> routes) <span class="keyword">const</span>;
<a name="l00493"></a>00493   <span class="comment">// Returns a compacted version of the given assignment, in which all vehicles</span>
<a name="l00494"></a>00494   <span class="comment">// with id lower or equal to some N have non-empty routes, and all vehicles</span>
<a name="l00495"></a>00495   <span class="comment">// with id greater than N have empty routes. Does not take ownership of the</span>
<a name="l00496"></a>00496   <span class="comment">// returned object.</span>
<a name="l00497"></a>00497   <span class="comment">// If found, the cost of the compact assignment is the same as in the</span>
<a name="l00498"></a>00498   <span class="comment">// original assignment and it preserves the values of 'active' variables.</span>
<a name="l00499"></a>00499   <span class="comment">// Returns NULL if a compact assignment was not found.</span>
<a name="l00500"></a>00500   <span class="comment">// This method only works in homogenous mode, and it only swaps equivalent</span>
<a name="l00501"></a>00501   <span class="comment">// vehicles (vehicles with the same start and end nodes). When creating the</span>
<a name="l00502"></a>00502   <span class="comment">// compact assignment, the empty plan is replaced by the route assigned to the</span>
<a name="l00503"></a>00503   <span class="comment">// compatible vehicle with the highest id. Note that with more complex</span>
<a name="l00504"></a>00504   <span class="comment">// constraints on vehicle variables, this method might fail even if a compact</span>
<a name="l00505"></a>00505   <span class="comment">// solution exists.</span>
<a name="l00506"></a>00506   <span class="comment">// This method changes the vehicle and dimension variables as necessary.</span>
<a name="l00507"></a>00507   <span class="comment">// While compacting the solution, only basic checks on vehicle variables are</span>
<a name="l00508"></a>00508   <span class="comment">// performed; the complete solution is checked at the end and if it is not</span>
<a name="l00509"></a>00509   <span class="comment">// valid, no attempts to repair it are made (instead, the method returns</span>
<a name="l00510"></a>00510   <span class="comment">// NULL).</span>
<a name="l00511"></a>00511   <a class="code" href="classoperations__research_1_1Assignment.html" title="Assignment.">Assignment</a>* <a class="code" href="classoperations__research_1_1RoutingModel.html#6d67433ee6cb41435ecec227ba2d9139" title="Returns a compacted version of the given assignment, in which all vehicles with id...">CompactAssignment</a>(<span class="keyword">const</span> <a class="code" href="classoperations__research_1_1Assignment.html" title="Assignment.">Assignment</a>&amp; assignment) <span class="keyword">const</span>;
<a name="l00512"></a>00512   <span class="comment">// Adds an extra variable to the vehicle routing assignment.</span>
<a name="l00513"></a>00513   <span class="keywordtype">void</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#1a11f61fc549eed60a0ee9fe937fbac6" title="Adds an extra variable to the vehicle routing assignment.">AddToAssignment</a>(<a class="code" href="classoperations__research_1_1IntVar.html" title="The class IntVar is a subset of IntExpr.">IntVar</a>* <span class="keyword">const</span> <a class="code" href="expr__array_8cc.html#472a99923cbe11ae7b5a5d157d9ad465">var</a>);
<a name="l00514"></a>00514 
<a name="l00515"></a>00515 
<a name="l00516"></a>00516   <span class="comment">// Model inspection.</span>
<a name="l00517"></a>00517   <span class="comment">// Returns the variable index of the starting node of a vehicle route.</span>
<a name="l00518"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#fcb255b430c9c51561a344966f32940d">00518</a>   <span class="keywordtype">int</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#fcb255b430c9c51561a344966f32940d" title="Model inspection.">Start</a>(<span class="keywordtype">int</span> vehicle)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> starts_[vehicle]; }
<a name="l00519"></a>00519   <span class="comment">// Returns the variable index of the ending node of a vehicle route.</span>
<a name="l00520"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#9d2055447d769bd064f61c150d099b53">00520</a>   <span class="keywordtype">int</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#9d2055447d769bd064f61c150d099b53" title="Returns the variable index of the ending node of a vehicle route.">End</a>(<span class="keywordtype">int</span> vehicle)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> ends_[vehicle]; }
<a name="l00521"></a>00521   <span class="comment">// Returns true if 'index' represents the first node of a route.</span>
<a name="l00522"></a>00522   <span class="keywordtype">bool</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#7f1ed907da5e1918e60d7a206e7dc0d7" title="Returns true if &amp;#39;index&amp;#39; represents the first node of a route.">IsStart</a>(int64 <a class="code" href="pack_8cc.html#750b5d744c39a06bfb13e6eb010e35d0">index</a>) <span class="keyword">const</span>;
<a name="l00523"></a>00523   <span class="comment">// Returns true if 'index' represents the last node of a route.</span>
<a name="l00524"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#d542c0716ca8948f8e6240b2ff24d878">00524</a>   <span class="keywordtype">bool</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#d542c0716ca8948f8e6240b2ff24d878" title="Returns true if &amp;#39;index&amp;#39; represents the last node of a route.">IsEnd</a>(int64 <a class="code" href="pack_8cc.html#750b5d744c39a06bfb13e6eb010e35d0">index</a>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> index &gt;= <a class="code" href="classoperations__research_1_1RoutingModel.html#5a560929b26804990f1e7d6972218f87" title="Returns the number of next variables in the model.">Size</a>(); }
<a name="l00525"></a>00525   int64 <a class="code" href="classoperations__research_1_1RoutingModel.html#1d7c2d652d782ca3930583b98ee3f15d" title="Return high cost if connecting to end node; used in cost-based first solution.">GetFirstSolutionCost</a>(int64 i, int64 j);
<a name="l00526"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#5a4f31c561411ae89bf266e41ceb509c">00526</a>   <span class="keywordtype">bool</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#5a4f31c561411ae89bf266e41ceb509c">homogeneous_costs</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> homogeneous_costs_; }
<a name="l00527"></a>00527   <span class="comment">// Assignment inspection</span>
<a name="l00528"></a>00528   <span class="comment">// Returns the variable index of the node directly after the node</span>
<a name="l00529"></a>00529   <span class="comment">// corresponding to 'index' in 'assignment'.</span>
<a name="l00530"></a>00530   <span class="keywordtype">int</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#831900fa1fa062dca5ba3d220b7f3387" title="Assignment inspection Returns the variable index of the node directly after the node...">Next</a>(<span class="keyword">const</span> <a class="code" href="classoperations__research_1_1Assignment.html" title="Assignment.">Assignment</a>&amp; assignment, <span class="keywordtype">int</span> <a class="code" href="pack_8cc.html#750b5d744c39a06bfb13e6eb010e35d0">index</a>) <span class="keyword">const</span>;
<a name="l00531"></a>00531   <span class="comment">// Returns true if the route of 'vehicle' is non empty in 'assignment'.</span>
<a name="l00532"></a>00532   <span class="keywordtype">bool</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#47b43075c4e09efcdc59b3368b0242fb" title="Returns true if the route of &amp;#39;vehicle&amp;#39; is non empty in &amp;#39;assignment&amp;#39;...">IsVehicleUsed</a>(<span class="keyword">const</span> <a class="code" href="classoperations__research_1_1Assignment.html" title="Assignment.">Assignment</a>&amp; assignment, <span class="keywordtype">int</span> vehicle) <span class="keyword">const</span>;
<a name="l00533"></a>00533   <span class="comment">// Variables</span>
<a name="l00534"></a>00534   <span class="comment">// Returns all next variables of the model, such that Nexts(i) is the next</span>
<a name="l00535"></a>00535   <span class="comment">// variable of the node corresponding to i.</span>
<a name="l00536"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#100397cb143b48549277c70f4afb32e2">00536</a>   <a class="code" href="classoperations__research_1_1IntVar.html" title="The class IntVar is a subset of IntExpr.">IntVar</a>** <a class="code" href="classoperations__research_1_1RoutingModel.html#100397cb143b48549277c70f4afb32e2" title="Variables Returns all next variables of the model, such that Nexts(i) is the next...">Nexts</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> nexts_.get(); }
<a name="l00537"></a>00537   <span class="comment">// Returns all vehicle variables of the model,  such that VehicleVars(i) is</span>
<a name="l00538"></a>00538   <span class="comment">// the vehicle variable of the node corresponding to i.</span>
<a name="l00539"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#6bf6aeb259ab509d97a5e6c3e5189f61">00539</a>   <a class="code" href="classoperations__research_1_1IntVar.html" title="The class IntVar is a subset of IntExpr.">IntVar</a>** <a class="code" href="classoperations__research_1_1RoutingModel.html#6bf6aeb259ab509d97a5e6c3e5189f61" title="Returns all vehicle variables of the model, such that VehicleVars(i) is the vehicle...">VehicleVars</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> vehicle_vars_.get(); }
<a name="l00540"></a>00540   <span class="comment">// Returns the next variable of the node corresponding to index.</span>
<a name="l00541"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#131f2181343be56fd836b64747fe9f49">00541</a>   <a class="code" href="classoperations__research_1_1IntVar.html" title="The class IntVar is a subset of IntExpr.">IntVar</a>* <a class="code" href="classoperations__research_1_1RoutingModel.html#131f2181343be56fd836b64747fe9f49" title="Returns the next variable of the node corresponding to index.">NextVar</a>(int64 <a class="code" href="pack_8cc.html#750b5d744c39a06bfb13e6eb010e35d0">index</a>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> nexts_[index]; }
<a name="l00542"></a>00542   <span class="comment">// Returns the active variable of the node corresponding to index.</span>
<a name="l00543"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#5254602b653dda44c6f6a6611e8cd6f2">00543</a>   <a class="code" href="classoperations__research_1_1IntVar.html" title="The class IntVar is a subset of IntExpr.">IntVar</a>* <a class="code" href="classoperations__research_1_1RoutingModel.html#5254602b653dda44c6f6a6611e8cd6f2" title="Returns the active variable of the node corresponding to index.">ActiveVar</a>(int64 <a class="code" href="pack_8cc.html#750b5d744c39a06bfb13e6eb010e35d0">index</a>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> active_[index]; }
<a name="l00544"></a>00544   <span class="comment">// Returns the vehicle variable of the node corresponding to index.</span>
<a name="l00545"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#618a961dcb65e02d6d310a83d1f60722">00545</a>   <a class="code" href="classoperations__research_1_1IntVar.html" title="The class IntVar is a subset of IntExpr.">IntVar</a>* <a class="code" href="classoperations__research_1_1RoutingModel.html#618a961dcb65e02d6d310a83d1f60722" title="Returns the vehicle variable of the node corresponding to index.">VehicleVar</a>(int64 <a class="code" href="pack_8cc.html#750b5d744c39a06bfb13e6eb010e35d0">index</a>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> vehicle_vars_[index]; }
<a name="l00546"></a>00546   <span class="comment">// Returns the cumul variable for the dimension named 'name'.</span>
<a name="l00547"></a>00547   <a class="code" href="classoperations__research_1_1IntVar.html" title="The class IntVar is a subset of IntExpr.">IntVar</a>* <a class="code" href="classoperations__research_1_1RoutingModel.html#a1e366cd50bfdfac06e032d9eb22612f" title="Returns the cumul variable for the dimension named &amp;#39;name&amp;#39;.">CumulVar</a>(int64 <a class="code" href="pack_8cc.html#750b5d744c39a06bfb13e6eb010e35d0">index</a>, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; <a class="code" href="default__search_8cc.html#1848ae81740c68c2502b2f176cfadcef" title="A name for logging purposes.">name</a>) <span class="keyword">const</span>;
<a name="l00548"></a>00548   <span class="comment">// Returns the transit variable for the dimension named 'name'.</span>
<a name="l00549"></a>00549   <a class="code" href="classoperations__research_1_1IntVar.html" title="The class IntVar is a subset of IntExpr.">IntVar</a>* <a class="code" href="classoperations__research_1_1RoutingModel.html#8d0a9a90e331b113628418013cfa813e" title="Returns the transit variable for the dimension named &amp;#39;name&amp;#39;.">TransitVar</a>(int64 <a class="code" href="pack_8cc.html#750b5d744c39a06bfb13e6eb010e35d0">index</a>, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; <a class="code" href="default__search_8cc.html#1848ae81740c68c2502b2f176cfadcef" title="A name for logging purposes.">name</a>) <span class="keyword">const</span>;
<a name="l00550"></a>00550   <span class="comment">// Returns the global cost variable which is being minimized.</span>
<a name="l00551"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#c76b2c7544a4fc56d06945cbde4480a6">00551</a>   <a class="code" href="classoperations__research_1_1IntVar.html" title="The class IntVar is a subset of IntExpr.">IntVar</a>* <a class="code" href="classoperations__research_1_1RoutingModel.html#c76b2c7544a4fc56d06945cbde4480a6" title="Returns the global cost variable which is being minimized.">CostVar</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> cost_; }
<a name="l00552"></a>00552   <span class="comment">// Returns the cost of the segment between two nodes for a given vehicle</span>
<a name="l00553"></a>00553   <span class="comment">// route. Input are variable indices of node.</span>
<a name="l00554"></a>00554   int64 <a class="code" href="classoperations__research_1_1RoutingModel.html#2fc423d06fca461e5220ee4c42672f37" title="Returns the cost of the segment between two nodes for a given vehicle route.">GetCost</a>(int64 from_index, int64 to_index, int64 vehicle);
<a name="l00555"></a>00555   <span class="comment">// Returns the cost of the segment between two nodes supposing all vehicle</span>
<a name="l00556"></a>00556   <span class="comment">// costs are the same (returns the cost for the first vehicle otherwise).</span>
<a name="l00557"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#6f274d2ace4d354140b9c086ef4dceee">00557</a>   int64 <a class="code" href="classoperations__research_1_1RoutingModel.html#6f274d2ace4d354140b9c086ef4dceee" title="Returns the cost of the segment between two nodes supposing all vehicle costs are...">GetHomogeneousCost</a>(int64 i, int64 j) {
<a name="l00558"></a>00558     <span class="keywordflow">return</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#2fc423d06fca461e5220ee4c42672f37" title="Returns the cost of the segment between two nodes for a given vehicle route.">GetCost</a>(i, j, 0);
<a name="l00559"></a>00559   }
<a name="l00560"></a>00560 
<a name="l00561"></a>00561   <span class="comment">// Returns the underlying constraint solver. Can be used to add extra</span>
<a name="l00562"></a>00562   <span class="comment">// constraints and/or modify search algoithms.</span>
<a name="l00563"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#35a094db917c3c996826285424bb2f54">00563</a>   <a class="code" href="classoperations__research_1_1Solver.html" title="Solver Class.">Solver</a>* <a class="code" href="classoperations__research_1_1RoutingModel.html#35a094db917c3c996826285424bb2f54" title="Returns the underlying constraint solver.">solver</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> solver_.get(); }
<a name="l00564"></a>00564 
<a name="l00565"></a>00565   <span class="comment">// Sizes and indices</span>
<a name="l00566"></a>00566   <span class="comment">// Returns the number of nodes in the model.</span>
<a name="l00567"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#20c1bf5b1ac1353c9e132774f3f7e1df">00567</a>   <span class="keywordtype">int</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#20c1bf5b1ac1353c9e132774f3f7e1df" title="Sizes and indices Returns the number of nodes in the model.">nodes</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> nodes_; }
<a name="l00568"></a>00568   <span class="comment">// Returns the number of vehicle routes in the model.</span>
<a name="l00569"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#9236103b3dca8a4112bd2a8be05b0b71">00569</a>   <span class="keywordtype">int</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#9236103b3dca8a4112bd2a8be05b0b71" title="Returns the number of vehicle routes in the model.">vehicles</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> vehicles_; }
<a name="l00570"></a>00570   <span class="comment">// Returns the number of next variables in the model.</span>
<a name="l00571"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#5a560929b26804990f1e7d6972218f87">00571</a>   <span class="keywordtype">int</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#5a560929b26804990f1e7d6972218f87" title="Returns the number of next variables in the model.">Size</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> nodes_ + vehicles_ - start_end_count_; }
<a name="l00572"></a>00572   <span class="comment">// Returns the node index from an index value resulting fron a next variable.</span>
<a name="l00573"></a>00573   <a class="code" href="classoperations__research_1_1RoutingModel.html#2e9f7da1126111a69ee0b7bcf7edeffe">NodeIndex</a> <a class="code" href="classoperations__research_1_1RoutingModel.html#ca1b6ad06bed2a28e3debeed4512db0d" title="Returns the node index from an index value resulting fron a next variable.">IndexToNode</a>(int64 <a class="code" href="pack_8cc.html#750b5d744c39a06bfb13e6eb010e35d0">index</a>) <span class="keyword">const</span>;
<a name="l00574"></a>00574   <span class="comment">// Returns the variable index from a node value.</span>
<a name="l00575"></a>00575   <span class="comment">// Should not be used for nodes at the start / end of a route,</span>
<a name="l00576"></a>00576   <span class="comment">// because of node multiplicity.  These cases return -1, which is</span>
<a name="l00577"></a>00577   <span class="comment">// considered a failure case.  Clients who need start and end</span>
<a name="l00578"></a>00578   <span class="comment">// variable indices should use RoutingModel::Start and RoutingModel::End.</span>
<a name="l00579"></a>00579   int64 <a class="code" href="classoperations__research_1_1RoutingModel.html#6c88d9d5da962886bfe0924bc5ea6457" title="Returns the variable index from a node value.">NodeToIndex</a>(<a class="code" href="classoperations__research_1_1RoutingModel.html#2e9f7da1126111a69ee0b7bcf7edeffe">NodeIndex</a> <a class="code" href="dependency__graph_8cc.html#4eefd1c2b90c940bb972d6d038744cc3">node</a>) <span class="keyword">const</span>;
<a name="l00580"></a>00580   <span class="comment">// Returns the variable indices of the nodes in the same disjunction as the</span>
<a name="l00581"></a>00581   <span class="comment">// node corresponding to the variable of index 'index'.</span>
<a name="l00582"></a>00582   <span class="keywordtype">void</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#23961d60010f2c38f156f2e705c6e781" title="Returns the variable indices of the nodes in the same disjunction as the node corresponding...">GetDisjunctionIndicesFromIndex</a>(int64 <a class="code" href="pack_8cc.html#750b5d744c39a06bfb13e6eb010e35d0">index</a>, std::vector&lt;int&gt;* indices) <span class="keyword">const</span>;
<a name="l00583"></a>00583 
<a name="l00584"></a>00584   <span class="comment">// Time limits</span>
<a name="l00585"></a>00585   <span class="comment">// Returns the current time limit used in the search.</span>
<a name="l00586"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#814299b5554ee840394457c61fec466f">00586</a>   int64 <a class="code" href="classoperations__research_1_1RoutingModel.html#814299b5554ee840394457c61fec466f" title="Time limits Returns the current time limit used in the search.">TimeLimit</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> time_limit_ms_; }
<a name="l00587"></a>00587   <span class="comment">// Updates the time limit used in the search.</span>
<a name="l00588"></a>00588   <span class="keywordtype">void</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#daff11f77b3ff5eec418ca0fe74d5890" title="Updates the time limit used in the search.">UpdateTimeLimit</a>(int64 limit_ms);
<a name="l00589"></a>00589   <span class="comment">// Updates the time limit used in the Large Neighborhood search tree.</span>
<a name="l00590"></a>00590   <span class="keywordtype">void</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#e5d2063233d64b4c746080d0e3bb429c" title="Updates the time limit used in the Large Neighborhood search tree.">UpdateLNSTimeLimit</a>(int64 limit_ms);
<a name="l00591"></a>00591 
<a name="l00592"></a>00592   <span class="comment">// Utilities for swig to set flags in python or java.</span>
<a name="l00593"></a>00593   <span class="keywordtype">void</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#6d58b03c066bfedc30d6555244bee0f8" title="Utilities for swig to set flags in python or java.">SetCommandLineOption</a>(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; <a class="code" href="default__search_8cc.html#1848ae81740c68c2502b2f176cfadcef" title="A name for logging purposes.">name</a>, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; <a class="code" href="search_8cc.html#21edc7ca4cc5802c8779d68556bc09cf">value</a>);
<a name="l00594"></a>00594 
<a name="l00595"></a>00595  <span class="keyword">private</span>:
<a name="l00596"></a>00596   <span class="keyword">typedef</span> hash_map&lt;string, IntVar**&gt; VarMap;
<a name="l00597"></a>00597   <span class="keyword">struct </span>Disjunction {
<a name="l00598"></a>00598     std::vector&lt;int&gt; <a class="code" href="classoperations__research_1_1RoutingModel.html#20c1bf5b1ac1353c9e132774f3f7e1df" title="Sizes and indices Returns the number of nodes in the model.">nodes</a>;
<a name="l00599"></a>00599     int64 penalty;
<a name="l00600"></a>00600   };
<a name="l00601"></a>00601 
<a name="l00602"></a>00602   <span class="keyword">struct </span>CostCacheElement {
<a name="l00603"></a>00603     <a class="code" href="classoperations__research_1_1RoutingModel.html#2e9f7da1126111a69ee0b7bcf7edeffe">NodeIndex</a> <a class="code" href="dependency__graph_8cc.html#4eefd1c2b90c940bb972d6d038744cc3">node</a>;
<a name="l00604"></a>00604     <span class="keywordtype">int</span> vehicle;
<a name="l00605"></a>00605     int64 cost;
<a name="l00606"></a>00606   };
<a name="l00607"></a>00607 
<a name="l00608"></a>00608   <span class="comment">// Internal methods.</span>
<a name="l00609"></a>00609   <span class="keywordtype">void</span> Initialize();
<a name="l00610"></a>00610   <span class="keywordtype">void</span> SetStartEnd(<span class="keyword">const</span> std::vector&lt;std::pair&lt;NodeIndex, NodeIndex&gt; &gt;&amp; start_end);
<a name="l00611"></a>00611   <span class="keywordtype">void</span> AddDisjunctionInternal(<span class="keyword">const</span> std::vector&lt;NodeIndex&gt;&amp; <a class="code" href="classoperations__research_1_1RoutingModel.html#20c1bf5b1ac1353c9e132774f3f7e1df" title="Sizes and indices Returns the number of nodes in the model.">nodes</a>, int64 penalty);
<a name="l00612"></a>00612   <span class="keywordtype">void</span> AddNoCycleConstraintInternal();
<a name="l00613"></a>00613   <span class="keywordtype">void</span> SetVehicleCostInternal(<span class="keywordtype">int</span> vehicle, <a class="code" href="classoperations__research_1_1RoutingModel.html#5ad22b1565f2e5b1735601a824629289">NodeEvaluator2</a>* evaluator);
<a name="l00614"></a>00614   Assignment* DoRestoreAssignment();
<a name="l00615"></a>00615   <span class="comment">// Variants of GetCost and GetHomogeneousCost returning costs used in local</span>
<a name="l00616"></a>00616   <span class="comment">// search filters.</span>
<a name="l00617"></a>00617   int64 GetFilterCost(int64 i, int64 j, int64 vehicle);
<a name="l00618"></a>00618   int64 GetHomogeneousFilterCost(int64 i, int64 j) {
<a name="l00619"></a>00619     <span class="keywordflow">return</span> GetFilterCost(i, j, 0);
<a name="l00620"></a>00620   }
<a name="l00621"></a>00621   <span class="comment">// Returns NULL if no penalty cost, otherwise returns penalty variable.</span>
<a name="l00622"></a>00622   IntVar* CreateDisjunction(<span class="keywordtype">int</span> disjunction);
<a name="l00623"></a>00623   <span class="comment">// Returns the first active node in nodes starting from index + 1.</span>
<a name="l00624"></a>00624   <span class="keywordtype">int</span> FindNextActive(<span class="keywordtype">int</span> <a class="code" href="pack_8cc.html#750b5d744c39a06bfb13e6eb010e35d0">index</a>, <span class="keyword">const</span> std::vector&lt;int&gt;&amp; <a class="code" href="classoperations__research_1_1RoutingModel.html#20c1bf5b1ac1353c9e132774f3f7e1df" title="Sizes and indices Returns the number of nodes in the model.">nodes</a>) <span class="keyword">const</span>;
<a name="l00625"></a>00625 
<a name="l00626"></a>00626   <span class="comment">// Checks that all nodes on the route starting at start_index (using the</span>
<a name="l00627"></a>00627   <span class="comment">// solution stored in assignment) can be visited by the given vehicle.</span>
<a name="l00628"></a>00628   <span class="keywordtype">bool</span> RouteCanBeUsedByVehicle(<span class="keyword">const</span> Assignment&amp; assignment,
<a name="l00629"></a>00629                                <span class="keywordtype">int</span> start_index,
<a name="l00630"></a>00630                                <span class="keywordtype">int</span> vehicle) <span class="keyword">const</span>;
<a name="l00631"></a>00631   <span class="comment">// Replaces the route of unused_vehicle with the route of active_vehicle in</span>
<a name="l00632"></a>00632   <span class="comment">// compact_assignment. Expects that unused_vehicle is a vehicle with an empty</span>
<a name="l00633"></a>00633   <span class="comment">// route and that the route of active_vehicle is non-empty. Also expects that</span>
<a name="l00634"></a>00634   <span class="comment">// 'assignment' contains the original assignment, from which</span>
<a name="l00635"></a>00635   <span class="comment">// compact_assignment was created.</span>
<a name="l00636"></a>00636   <span class="comment">// Returns true if the vehicles were successfully swapped; otherwise, returns</span>
<a name="l00637"></a>00637   <span class="comment">// false.</span>
<a name="l00638"></a>00638   <span class="keywordtype">bool</span> ReplaceUnusedVehicle(<span class="keywordtype">int</span> unused_vehicle,
<a name="l00639"></a>00639                             <span class="keywordtype">int</span> active_vehicle,
<a name="l00640"></a>00640                             Assignment* compact_assignment) <span class="keyword">const</span>;
<a name="l00641"></a>00641 
<a name="l00642"></a>00642   <a class="code" href="classoperations__research_1_1RoutingModel.html#5ad22b1565f2e5b1735601a824629289">NodeEvaluator2</a>* NewCachedCallback(<a class="code" href="classoperations__research_1_1RoutingModel.html#5ad22b1565f2e5b1735601a824629289">NodeEvaluator2</a>* callback);
<a name="l00643"></a>00643   <a class="code" href="classoperations__research_1_1Solver.html#fd80e55c6251fec492c4887f11b5b0e0">Solver::IndexEvaluator3</a>* BuildCostCallback();
<a name="l00644"></a>00644   <span class="keywordtype">void</span> CheckDepot();
<a name="l00645"></a>00645   <span class="keywordtype">void</span> QuietCloseModel() {
<a name="l00646"></a>00646     <span class="keywordflow">if</span> (!closed_) {
<a name="l00647"></a>00647       <a class="code" href="classoperations__research_1_1RoutingModel.html#e84602b98050ad382d725e35326aab3d" title="Closes the current routing model; after this method is called, no modification to...">CloseModel</a>();
<a name="l00648"></a>00648     }
<a name="l00649"></a>00649   }
<a name="l00650"></a>00650   <span class="comment">// Sets up search objects, such as decision builders and monitors.</span>
<a name="l00651"></a>00651   <span class="keywordtype">void</span> SetupSearch();
<a name="l00652"></a>00652   <span class="comment">// Set of auxiliary methods used to setup the search.</span>
<a name="l00653"></a>00653   <span class="comment">// TODO(user): Document each auxiliary method.</span>
<a name="l00654"></a>00654   Assignment* GetOrCreateAssignment();
<a name="l00655"></a>00655   SearchLimit* GetOrCreateLimit();
<a name="l00656"></a>00656   SearchLimit* GetOrCreateLocalSearchLimit();
<a name="l00657"></a>00657   SearchLimit* GetOrCreateLargeNeighborhoodSearchLimit();
<a name="l00658"></a>00658   LocalSearchOperator* CreateInsertionOperator();
<a name="l00659"></a>00659   LocalSearchOperator* CreateNeighborhoodOperators();
<a name="l00660"></a>00660   <span class="keyword">const</span> std::vector&lt;LocalSearchFilter*&gt;&amp; GetOrCreateLocalSearchFilters();
<a name="l00661"></a>00661   DecisionBuilder* CreateSolutionFinalizer();
<a name="l00662"></a>00662   DecisionBuilder* CreateFirstSolutionDecisionBuilder();
<a name="l00663"></a>00663   LocalSearchPhaseParameters* CreateLocalSearchParameters();
<a name="l00664"></a>00664   DecisionBuilder* CreateLocalSearchDecisionBuilder();
<a name="l00665"></a>00665   <span class="keywordtype">void</span> SetupDecisionBuilders();
<a name="l00666"></a>00666   <span class="keywordtype">void</span> SetupMetaheuristics();
<a name="l00667"></a>00667   <span class="keywordtype">void</span> SetupAssignmentCollector();
<a name="l00668"></a>00668   <span class="keywordtype">void</span> SetupTrace();
<a name="l00669"></a>00669   <span class="keywordtype">void</span> SetupSearchMonitors();
<a name="l00670"></a>00670 
<a name="l00671"></a>00671   IntVar** GetOrMakeCumuls(int64 capacity, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; <a class="code" href="default__search_8cc.html#1848ae81740c68c2502b2f176cfadcef" title="A name for logging purposes.">name</a>);
<a name="l00672"></a>00672   IntVar** GetOrMakeTransits(<a class="code" href="classoperations__research_1_1RoutingModel.html#5ad22b1565f2e5b1735601a824629289">NodeEvaluator2</a>* evaluator,
<a name="l00673"></a>00673                              int64 slack_max,
<a name="l00674"></a>00674                              int64 capacity,
<a name="l00675"></a>00675                              <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; <a class="code" href="default__search_8cc.html#1848ae81740c68c2502b2f176cfadcef" title="A name for logging purposes.">name</a>);
<a name="l00676"></a>00676 
<a name="l00677"></a>00677   int64 GetArcCost(int64 i, int64 j, int64 vehicle);
<a name="l00678"></a>00678   int64 GetPenaltyCost(int64 i) <span class="keyword">const</span>;
<a name="l00679"></a>00679   int64 WrappedEvaluator(<a class="code" href="classoperations__research_1_1RoutingModel.html#5ad22b1565f2e5b1735601a824629289">NodeEvaluator2</a>* evaluator,
<a name="l00680"></a>00680                          int64 from,
<a name="l00681"></a>00681                          int64 to);
<a name="l00682"></a>00682 
<a name="l00683"></a>00683   <span class="comment">// Model</span>
<a name="l00684"></a>00684   scoped_ptr&lt;Solver&gt; solver_;
<a name="l00685"></a>00685   Constraint* no_cycle_constraint_;
<a name="l00686"></a>00686   scoped_array&lt;IntVar*&gt; nexts_;
<a name="l00687"></a>00687   scoped_array&lt;IntVar*&gt; vehicle_vars_;
<a name="l00688"></a>00688   scoped_array&lt;IntVar*&gt; active_;
<a name="l00689"></a>00689   std::vector&lt;NodeEvaluator2*&gt; costs_;
<a name="l00690"></a>00690   <span class="keywordtype">bool</span> homogeneous_costs_;
<a name="l00691"></a>00691   std::vector&lt;CostCacheElement&gt; cost_cache_;
<a name="l00692"></a>00692   std::vector&lt;RoutingCache*&gt; routing_caches_;
<a name="l00693"></a>00693   std::vector&lt;Disjunction&gt; disjunctions_;
<a name="l00694"></a>00694   hash_map&lt;int64, int&gt; node_to_disjunction_;
<a name="l00695"></a>00695   <a class="code" href="classoperations__research_1_1RoutingModel.html#4251c2ca5b1558dc69e696991c853ae3">NodePairs</a> pickup_delivery_pairs_;
<a name="l00696"></a>00696   IntVar* cost_;
<a name="l00697"></a>00697   std::vector&lt;int64&gt; fixed_costs_;
<a name="l00698"></a>00698   <span class="keywordtype">int</span> nodes_;
<a name="l00699"></a>00699   <span class="keywordtype">int</span> vehicles_;
<a name="l00700"></a>00700   std::vector&lt;NodeIndex&gt; index_to_node_;
<a name="l00701"></a>00701   ITIVector&lt;NodeIndex, int&gt; node_to_index_;
<a name="l00702"></a>00702   std::vector&lt;int&gt; index_to_vehicle_;
<a name="l00703"></a>00703   std::vector&lt;int&gt; starts_;
<a name="l00704"></a>00704   std::vector&lt;int&gt; ends_;
<a name="l00705"></a>00705   <span class="keywordtype">int</span> start_end_count_;
<a name="l00706"></a>00706   <span class="keywordtype">bool</span> is_depot_set_;
<a name="l00707"></a>00707   VarMap cumuls_;
<a name="l00708"></a>00708   VarMap transits_;
<a name="l00709"></a>00709   hash_map&lt;string, Solver::IndexEvaluator2*&gt; transit_evaluators_;
<a name="l00710"></a>00710   <span class="keywordtype">bool</span> closed_;
<a name="l00711"></a>00711   <a class="code" href="classoperations__research_1_1RoutingModel.html#328a19213729eec49288128061bc2044" title="Status of the search.">Status</a> status_;
<a name="l00712"></a>00712 
<a name="l00713"></a>00713   <span class="comment">// Search data</span>
<a name="l00714"></a>00714   <a class="code" href="classoperations__research_1_1RoutingModel.html#6f38b3ff9a2e455677856d97e339da6d" title="First solution strategies, used as starting point of local search.">RoutingStrategy</a> first_solution_strategy_;
<a name="l00715"></a>00715   scoped_ptr&lt;Solver::IndexEvaluator2&gt; first_solution_evaluator_;
<a name="l00716"></a>00716   <a class="code" href="classoperations__research_1_1RoutingModel.html#0f0bd97e25af059ab2e8e7f263afc8e1" title="Metaheuristics used to guide the search.">RoutingMetaheuristic</a> metaheuristic_;
<a name="l00717"></a>00717   std::vector&lt;SearchMonitor*&gt; monitors_;
<a name="l00718"></a>00718   SolutionCollector* collect_assignments_;
<a name="l00719"></a>00719   DecisionBuilder* solve_db_;
<a name="l00720"></a>00720   DecisionBuilder* improve_db_;
<a name="l00721"></a>00721   DecisionBuilder* restore_assignment_;
<a name="l00722"></a>00722   Assignment* assignment_;
<a name="l00723"></a>00723   Assignment* preassignment_;
<a name="l00724"></a>00724   std::vector&lt;IntVar*&gt; extra_vars_;
<a name="l00725"></a>00725   std::vector&lt;LocalSearchOperator*&gt; extra_operators_;
<a name="l00726"></a>00726   std::vector&lt;LocalSearchFilter*&gt; filters_;
<a name="l00727"></a>00727 
<a name="l00728"></a>00728   int64 time_limit_ms_;
<a name="l00729"></a>00729   int64 lns_time_limit_ms_;
<a name="l00730"></a>00730   SearchLimit* limit_;
<a name="l00731"></a>00731   SearchLimit* ls_limit_;
<a name="l00732"></a>00732   SearchLimit* lns_limit_;
<a name="l00733"></a>00733 
<a name="l00734"></a>00734   <span class="comment">// Callbacks to be deleted</span>
<a name="l00735"></a>00735   hash_set&lt;NodeEvaluator2*&gt; owned_node_callbacks_;
<a name="l00736"></a>00736   hash_set&lt;Solver::IndexEvaluator2*&gt; owned_index_callbacks_;
<a name="l00737"></a>00737 
<a name="l00738"></a>00738   DISALLOW_COPY_AND_ASSIGN(<a class="code" href="classoperations__research_1_1RoutingModel.html#67e90b8e5fba64a285e2eed07a39b2ca" title="Supposes a single depot.">RoutingModel</a>);
<a name="l00739"></a>00739 };
<a name="l00740"></a>00740 
<a name="l00741"></a>00741 }  <span class="comment">// namespace operations_research</span>
<a name="l00742"></a>00742 
<a name="l00743"></a>00743 <span class="preprocessor">#endif  // OR_TOOLS_CONSTRAINT_SOLVER_ROUTING_H_</span>
</pre></div></div>

  <!-- Start of footer. -->
  <table width=100% cellpadding=0 cellspacing=0 border=0>
    <tr valign=top>
      <td colspan=2 height=10></td>
    </tr>
    <tr valign=top>
      <td colspan=2 bgcolor=#287003 height=3></td>
    </tr>
  </table>

  <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
  <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
  <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
  <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
  <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
  <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
  <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
  <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
  <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
  <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
  <br /><br />

  
  </body>
</html>
