

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>10.6. Partial routes and Assigments &mdash; or-tools User&#39;s Manual</title>
    
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     'doc version 0.0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  false
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../../_static/logo.ico"/>
    <link rel="top" title="or-tools User&#39;s Manual" href="../../index.html" />
    <link rel="up" title="10. Vehicule Routing Problems with constraints: the capacitated vehicle routing problem" href="../VRP.html" />
    <link rel="next" title="10.7. Summary" href="cvrp_summary.html" />
    <link rel="prev" title="10.5. Multi-depots and vehicles" href="multi_depots.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="cvrp_summary.html" title="10.7. Summary"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="multi_depots.html" title="10.5. Multi-depots and vehicles"
             accesskey="P">previous</a> |</li>
        <li><a href="../../index.html">or-tools User&#39;s Manual</a> &raquo;</li>
          <li><a href="../VRP.html" accesskey="U">10. Vehicule Routing Problems with constraints: the capacitated vehicle routing problem</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="partial-routes-and-assigments">
<span id="vrp-partial-routes"></span><h1>10.6. Partial routes and Assigments</h1>
<div class="files-sidebar container">
<ol>
  <li>C++ code:
    <ol>
      <li><a href="../../../tutorials/cplusplus/chap10/vrp_locks.cc">vrp_locks.cc</a></li>
    </ol>
  </li>
</ol></div>
<p>Sometimes, while searching for a good solution, you find some promising partial routes or you may already know that
some routes or partial routes should be part of a solution. Wouldn&#8217;t it be nifty to be able to fix some parts of
the solution and let the CP routing solver assign the rest of the solution? Dream no more: this possibility
is integrated in the RL and we detail it in this section.</p>
<div class="section" id="a-little-bit-of-terminology">
<h2>10.6.1. A little bit of terminology</h2>
<p>Before we go on, let&#8217;s agree on the terminology. Our routing problems are modelled with a graph <img class="math" src="../../_images/math/5d079ab2236d0c1f10d52a59d4b606c4a9c618a8.png" alt="G=(V, E \cup A)" style="vertical-align: -4px"/>
with <img class="math" src="../../_images/math/12d58aa29201da09d8e620f8698e3a37547f6b4a.png" alt="V" style="vertical-align: 0px"/> the set of all vertices, <img class="math" src="../../_images/math/fa2fa899f0afb05d6837885523503a2d4df434f9.png" alt="E" style="vertical-align: 0px"/> the set of edges and <img class="math" src="../../_images/math/019e9892786e493964e145e7c5cf7b700314e53b.png" alt="A" style="vertical-align: 0px"/> the set of arcs. Here are key terms that we will
use throughout the rest of part III:</p>
<dl class="docutils" id="index-0">
<dt><em>paths</em>:</dt>
<dd>We use <em>path</em> in the common graph theoretic sense. A <em>path</em> is a sequence of adjacent<a class="footnote-reference" href="#adjacent-edges" id="id1">[1]</a> edges and/or arcs with the
possibility to traverse these edges and/or arcs one after the other<a class="footnote-reference" href="#path-def-precision" id="id2">[2]</a>.
The first and last vertices belong to the path and are called respectively <em>start</em> end <em>end</em> vertices.</dd>
</dl>
<dl class="docutils" id="index-1">
<dt><em>cycles</em>:</dt>
<dd>A <em>cycle</em> is a path such that the start and end vertices are the same.</dd>
</dl>
<dl class="docutils" id="index-2">
<dt><em>simple paths</em>:</dt>
<dd>A <em>simple path</em> is a path that doesn&#8217;t intersect itself.</dd>
</dl>
<dl class="docutils" id="index-3">
<dt><em>simple cycles</em>:</dt>
<dd>A <em>simple cycle</em> is a simple path such that the start and end vertices coincide.</dd>
</dl>
<dl class="docutils" id="index-4">
<dt><em>routes</em>:</dt>
<dd>A <em>route</em> is a <em>simple path</em> or <em>simple cycle</em> that connects a starting depot and an ending depot <strong>and</strong> that is
traversed by <strong>only one</strong> vehicle.</dd>
</dl>
<dl class="docutils" id="index-5">
<dt><em>empty routes</em>:</dt>
<dd>An <em>empty route</em> is a pair of starting and ending depots that are assigned to the <strong>same</strong> vehicle.</dd>
</dl>
<dl class="docutils" id="index-6">
<dt><em>partial routes</em>:</dt>
<dd>A <em>partial route</em> is a simple path that is traversed by <strong>only one</strong> vehicle. The idea is to name &#8220;parts&#8221; of contiguous edges/arcs that
could be extended - in both incoming and outgoing directions - to form a route. A route can be considered as a partial route only if the starting and ending depots are
not the same. This partial route cannot be extended at both its end depot vertices but we still call it a <em>partial route</em>.</dd>
</dl>
<table class="docutils footnote" frame="void" id="adjacent-edges" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Two edges are <em>adjacent</em> if they share a common vertex.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="path-def-precision" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>We don&#8217;t distinguish between paths with only edges (<em>paths</em>), only arcs (<em>directed</em> paths)
or containing edges and arcs (<em>mixed</em> paths). In the same vein, we don&#8217;t distinguish between cycles with only edges
(<em>cycles</em>), only arcs (<em>circuits</em>) or containing edges and arcs (<em>mixed cycles</em>).</td></tr>
</tbody>
</table>
</div>
<div class="section" id="locks-and-the-applylockstoallvehicles-method">
<h2>10.6.2. <em>Locks</em> and the <tt class="docutils literal"><span class="pre">ApplyLocksToAllVehicles()</span></tt> method</h2>
<p>You can find the source code in the file <tt class="file docutils literal"><span class="pre">vrp_locks.cc</span></tt>.</p>
<p>A <em>lock</em> is what we call internally an <tt class="docutils literal"><span class="pre">std::vector&lt;RoutingModel::NodeIndex&gt;</span></tt> that represents a partial route.
Locks can be fixed (we prefer to say <em>applied</em>) before the search. Basically, this means that
given a lock <tt class="docutils literal"><span class="pre">p</span></tt> corresponding to a vehicle <tt class="docutils literal"><span class="pre">v</span></tt>
(again with the same abuse of notation):</p>
<blockquote>
<div><tt class="docutils literal"><span class="pre">NextVar(p[i])</span> <span class="pre">==</span> <span class="pre">p[i+1]</span></tt> for all <tt class="docutils literal"><span class="pre">i</span></tt> and <tt class="docutils literal"><span class="pre">i+1</span></tt> in <tt class="docutils literal"><span class="pre">p</span></tt></div></blockquote>
<p>and</p>
<blockquote>
<div><tt class="docutils literal"><span class="pre">VehicleVar(p[i])</span> <span class="pre">==</span> <span class="pre">v</span></tt> for all <tt class="docutils literal"><span class="pre">i</span></tt> in <tt class="docutils literal"><span class="pre">p</span></tt>.</div></blockquote>
<p>To apply the locks, use the <tt class="docutils literal"><span class="pre">ApplyLocksToAllVehicles()</span></tt> method:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">RoutingModel</span><span class="o">::</span><span class="n">NodeIndex</span><span class="p">,</span>
                       <span class="n">RoutingModel</span><span class="o">::</span><span class="n">NodeIndex</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">depots</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
<span class="c1">// Internal depots are 1, 3, 4 and 7</span>
<span class="c1">// thus with the TSPLIB convention in this manual,</span>
<span class="c1">// the real depots are 2, 4, 5 and 8</span>
<span class="n">depots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">);</span>
<span class="n">depots</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">);</span>
<span class="n">depots</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">);</span>
<span class="n">depots</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">);</span>
<span class="p">...</span>
<span class="n">RoutingModel</span> <span class="n">routing</span><span class="p">(</span><span class="mi">29</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">depots</span><span class="p">);</span> <span class="c1">// 29 nodes, 4 vehicles</span>
<span class="p">...</span>
<span class="n">routing</span><span class="p">.</span><span class="n">CloseModel</span><span class="p">();</span>

<span class="c1">//  Constructing partial routes</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">RoutingModel</span><span class="o">::</span><span class="n">NodeIndex</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">p</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="c1">// first partial route</span>
<span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">RoutingModel</span><span class="o">::</span><span class="n">NodeIndex</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
<span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">RoutingModel</span><span class="o">::</span><span class="n">NodeIndex</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
<span class="p">...</span>
<span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">RoutingModel</span><span class="o">::</span><span class="n">NodeIndex</span><span class="p">(</span><span class="mi">26</span><span class="p">));</span>
<span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">RoutingModel</span><span class="o">::</span><span class="n">NodeIndex</span><span class="p">(</span><span class="mi">7</span><span class="p">));</span>
<span class="c1">// second partial route</span>
<span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">RoutingModel</span><span class="o">::</span><span class="n">NodeIndex</span><span class="p">(</span><span class="mi">23</span><span class="p">));</span>
<span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">RoutingModel</span><span class="o">::</span><span class="n">NodeIndex</span><span class="p">(</span><span class="mi">18</span><span class="p">));</span>
<span class="p">...</span>
<span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">RoutingModel</span><span class="o">::</span><span class="n">NodeIndex</span><span class="p">(</span><span class="mi">13</span><span class="p">));</span>
<span class="p">...</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">routing</span><span class="p">.</span><span class="n">ApplyLocksToAllVehicles</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">FLAGS_close_routes</span><span class="p">))</span> <span class="p">{</span>
  <span class="n">LOG</span><span class="p">(</span><span class="n">FATAL</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Unable to apply locks...&quot;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here are a few remarks about the <tt class="docutils literal"><span class="pre">ApplyLocksToAllVehicles()</span></tt> method:</p>
<ul>
<li><p class="first">You can only call <tt class="docutils literal"><span class="pre">ApplyLocksToAllVehicles()</span></tt> if the model is closed (or you&#8217;ll trigger an <tt class="docutils literal"><span class="pre">assert()</span></tt>).</p>
</li>
<li><p class="first">Partial routes are attached to the corresponding starting depots.
For instance, <tt class="docutils literal"><span class="pre">p[1][0]</span></tt> is attached to the depot of the second route/vehicle. This means that partial routes constructed with the
<tt class="docutils literal"><span class="pre">ApplyLocksToAllVehicles()</span></tt> method all <strong>start</strong> at a given depot.</p>
</li>
<li><p class="first">The <tt class="docutils literal"><span class="pre">bool</span></tt> <tt class="docutils literal"><span class="pre">FLAGS_close_routes</span></tt> indicates if the routes are closed or not. If set to <tt class="docutils literal"><span class="pre">true</span></tt>, all the given
partial routes are closed (i.e. the last vertex of each lock is connected to the corresponding end depot)
and <strong>all the remaining</strong> <em>transit vertices</em> are <strong>deactivated</strong>. If set to <tt class="docutils literal"><span class="pre">false</span></tt>,
the partial routes are <strong>not</strong> closed and the remaining vertices are <strong>not</strong> deactivated (already
deactivated vertices remain deactivated).</p>
</li>
<li><p class="first">You can <strong>only</strong> use transit nodes and each transit node can only be in <strong>one</strong> lock (no depot allowed in the locks).</p>
</li>
<li><p class="first">You can add empty routes by adding an empty vector to the corresponding vehicle/route. In our example, route <tt class="docutils literal"><span class="pre">p[2]</span></tt>
is empty and can thus be completed by the CP routing solver (if <tt class="docutils literal"><span class="pre">FLAGS_close_routes</span></tt> is set to <tt class="docutils literal"><span class="pre">false</span></tt>). The remaining routes that were not defined in <tt class="docutils literal"><span class="pre">p</span></tt>
are closed (i.e. <tt class="docutils literal"><span class="pre">NextVar(routing.Start(v))</span> <span class="pre">==</span> <span class="pre">routing.End(v)</span></tt> for all <tt class="docutils literal"><span class="pre">v</span> <span class="pre">&gt;=</span> <span class="pre">p.size()</span></tt>).</p>
</li>
<li><p class="first">You can get the corresponding <tt class="docutils literal"><span class="pre">Assignment</span></tt> with the <tt class="docutils literal"><span class="pre">PreAssignment()</span></tt> method:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">const</span> <span class="n">Assignment</span><span class="o">*</span> <span class="k">const</span> <span class="n">solution_from_locks</span> <span class="o">=</span>
                                          <span class="n">routing</span><span class="p">.</span><span class="n">PreAssignment</span><span class="p">();</span>
</pre></div>
</div>
</li>
<li><p class="first">Finally, <tt class="docutils literal"><span class="pre">ApplyLocksToAllVehicles()</span></tt> returns <tt class="docutils literal"><span class="pre">true</span></tt> if the all
the locks could be applied and <tt class="docutils literal"><span class="pre">false</span></tt> otherwise.</p>
</li>
</ul>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Pay close attention to <strong>all</strong> the remarks before using the <tt class="docutils literal"><span class="pre">ApplyLocksToAllVehicles()</span></tt> method.</p>
</div>
<p>Now, let&#8217;s solve this instance:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">const</span> <span class="n">Assignment</span><span class="o">*</span> <span class="n">solution</span> <span class="o">=</span> <span class="n">routing</span><span class="p">.</span><span class="n">Solve</span><span class="p">();</span>
</pre></div>
</div>
<p>and inspect the solution:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">if</span> <span class="p">(</span><span class="n">solution</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Solution cost.</span>
  <span class="n">LG</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Obj value: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">solution</span><span class="o">-&gt;</span><span class="n">ObjectiveValue</span><span class="p">();</span>
  <span class="c1">// Inspect solution.</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">route</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">vehicle_nbr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">vehicle_nbr</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="o">++</span><span class="n">vehicle_nbr</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">route</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">int64</span> <span class="n">node</span> <span class="o">=</span> <span class="n">routing</span><span class="p">.</span><span class="n">Start</span><span class="p">(</span><span class="n">vehicle_nbr</span><span class="p">);</span>
         <span class="o">!</span><span class="n">routing</span><span class="p">.</span><span class="n">IsEnd</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
         <span class="n">node</span> <span class="o">=</span> <span class="n">solution</span><span class="o">-&gt;</span><span class="n">Value</span><span class="p">(</span><span class="n">routing</span><span class="p">.</span><span class="n">NextVar</span><span class="p">(</span><span class="n">node</span><span class="p">)))</span> <span class="p">{</span>
      <span class="n">route</span> <span class="o">=</span> <span class="n">StrCat</span><span class="p">(</span><span class="n">route</span><span class="p">,</span>
                <span class="n">StrCat</span><span class="p">(</span><span class="n">routing</span><span class="p">.</span><span class="n">IndexToNode</span><span class="p">(</span><span class="n">node</span><span class="p">).</span><span class="n">value</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                  <span class="s">&quot; -&gt; &quot;</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="n">route</span> <span class="o">=</span> <span class="n">StrCat</span><span class="p">(</span><span class="n">route</span><span class="p">,</span>
              <span class="n">routing</span><span class="p">.</span><span class="n">IndexToNode</span><span class="p">(</span>
                          <span class="n">routing</span><span class="p">.</span><span class="n">End</span><span class="p">(</span><span class="n">vehicle_nbr</span><span class="p">)).</span><span class="n">value</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">);</span>
    <span class="n">LG</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Route #&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">vehicle_nbr</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span>
       <span class="o">&lt;&lt;</span> <span class="n">route</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="n">LG</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;No solution found.&quot;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Let&#8217;s refresh our memory about the data instance before we look at the results.</p>
<p>The routes depots are:</p>
<ul class="simple">
<li>route 1: 2 and 5;</li>
<li>route 2: 4 and 5;</li>
<li>route 3: 4 and 8;</li>
<li>route 4: 5 and 8.</li>
</ul>
<p>The defined locks are:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">p[0]</span></tt>: 1 -&gt; 3 -&gt; 18 -&gt; 27 -&gt; 22;</li>
<li><tt class="docutils literal"><span class="pre">p[1]</span></tt>: 24 -&gt; 19 -&gt; 16 -&gt; 14;</li>
<li><tt class="docutils literal"><span class="pre">p[2]</span></tt>:</li>
</ul>
<p>The fact that we only applied locks for the 3 first routes while the model has 4 routes means that the fourth route will not be used
in the search.</p>
<p>If you set <tt class="docutils literal"><span class="pre">FLAGS_close_routes</span></tt> to <tt class="docutils literal"><span class="pre">true</span></tt>, you&#8217;ll get a partial solution that is <strong>not</strong> feasible and the following
expected result:</p>
<div class="highlight-bash"><div class="highlight"><pre>No solution found.
</pre></div>
</div>
<p>If you set <tt class="docutils literal"><span class="pre">FLAGS_close_routes</span></tt> to <tt class="docutils literal"><span class="pre">false</span></tt>, the partial solution made up by the locks is completed by the
CP routing solver:</p>
<div class="highlight-bash"><div class="highlight"><pre>Obj value: 804
Route <span class="c">#1</span>
2 -&gt; 1 -&gt; 3 -&gt; 18 -&gt; 27 -&gt; 22 -&gt; 26 -&gt; 5

Route <span class="c">#2</span>
4 -&gt; 24 -&gt; 19 -&gt; 16 -&gt; 14 -&gt; 17 -&gt; 21 -&gt; 25 -&gt; 29 -&gt; 5

Route <span class="c">#3</span>
4 -&gt; 6 -&gt; 7 -&gt; 9 -&gt; 10 -&gt; 11 -&gt; 12 -&gt; 13 -&gt; 15 -&gt; 20 -&gt; 23 -&gt; 28 -&gt; 8

Route <span class="c">#4</span>
5 -&gt; 8
</pre></div>
</div>
<p>If you find the <tt class="docutils literal"><span class="pre">ApplyLocksToAllVehicles()</span></tt> method too restrictive for your needs, you can always construct
a partial <tt class="docutils literal"><span class="pre">Assignment</span></tt> and pass it to the CP routing solver as we will do in the next sub-section.</p>
<div class="topic">
<p class="topic-title first">Locks and online problems</p>
<p>Locks can be applied when you have an idea of partial routes that should be fixed in
a solution for one reason or the other. A type of problems where you often apply locks is worth mentioning: the
so-called <em>online</em> or <em>dynamical</em> problems. These problems are dynamic in the sense that the instances gradually change
over time: some parts of these instances change with time or are only revealed over time.</p>
<p>For a VRP, you may think of actual drivers that are trapped in congested areas: you must then adapt the
routes to follow (to <em>reroute</em>) (or be prepared for some unpleasant consequences). You don&#8217;t want/have the time or the resources
to recompute a solution from scratch. The partial routes
not affected by congestion might still be optimal after all.</p>
<p>Problems where the instances are completely known - like all the problems presented in this manual - are
then coined as <em>offline</em> problems by contrast.</p>
</div>
</div>
<div class="section" id="assignments-and-partial-assignments">
<span id="vrp-assigments"></span><h2>10.6.3. <tt class="docutils literal"><span class="pre">Assignment</span></tt>s and partial <tt class="docutils literal"><span class="pre">Assignment</span></tt>s</h2>
<p>You can find the source code in the file <tt class="file docutils literal"><span class="pre">vrp_IO.cc</span></tt>.</p>
<p>The RL provides several helper methods to write and read <tt class="docutils literal"><span class="pre">Assignment</span></tt>s.</p>
<ol class="arabic">
<li><p class="first">First, you have the shortcut methods:</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="kt">bool</span> <span class="n">WriteAssignment</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">file_name</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="n">Assignment</span><span class="o">*</span> <span class="nf">ReadAssignment</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">file_name</span><span class="p">);</span>
</pre></div>
</div>
</div></blockquote>
<p>The first method writes the current solution to a file and the second method loads the <tt class="docutils literal"><span class="pre">Assignment</span></tt> contained in the
file as the current solution. The format used is the <em>protocol buffer</em> from
Google<a class="footnote-reference" href="#proto-format" id="id3">[3]</a>. These two methods are shortcuts. <tt class="docutils literal"><span class="pre">WriteAssignment()</span></tt> takes the current solution and invokes
its <tt class="docutils literal"><span class="pre">Save()</span></tt> method while <tt class="docutils literal"><span class="pre">ReadAssignment()</span></tt> invokes the <tt class="docutils literal"><span class="pre">Load()</span></tt> method of an <tt class="docutils literal"><span class="pre">Assignment</span></tt> and restores this
<tt class="docutils literal"><span class="pre">Assignment</span></tt> as the current solution with the <tt class="docutils literal"><span class="pre">RestoreAssignment</span></tt> <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>.</p>
<p>To test if everything went fine, use <tt class="docutils literal"><span class="pre">WriteAssignment()</span></tt> and <tt class="docutils literal"><span class="pre">ReadAssignment()</span></tt>. The former returns true if the
<tt class="docutils literal"><span class="pre">Assignment</span></tt> was successfully saved and false otherwise. The latter returns NULL if it could not load the <tt class="docutils literal"><span class="pre">Assignment</span></tt>
contained in the file as the current solution.</p>
<p>If you already have an <tt class="docutils literal"><span class="pre">Assignment</span></tt> at hand, you can restore it as the current solution with</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Assignment</span><span class="o">*</span> <span class="nf">RestoreAssignment</span><span class="p">(</span><span class="k">const</span> <span class="n">Assignment</span><span class="o">&amp;</span> <span class="n">solution</span><span class="p">);</span>
</pre></div>
</div>
<p>Again, if <tt class="docutils literal"><span class="pre">solution</span></tt> is not valid, <tt class="docutils literal"><span class="pre">RestoreAssignment()</span></tt> returns <tt class="docutils literal"><span class="pre">NULL</span></tt>. As usual with the <tt class="docutils literal"><span class="pre">RestoreAssignment</span></tt>
<tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>, you don&#8217;t need to provide a complete <tt class="docutils literal"><span class="pre">Assignment</span></tt>. If needed, the CP solver will complete the
solution. For the RL, this <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> will be the classical
default <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> on the <tt class="docutils literal"><span class="pre">NextVar()</span></tt> variables with the <tt class="docutils literal"><span class="pre">CHOOSE_FIRST_UNBOUND</span></tt> and <tt class="docutils literal"><span class="pre">ASSIGN_MIN_VALUE</span></tt>
strategies.</p>
<p>You can also add extra interesting <tt class="docutils literal"><span class="pre">IntVar</span></tt> variables to the routing <tt class="docutils literal"><span class="pre">Assignment</span></tt>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">AddToAssignment</span><span class="p">(</span><span class="n">IntVar</span><span class="o">*</span> <span class="k">const</span> <span class="n">var</span><span class="p">);</span>
</pre></div>
</div>
</li>
<li><p class="first">Second and more interestingly, the RL provides methods to translate an <tt class="docutils literal"><span class="pre">Assignment</span></tt> into and from
an <tt class="docutils literal"><span class="pre">std::vector&lt;std::vector&lt;RoutingModel::NodeIndex&gt;</span> <span class="pre">&gt;</span></tt>.
The vector is a little bit peculiar as it doesn&#8217;t hold the starting and ending depots:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">RoutingModel</span> <span class="nf">routing</span><span class="p">();</span> <span class="c1">// as above</span>
<span class="p">...</span>
<span class="k">const</span> <span class="n">Assignment</span><span class="o">*</span> <span class="n">solution</span> <span class="o">=</span> <span class="n">routing</span><span class="p">.</span><span class="n">Solve</span><span class="p">();</span>
<span class="p">...</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">RoutingModel</span><span class="o">::</span><span class="n">NodeIndex</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">sol</span><span class="p">;</span>
<span class="n">routing</span><span class="p">.</span><span class="n">AssignmentToRoutes</span><span class="p">(</span><span class="o">*</span><span class="n">solution</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sol</span><span class="p">);</span>
</pre></div>
</div>
<p>In the file <tt class="file docutils literal"><span class="pre">vrp_IO.cc</span></tt>, we print the vector and for the instance above, we obtain:</p>
<div class="highlight-bash"><div class="highlight"><pre>Solution saved into an std::vector of size 4
Route <span class="c">#1 with starting depot 2 and ending depot 5</span>
1 -&gt; 3 -&gt; 18 -&gt; 27 -&gt; 22 -&gt; 26

Route <span class="c">#2 with starting depot 4 and ending depot 5</span>
24 -&gt; 19 -&gt; 16 -&gt; 14 -&gt; 17 -&gt; 21 -&gt; 25 -&gt; 29

Route <span class="c">#3 with starting depot 4 and ending depot 8</span>
6 -&gt; 7 -&gt; 9 -&gt; 10 -&gt; 11 -&gt; 12 -&gt; 13 -&gt; 15 -&gt; 20 -&gt; 23 -&gt; 28

Route <span class="c">#4 with starting depot 5 and ending depot 8</span>
</pre></div>
</div>
<p>As you can see, no depot is saved into this <tt class="docutils literal"><span class="pre">std::vector</span></tt>. This is exactly the kind of <tt class="docutils literal"><span class="pre">std::vector</span></tt> that you need to
pass to <tt class="docutils literal"><span class="pre">RoutesToAssignment()</span></tt>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Assignment</span><span class="o">*</span> <span class="k">const</span> <span class="n">restored_sol</span> <span class="o">=</span>
                      <span class="n">routing</span><span class="p">.</span><span class="n">ReadAssignmentFromRoutes</span><span class="p">(</span><span class="n">sol</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
</pre></div>
</div>
<p>This method restores the solution contained in the vector as the current solution.</p>
</li>
</ol>
<p>In contrast to the <tt class="docutils literal"><span class="pre">RoutesToAssignment()</span></tt> method, the solution passed to <tt class="docutils literal"><span class="pre">ReadAssignmentFromRoutes()</span></tt> must be a complete
solution, i.e. all <tt class="docutils literal"><span class="pre">NextVar()</span></tt> mandatory variables must be assigned.</p>
<p>We also remind the reader that in contrast to all other loading methods presented here,
<tt class="docutils literal"><span class="pre">RoutesToAssignment()</span></tt> doesn&#8217;t reconstruct
a feasible solution and deals only with <tt class="docutils literal"><span class="pre">NextVar()</span></tt> variables. If your model has many complicated side constraints (like
<tt class="docutils literal"><span class="pre">Dimension</span></tt>s with slack variables), the CP routing solver might need some time to reconstruct a feasible solution
from the <tt class="docutils literal"><span class="pre">NextVar()</span></tt> variables.</p>
<table class="docutils footnote" frame="void" id="proto-format" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td>This format is a multi-platform compatible binary format for serializing structured data.
See their <a class="reference external" href="https://developers.google.com/protocol-buffers/docs/overview">website</a> or the
section <a class="reference internal" href="../utilities/serializing.html#serializing"><em>Serializing</em></a> where we reveal everything you always wanted to know about <em>serializing</em> with
the <em>or-tools</em> library.</td></tr>
</tbody>
</table>
<div class="topic">
<p class="topic-title first">Partial <tt class="docutils literal"><span class="pre">Assignment</span></tt>s and the RL</p>
<p>Partial <tt class="docutils literal"><span class="pre">Assignment</span></tt>s in the Routing Library have nothing special and
you can use partial <tt class="docutils literal"><span class="pre">Assignment</span></tt>s in a similar way with the CP solver.
The RL provides several handy helper methods that you can use in your own code.
Aside from the defensive testings, these methods are only several lines long.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<table>
<tr>
<td width="60"><img src="../../_static/logo.png" width="50" height="50"  alt="" /></td>
<td><p class="library_name">Google <a href="http://code.google.com/p/or-tools/"><strong>or-tools</strong></a><br>open source library</p></td>
</tr>
</table>
<h1>User's Manual</h1>

  
   



<h3>Google search</h3>

<form method="get" action="http://www.google.com/search">

<div style="padding:-1px;width:15em;">
<table border="0" cellpadding="0">
<tr><td>
<input type="text"   name="q" size="25"
 maxlength="255" value="" />
<input type="submit" value="Go" /></td></tr>
<tr><td align="center" style="font-size:80%">
Search:
<select name="sitesearch" width="125" style="width: 125px">
<option value="http://or-tools.googlecode.com/svn/trunk/documentation/user_manual/" selected>user's manual</option>
<option value="http://or-tools.googlecode.com/svn/trunk/documentation/faq/">faq</option>
<option value="http://or-tools.googlecode.com/svn/trunk/documentation/reference_manual/or-tools/">reference manual</option>
<option value="http://or-tools.googlecode.com/svn/trunk/documentation/">All or-tools doc</option>
</select>
</td></tr>
</table>
</div>

</form>
</br>




  <h3>Welcome</h3>
  
  <ul>
  	<li><a href="../../index.html">Content and foreword</a></li>
  	<li><a href="http://or-tools.googlecode.com/svn/trunk/documentation/documentation_hub.html">Documentation's hub</a></li>
	<li><a href="http://code.google.com/p/or-tools/">The or-tools open source library</a></li></li>	
  </ul>
  
   
	


  <h3>Tutorial examples</h3>
  
  <ul>
	<li><a href="http://or-tools.googlecode.com/svn/trunk/documentation/documentation_hub.html#tutorial_C++">C++</a></li>
	<li><a href="http://or-tools.googlecode.com/svn/trunk/documentation/documentation_hub.html#tutorial_Python">Python</a></li>	
	<li><a href="http://or-tools.googlecode.com/svn/trunk/documentation/documentation_hub.html#tutorial_Java">Java</a></li>
	<li><a href="http://or-tools.googlecode.com/svn/trunk/documentation/documentation_hub.html#tutorial_Csharp">C#</a></li>
</ul>
  
   
	

  <h3>Current chapter</h3>
  <p class="topless"><a href="../VRP.html"
                        title="previous chapter">10. Vehicule Routing Problems with constraints: the capacitated vehicle routing problem</a></p>
  <h3>Previous section</h3>
  <p class="topless"><a href="multi_depots.html"
                        title="previous chapter">10.5. Multi-depots and vehicles</a></p>
  <h3>Next section</h3>
  <p class="topless"><a href="cvrp_summary.html"
                        title="next chapter">10.7. Summary</a></p>
  <h3>Current section</a></h3>
  <ul>
<li><a class="reference internal" href="#">10.6. Partial routes and Assigments</a><ul>
<li><a class="reference internal" href="#a-little-bit-of-terminology">10.6.1. A little bit of terminology</a></li>
<li><a class="reference internal" href="#locks-and-the-applylockstoallvehicles-method">10.6.2. <em>Locks</em> and the <tt class="docutils literal"><span class="pre">ApplyLocksToAllVehicles()</span></tt> method</a></li>
<li><a class="reference internal" href="#assignments-and-partial-assignments">10.6.3. <tt class="docutils literal"><span class="pre">Assignment</span></tt>s and partial <tt class="docutils literal"><span class="pre">Assignment</span></tt>s</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="cvrp_summary.html" title="10.7. Summary"
             >next</a> |</li>
        <li class="right" >
          <a href="multi_depots.html" title="10.5. Multi-depots and vehicles"
             >previous</a> |</li>
        <li><a href="../../index.html">or-tools User&#39;s Manual</a> &raquo;</li>
          <li><a href="../VRP.html" >10. Vehicule Routing Problems with constraints: the capacitated vehicle routing problem</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012-2013, Google.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>