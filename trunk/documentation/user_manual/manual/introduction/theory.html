

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>1.3. A little bit of theory &mdash; or-tools User&#39;s Manual</title>
    
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     'doc version 0.0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  false
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../../_static/logo.ico"/>
    <link rel="top" title="or-tools User&#39;s Manual" href="../../index.html" />
    <link rel="up" title="1. Introduction to constraint programming" href="../introduction.html" />
    <link rel="next" title="1.4. Real examples" href="real_examples.html" />
    <link rel="prev" title="1.2. What is constraint programming?" href="what_is_cp.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="real_examples.html" title="1.4. Real examples"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="what_is_cp.html" title="1.2. What is constraint programming?"
             accesskey="P">previous</a> |</li>
        <li><a href="../../index.html">or-tools User&#39;s Manual</a> &raquo;</li>
          <li><a href="../introduction.html" accesskey="U">1. Introduction to constraint programming</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="a-little-bit-of-theory">
<span id="id1"></span><h1>1.3. A little bit of theory</h1>
<p>[MUST BE REREAD]</p>
<p>We give you in a nutshell the important ideas and
the vocabulary we use throughout this manual. In the section <a class="reference internal" href="#constraint-satisfaction-problem"><em>Constraint Satisfaction Problems (CSP) and Constraint Optimization Problems (COP)</em></a>,
we cover the basic vocabulary to talk about the problems we solve in CP. The section
<a class="reference internal" href="#complexity-in-a-few-lines"><em>Complexity theory in a few lines</em></a> introduces informally <em>complexity theory</em><a class="footnote-reference" href="#time-complexity" id="id2">[1]</a>.
One of the difficulties of this
theory is that there are a lot of technical details no to be missed. We have tried
in this section to introduce you to important ideas without being drawn into too many details
(some inescapable details are in the footnotes).</p>
<table class="docutils footnote" frame="void" id="time-complexity" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[1]</a></td><td>We talk here about <em>Time</em>-complexity theory, i.e. we are concerned with the time we need
to solve problems. There exist other complexity theories, for instance the <em>Space</em>-complexity
theory where we are concerned with the memory space needed to solve problems.</td></tr>
</tbody>
</table>
<p>Complexity theory is quite new (it really started in the &#8216;70s)
and is not easy (and after reading this section, you&#8217;ll have more questions than answers).
If you are allergic to theory, read the next two subsections
but skip the rest. We are convinced - we took the time to write it, right? - that
you would benefit from reading this section in its entirety but it is up to you.</p>
<div class="section" id="constraint-satisfaction-problems-csp-and-constraint-optimization-problems-cop">
<span id="constraint-satisfaction-problem"></span><h2>1.3.1. Constraint Satisfaction Problems (CSP) and Constraint Optimization Problems (COP)</h2>
<p>We illustrate the different components of a
Constraint Satisfaction Problem with the 4-queens problem we saw in the section <a class="reference internal" href="4queens.html#four-queens-problem"><em>The 4-queens problem</em></a>.
Each time, we use a general definition (for instance variable <img class="math" src="../../_images/math/67bc6daa9d6b964201d6cef60cbeb1ac5fd26ead.png" alt="x_i" style="vertical-align: -3px"/>) and then illustrate this definition by
the 4-queens problem (for instance variable <img class="math" src="../../_images/math/b77453505fc5ba87f06001a293090b221374b9be.png" alt="x_{21}" style="vertical-align: -4px"/>).</p>
<p>A <strong>CSP</strong> consists of</p>
<blockquote>
<div><ul>
<li><p class="first">a set of <strong>variables</strong> <img class="math" src="../../_images/math/2ab231acf867ace39541437bedcff17c1b25dbf8.png" alt="X = \{x_0, \ldots, x_{n-1}\}" style="vertical-align: -5px"/>.</p>
<p>Ex.: For the 4-queens problem, we have a binary variable <img class="math" src="../../_images/math/9ff77ee087b4287c6e82e414efbe4d79aba8c012.png" alt="x_{ij}" style="vertical-align: -6px"/> indicating the presence or not of a queen
on square <img class="math" src="../../_images/math/887919dfbc86eebc29e0373f98f97dbf23a0ae23.png" alt="(i,j)" style="vertical-align: -4px"/>:</p>
<div class="math">
<p><img src="../../_images/math/2d6d87903738beba57de44b06cea25fe378f5514.png" alt="X = \{x_{00}, x_{01}, x_{02}, x_{03}, x_{10}, x_{11}, x_{12},  \ldots, x_{33}\}"/></p>
</div></li>
<li><p class="first">for each variable <img class="math" src="../../_images/math/67bc6daa9d6b964201d6cef60cbeb1ac5fd26ead.png" alt="x_i" style="vertical-align: -3px"/>, a <em>finite</em> set <img class="math" src="../../_images/math/8dfcbccbc64a91b700ee90d800d2d0a0c2cda992.png" alt="D_i" style="vertical-align: -3px"/> of possible values (its <strong>domain</strong>).</p>
<p>Ex.: Each variable <img class="math" src="../../_images/math/9ff77ee087b4287c6e82e414efbe4d79aba8c012.png" alt="x_{ij}" style="vertical-align: -6px"/> is a binary variable, thus</p>
<div class="math">
<p><img src="../../_images/math/a8d0161c43b8f45e2a6ca59e393dde658de4e228.png" alt="D_{00} = D_{01} = \ldots = D_{33} = \{0,1\}."/></p>
</div></li>
<li><p class="first"><strong>constraints</strong> that restrict the values the variables can take simultaneously.</p>
<p>Ex.: Constraints that avoid that two queens are on the same row:</p>
<div class="math">
<p><img src="../../_images/math/62fd4cd6d4f046d90bc0ec2bbcaa77fa143eb788.png" alt="\begin{array}{rlcr}
\text{row 0:} &amp; x_{00} + x_{01} + x_{02} + x_{03} &amp; \leqslant &amp; 1\\
\text{row 1:} &amp; x_{10} + x_{11} + x_{12} + x_{13} &amp; \leqslant &amp; 1\\
\text{row 2:} &amp; x_{20} + x_{21} + x_{22} + x_{23} &amp; \leqslant &amp; 1\\
\text{row 3:} &amp; x_{30} + x_{31} + x_{32} + x_{33} &amp; \leqslant &amp; 1\\
\end{array}"/></p>
</div><p>Indeed, these constraints ensure that for each row <img class="math" src="../../_images/math/34857b3ba74ce5cd8607f3ebd23e9015908ada71.png" alt="i" style="vertical-align: 0px"/> at most one variable
<img class="math" src="../../_images/math/e79980f9fd9ede8a2762d150d907ecc53482a190.png" alt="x_{i0}, x_{i1}, x_{i2}" style="vertical-align: -4px"/> or
<img class="math" src="../../_images/math/26a8a694a69baf9a65d32b4407138e7991979341.png" alt="x_{i3}" style="vertical-align: -3px"/> could take the value <img class="math" src="../../_images/math/dce34f4dfb2406144304ad0d6106c5382ddd1446.png" alt="1" style="vertical-align: -1px"/>. Actually, we could replace the inequalities by equalities because
we know that every feasible solution must have a queen on each row. Later, in the
section <a class="reference internal" href="../search_primitives/basic_model_implementation.html#nqueen-implementation-basic-model"><em>Implementation of the basic model</em></a>, we will provide
another model with other variables and constraints.</p>
</li>
</ul>
</div></blockquote>
<p>As we mentioned earlier, values don&#8217;t need to be integers and constraints don&#8217;t need to be
algebraic equations or inequalities<a class="footnote-reference" href="#only-constraint-on-constraint-in-cp" id="id3">[2]</a>.</p>
<table class="docutils footnote" frame="void" id="only-constraint-on-constraint-in-cp" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[2]</a></td><td>Basically, the only requirement for a constraint in CP is its ability to be
propagated.</td></tr>
</tbody>
</table>
<p>If we want to <em>optimize</em>, i.e. to <em>minimize</em> or <em>maximize</em> an <em>objective function</em>, we talk about a Constraint Optimization
Problem (<strong>COP</strong>). The <strong>objective function</strong> can be one of the variables of the problem or a function of some or all the variables.</p>
<p>A <strong>feasible solution</strong> to a CSP or a COP is a feasible assignment: every variable has been assigned a value from its domain
in such a way that <em>all</em> the constraints of the model are respected. The <strong>objective value</strong> of a feasible solution is
the value of the objective function for this solution. An <strong>optimal solution</strong> to a COP is a feasible solution such
that there are no other solutions with better objective values. Note that an optimal solution doesn&#8217;t need to exist nor is it
unique.</p>
</div>
<div class="section" id="problems-instances-and-solutions">
<span id="problems-instances-solutions"></span><h2>1.3.2. Problems, instances and solutions</h2>
</div>
<div class="section" id="two-important-ideas-of-the-complexity-theory-for-the-hurried-reader">
<span id="two-important-ideas-complexity-theory-hurried-reader"></span><h2>1.3.3. Two important ideas of the complexity theory for the hurried reader</h2>
<p>If you prefer not to read the next section, we have summarized its main ideas:</p>
<ul class="simple">
<li>problems are divided in two categories<a class="footnote-reference" href="#more-than-one-category" id="id4">[3]</a>: <strong>easy</strong>
(<img class="math" src="../../_images/math/14ff51e70197053469742052bdebe94cb064ae51.png" alt="\text{P}" style="vertical-align: -1px"/> problems) and <strong>hard</strong> (<img class="math" src="../../_images/math/8ed27d32851b0b1fac3aa7982c862daf59f21d46.png" alt="\text{NP-Hard}" style="vertical-align: -1px"/> or <img class="math" src="../../_images/math/6d7719cf28def4d9e4a88d9df1d5dffec1619935.png" alt="\text{NP-Complete}" style="vertical-align: -4px"/> problems)
problems. Hard problems are also called <em>intractable</em><a class="footnote-reference" href="#intractable" id="id5">[5]</a> and in general we only can find
approximate solutions for such problems<a class="footnote-reference" href="#good-vs-proven" id="id6">[6]</a>.
Actually, the question of being able to find exact solutions to hard problems is still open (See the box
&#8220;The <img class="math" src="../../_images/math/50401cce0057136c835ebbad1f6037f8bc8465a3.png" alt="P \stackrel{?}{=} NP" style="vertical-align: 0px"/> question&#8221; below);</li>
<li>good solutions (vs. exact solutions) are called <em>approximations</em> and since the &#8216;90s a considerable
effort was invested in designing a <em>complexity
theory of approximations</em>. There is a whole zoo of complexity classes. Some problems can be approximated but without any
guarantee on the quality of the solution, others can be approximated with as much precision as you desire but
you have to pay the price for this precision: the more precision you want the slower your algorithm will be.
For some problems it is hard to find approximations and for others, it is even impossible to find an approximation with
any guarantee on its quality!</li>
</ul>
<table class="docutils footnote" frame="void" id="more-than-one-category" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[3]</a></td><td>Most problems of practical interest belong to either categories but these two categories
don&#8217;t cover all problems.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="garey-outdated" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id21">[4]</a></td><td>This book was written in 1979 and so misses the last developments of the complexity theory
but it clearly explains the NP-Completeness theory and
provides a long list of NP-Complete problems.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="intractable" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[5]</a></td><td><em>Intractable problems</em> are problems which in practice take too long to solve exactly, so there
is a gap between the theoretical definition (<img class="math" src="../../_images/math/f92cdaa60529de09ad1683bff22ee9be04dffa28.png" alt="\textrm{NP-Hard}" style="vertical-align: -1px"/> problems) and the
practical definition (<em>Intractable</em> problems).</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="good-vs-proven" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[6]</a></td><td>Technically, you could find an exact solution but you would not be able to prove that
it is indeed an exact solution in general.</td></tr>
</tbody>
</table>
</div>
<div class="section" id="complexity-theory-in-a-few-lines">
<span id="complexity-in-a-few-lines"></span><h2>1.3.4. Complexity theory in a few lines</h2>
<p>Some problems such as the <em>Travelling Salesman Problem</em> (see the chapter <a class="reference internal" href="../TSP.html#chapter-tsp-with-constraints"><em>Travelling Salesman Problems with constraints: the TSP with time windows</em></a>)
are hard to solve<a class="footnote-reference" href="#difficult-to-solve" id="id7">[7]</a>:
no one could ever come up
with a very efficient algorithm to solve this problem. On the other hand, other problems,
like the <em>Chinese Postman Problem</em>
(see the chapter <em class="xref std std-ref">chapter_arc_routing_with_constraints</em>), are solved very efficiently.
In the &#8216;70s, complexity experts were able to translate this
fact into a beautiful <em>complexity theory</em>.</p>
<table class="docutils footnote" frame="void" id="difficult-to-solve" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[7]</a></td><td>Roughly, we consider a problem to be hard to solve if we need a lot of time to solve it. Read on.</td></tr>
</tbody>
</table>
<p>Hard to solve problems are called <em>intractable</em> problems. When you cannot solve an intractable
problem to optimality, you can
try to find good solutions or/and <em>approximate</em> the problem. In the &#8216;90s, complexity experts continued their
investigation on the
complexity of solving problems and developed what is now known as the <em>approximation complexity theory</em>. Both theories
are quite new,
very interesting and ... not easy to understand. We try the <em>tour the force</em> to introduce them in a few lines.
We willingly kept certain technical details out of the way. These technical details <em>are important</em> and actually without
them, you can not construct a complexity theory.</p>
<div class="section" id="intractability">
<span id="id8"></span><h3>1.3.4.1. Intractability</h3>
<p>One of the main difficulties complexity experts faced in the &#8216;70s was to come up with a theoretical
definition of the complexity
of problems not algorithms. Indeed, it is relatively easy<a class="footnote-reference" href="#complexity-algo-difficult" id="id9">[8]</a> to define a complexity measure of
algorithms but how would you define
the complexity of a problem? If you have an efficient algorithm to solve a problem, you could say that the problem
belongs to the set of easy problems but what about difficult problems?
The fact that we don&#8217;t know an efficient algorithm to solve
these doesn&#8217;t mean these problems are really difficult. Someone could come up one day with an efficient algorithm!
The solution the experts came up with was to build equivalence classes between problems and define the complexity of
a problem with respect to the complexity of other problems (so the notion of complexity is relative not absolute):
a problem <img class="math" src="../../_images/math/019e9892786e493964e145e7c5cf7b700314e53b.png" alt="A" style="vertical-align: 0px"/> is as hard as a problem <img class="math" src="../../_images/math/ff5fb3d775862e2123b007eb4373ff6cc1a34d4e.png" alt="B" style="vertical-align: 0px"/> if there exists an efficient transformation <img class="math" src="../../_images/math/1dc1c0119a604b91be9142370dc3159b6a9bbcb9.png" alt="\tau" style="vertical-align: 0px"/>
that maps every
instance <img class="math" src="../../_images/math/8136a7ef6a03334a7246df9097e5bcc31ba33fd2.png" alt="b" style="vertical-align: 0px"/> of
problem <img class="math" src="../../_images/math/ff5fb3d775862e2123b007eb4373ff6cc1a34d4e.png" alt="B" style="vertical-align: 0px"/> into an instance <img class="math" src="../../_images/math/02d7934c9901da21b547877d23334c29af27e2e6.png" alt="\tau(b) = a" style="vertical-align: -4px"/> of problem <img class="math" src="../../_images/math/019e9892786e493964e145e7c5cf7b700314e53b.png" alt="A" style="vertical-align: 0px"/> such that if solve <img class="math" src="../../_images/math/c7d457e388298246adb06c587bccd419ea67f7e8.png" alt="a" style="vertical-align: 0px"/>,
you solve <img class="math" src="../../_images/math/8136a7ef6a03334a7246df9097e5bcc31ba33fd2.png" alt="b" style="vertical-align: 0px"/>.</p>
<img alt="../../_images/reduction.png" class="align-center" src="../../_images/reduction.png" style="height: 150px;" />
<p>Indeed, if there exists an efficient algorithm to solve
problem <img class="math" src="../../_images/math/019e9892786e493964e145e7c5cf7b700314e53b.png" alt="A" style="vertical-align: 0px"/>, you can also solve efficiently problem <img class="math" src="../../_images/math/ff5fb3d775862e2123b007eb4373ff6cc1a34d4e.png" alt="B" style="vertical-align: 0px"/>: transform an instance <img class="math" src="../../_images/math/8136a7ef6a03334a7246df9097e5bcc31ba33fd2.png" alt="b" style="vertical-align: 0px"/> into into
an instance <img class="math" src="../../_images/math/02d7934c9901da21b547877d23334c29af27e2e6.png" alt="\tau(b) = a" style="vertical-align: -4px"/> of problem <img class="math" src="../../_images/math/019e9892786e493964e145e7c5cf7b700314e53b.png" alt="A" style="vertical-align: 0px"/> and solve it with the efficient algorithm known to solve problem
<img class="math" src="../../_images/math/019e9892786e493964e145e7c5cf7b700314e53b.png" alt="A" style="vertical-align: 0px"/>. So problem <img class="math" src="../../_images/math/019e9892786e493964e145e7c5cf7b700314e53b.png" alt="A" style="vertical-align: 0px"/> is as difficult as
problem <img class="math" src="../../_images/math/ff5fb3d775862e2123b007eb4373ff6cc1a34d4e.png" alt="B" style="vertical-align: 0px"/> (because if you know an efficient algorithm to solve problem <img class="math" src="../../_images/math/019e9892786e493964e145e7c5cf7b700314e53b.png" alt="A" style="vertical-align: 0px"/>, you can solve problem <img class="math" src="../../_images/math/ff5fb3d775862e2123b007eb4373ff6cc1a34d4e.png" alt="B" style="vertical-align: 0px"/>
as efficiently) and we write <img class="math" src="../../_images/math/408da4b75f34fba020ef25fd2f0ce35769b11b56.png" alt="B \leqslant_{\text{T}} A" style="vertical-align: -4px"/> and say that problem <img class="math" src="../../_images/math/ff5fb3d775862e2123b007eb4373ff6cc1a34d4e.png" alt="B" style="vertical-align: 0px"/> <em>reduces efficiently</em>
to problem <img class="math" src="../../_images/math/019e9892786e493964e145e7c5cf7b700314e53b.png" alt="A" style="vertical-align: 0px"/>
or that <img class="math" src="../../_images/math/1dc1c0119a604b91be9142370dc3159b6a9bbcb9.png" alt="\tau" style="vertical-align: 0px"/> is an <em>efficient reduction</em><a class="footnote-reference" href="#alanturingt" id="id10">[9]</a>.
The search for an efficient algorithm is replaced by the search for an efficient reduction between
instances of two problems to prove complexity.</p>
<table class="docutils footnote" frame="void" id="complexity-algo-difficult" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[8]</a></td><td>Well, to a certain degree. You need to know what instances you consider, how these are
encoded, what type of machines you use and so on.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="alanturingt" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10">[9]</a></td><td>The <img class="math" src="../../_images/math/512dc0768885cd763b41f840733bdfe8c31ae1e7.png" alt="\text{T}" style="vertical-align: 0px"/> in <img class="math" src="../../_images/math/60558d78ce54153ab4b7a7a88caa75475b6a8d8c.png" alt="\leqslant_{\text{T}}" style="vertical-align: -4px"/> is in honor of Alan Turing. Different types of
efficient reductions exist.</td></tr>
</tbody>
</table>
<p>This main idea leads to a lot of technicalities:</p>
<blockquote>
<div><ul class="simple">
<li>how to measure the complexity of an algorithm?</li>
<li>what is an efficient transformation?</li>
<li>what are the requirements for such a reduction?</li>
<li>...</li>
</ul>
</div></blockquote>
<p>We don&#8217;t answer these interesting questions except the one on efficiency. We consider a reduction
<img class="math" src="../../_images/math/1dc1c0119a604b91be9142370dc3159b6a9bbcb9.png" alt="\tau" style="vertical-align: 0px"/> <em>efficient</em>
if there exist a polynomial-time bounded algorithm (this refers to the first question...) that can transform any
instance <img class="math" src="../../_images/math/8136a7ef6a03334a7246df9097e5bcc31ba33fd2.png" alt="b" style="vertical-align: 0px"/> of problem <img class="math" src="../../_images/math/ff5fb3d775862e2123b007eb4373ff6cc1a34d4e.png" alt="B" style="vertical-align: 0px"/> into an instance <img class="math" src="../../_images/math/c7d457e388298246adb06c587bccd419ea67f7e8.png" alt="a" style="vertical-align: 0px"/> of problem <img class="math" src="../../_images/math/019e9892786e493964e145e7c5cf7b700314e53b.png" alt="A" style="vertical-align: 0px"/> such that the solutions
correspond. This also means that we
consider an algorithm <em>efficient</em> if it is <em>polynomially time-bounded</em> (otherwise the efficiency of the
reduction would be useless).</p>
<p>The class of problems that can be efficiently solved is called <img class="math" src="../../_images/math/4b4cade9ca8a2c8311fafcf040bc5b15ca507f52.png" alt="P" style="vertical-align: 0px"/>, i.e. the class of problems that can be solved by
a polynomial-time bounded algorithm<a class="footnote-reference" href="#p-technically-speaking" id="id11">[10]</a><a class="footnote-reference" href="#p-in-practice" id="id12">[11]</a>.</p>
<table class="docutils footnote" frame="void" id="p-technically-speaking" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id11">[10]</a></td><td>For technical reasons, we don&#8217;t compare problems but <em>languages</em> and only consider
<em>decision problems</em>, i.e. problems that have a <em>yes/no</em> answer. The <em>Subset Sum Problem</em> is such a problem.
Given a finite set of integers, is there a non-empty subset whose sum is zero? The answer is yes or no. By extension,
we say an optimization problem is in <img class="math" src="../../_images/math/4b4cade9ca8a2c8311fafcf040bc5b15ca507f52.png" alt="P" style="vertical-align: 0px"/>, if its equivalent <em>decision problem</em> is in <img class="math" src="../../_images/math/4b4cade9ca8a2c8311fafcf040bc5b15ca507f52.png" alt="P" style="vertical-align: 0px"/>. For instance,
the Chinese Postman Problem (CPP) is an optimization problem where one wants to find a minimal route
traversing all edges
of a graph. The equivalent decision problem is &#8221; <em>Is it possible to find a feasible route with cost less or equal
to</em> <img class="math" src="../../_images/math/8c325612684d41304b9751c175df7bcc0f61f64f.png" alt="k" style="vertical-align: 0px"/> <em>?</em> &#8221; where <img class="math" src="../../_images/math/8c325612684d41304b9751c175df7bcc0f61f64f.png" alt="k" style="vertical-align: 0px"/> is a given integer. By extension, we will say that the CPP
is in <img class="math" src="../../_images/math/4b4cade9ca8a2c8311fafcf040bc5b15ca507f52.png" alt="P" style="vertical-align: 0px"/> (we should rather say that the CPP is in <img class="math" src="../../_images/math/965e85c5d394f9b307461c8a8a87a316ba27c079.png" alt="P-\text{optimization}" style="vertical-align: -4px"/>).</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="p-in-practice" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id12">[11]</a></td><td>This discussion is really about <em>theoretical</em> difficulties of problems. Some problems that
are theoretically easy (such as solving a Linear System or a Linear Program) are difficult in
practice and conversely, some problems that are theoretically difficult, such as the Knapsack Problem
are routinely solved on big instances.</td></tr>
</tbody>
</table>
<p>Some problems are difficult to solve but once you have an answer, it is quite straightforward to verify that a
given solution is indeed the solution of the problem. One such problem is the <em>Hamiltonian Path Problem (HPP)</em>.
Given a graph, is there a path that visits each vertex exactly once? Finding such a path is difficult but verifying
that a given path is indeed an Hamiltonian path, i.e. that passes exactly once through each vertex, can be
easily done. Problems for which it is easy to verify their solutions, i.e. for which this verification can be done
in polynomial time, are said to be in the class <img class="math" src="../../_images/math/35e650cafa2f70ede1a3563843e1f75c539761f8.png" alt="NP" style="vertical-align: 0px"/><a class="footnote-reference" href="#np-term" id="id13">[12]</a>. <img class="math" src="../../_images/math/0a9e39774d93f4876b7a540ea26f6fa9c6b756de.png" alt="P \subset NP" style="vertical-align: -1px"/> because if you can
find a solution in polynomial time, you can also verify this solution in polynomial time (just construct it).
Whether we have equality or not
between these two sets is one of the major unsolved theoretical questions in Operations Research (see the box
&#8220;The <img class="math" src="../../_images/math/50401cce0057136c835ebbad1f6037f8bc8465a3.png" alt="P \stackrel{?}{=} NP" style="vertical-align: 0px"/> question&#8221; below).</p>
<table class="docutils footnote" frame="void" id="np-term" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id13">[12]</a></td><td>The abbreviation <img class="math" src="../../_images/math/35e650cafa2f70ede1a3563843e1f75c539761f8.png" alt="NP" style="vertical-align: 0px"/> refers to <em>non-deterministic polynomial time</em>, not to <em>non-polynomial</em>.</td></tr>
</tbody>
</table>
<p>Not all problems in <img class="math" src="../../_images/math/e12ea0577ff0b662bec381b5f35dc3dbd9c3339f.png" alt="\text{NP}" style="vertical-align: -1px"/> seem to be of equal complexity. Some problems, such as the HPP are as hard as any problem
in <img class="math" src="../../_images/math/e12ea0577ff0b662bec381b5f35dc3dbd9c3339f.png" alt="\text{NP}" style="vertical-align: -1px"/>. Remember our classification of the complexity of problems? This means that every problem in <img class="math" src="../../_images/math/e12ea0577ff0b662bec381b5f35dc3dbd9c3339f.png" alt="\text{NP}" style="vertical-align: -1px"/> can
be transformed in polynomial time into the HPP. The hardest problems of <img class="math" src="../../_images/math/e12ea0577ff0b662bec381b5f35dc3dbd9c3339f.png" alt="\text{NP}" style="vertical-align: -1px"/> form the class of <img class="math" src="../../_images/math/6d7719cf28def4d9e4a88d9df1d5dffec1619935.png" alt="\text{NP-Complete}" style="vertical-align: -4px"/> problems.</p>
<div class="topic">
<p class="topic-title first">How can you prove that all problems in <img class="math" src="../../_images/math/e12ea0577ff0b662bec381b5f35dc3dbd9c3339f.png" alt="\text{NP}" style="vertical-align: -1px"/> are reducible to a problem?</p>
<p>Wait a minute. There is an infinite number of problems in <img class="math" src="../../_images/math/e12ea0577ff0b662bec381b5f35dc3dbd9c3339f.png" alt="\text{NP}" style="vertical-align: -1px"/>, many of which are unknown to us.
So, how is it possible to prove that all problems in <img class="math" src="../../_images/math/e12ea0577ff0b662bec381b5f35dc3dbd9c3339f.png" alt="\text{NP}" style="vertical-align: -1px"/> can be reduced to a problem (and
hereby proving that this problem belongs to the set of <img class="math" src="../../_images/math/6d7719cf28def4d9e4a88d9df1d5dffec1619935.png" alt="\text{NP-Complete}" style="vertical-align: -4px"/> problems?</p>
<p>This is done in two steps:</p>
<ol class="arabic">
<li><p class="first">First, you have to know that the reduction is <em>transitive</em>. This means that if <img class="math" src="../../_images/math/afc8ad1f66ffd169e136847ae1657634c76a2b01.png" alt="A \leqslant_{\text{T}} B" style="vertical-align: -4px"/>
and <img class="math" src="../../_images/math/13f396961e36a17b6003f97d57f3570021f3588a.png" alt="B \leqslant_{\text{T}} C" style="vertical-align: -4px"/> then <img class="math" src="../../_images/math/294b6cf3a0ca074c040e389b1d4a8eeb0668b1b2.png" alt="A \leqslant_{\text{T}} C" style="vertical-align: -4px"/>. Thus, if you have one problem
<img class="math" src="../../_images/math/3ead47fb9fb4a4c273feee398f72ff2a09702b84.png" alt="Z" style="vertical-align: 0px"/> such that all problems <img class="math" src="../../_images/math/2744600189f7f1df31756f2022b2d5212ef1c767.png" alt="A_i" style="vertical-align: -3px"/> in <img class="math" src="../../_images/math/e12ea0577ff0b662bec381b5f35dc3dbd9c3339f.png" alt="\text{NP}" style="vertical-align: -1px"/> are reducible to <img class="math" src="../../_images/math/3ead47fb9fb4a4c273feee398f72ff2a09702b84.png" alt="Z" style="vertical-align: 0px"/>, i.e.
<img class="math" src="../../_images/math/8d96799a95dd8394032126d1e922b013ebf7d8bd.png" alt="A_i \leqslant_{\text{T}} Z" style="vertical-align: -4px"/>, then to prove that all problems <img class="math" src="../../_images/math/2744600189f7f1df31756f2022b2d5212ef1c767.png" alt="A_i" style="vertical-align: -3px"/> in <img class="math" src="../../_images/math/e12ea0577ff0b662bec381b5f35dc3dbd9c3339f.png" alt="\text{NP}" style="vertical-align: -1px"/> reduce
to a problem <img class="math" src="../../_images/math/6a47ca0fe7cb276abc022af6ac88ddae1a9d6894.png" alt="X" style="vertical-align: 0px"/>, you just need to prove that <img class="math" src="../../_images/math/3ead47fb9fb4a4c273feee398f72ff2a09702b84.png" alt="Z" style="vertical-align: 0px"/> reduces to <img class="math" src="../../_images/math/6a47ca0fe7cb276abc022af6ac88ddae1a9d6894.png" alt="X" style="vertical-align: 0px"/>. Indeed, if
<img class="math" src="../../_images/math/03cd569166253c4b4dc478fd5c3e1422320d5eea.png" alt="Z \leqslant_{\text{T}} X" style="vertical-align: -4px"/> then <img class="math" src="../../_images/math/a6424038c88a1a647334e34763742da942f09abc.png" alt="A_i \leqslant_{\text{T}} Z \leqslant_{\text{T}} X" style="vertical-align: -4px"/><a class="footnote-reference" href="#to-prove-np-completeness" id="id14">[13]</a>.</p>
<p>The funny fact is that if <img class="math" src="../../_images/math/6a47ca0fe7cb276abc022af6ac88ddae1a9d6894.png" alt="X" style="vertical-align: 0px"/> is in <img class="math" src="../../_images/math/e12ea0577ff0b662bec381b5f35dc3dbd9c3339f.png" alt="\text{NP}" style="vertical-align: -1px"/>, then <img class="math" src="../../_images/math/d356cf20d4a30e4d146ccf0dfbbf19510e03e5a3.png" alt="X \leqslant_{\text{T}} Z" style="vertical-align: -4px"/> also.
If you can solve one problem in <img class="math" src="../../_images/math/6d7719cf28def4d9e4a88d9df1d5dffec1619935.png" alt="\text{NP-Complete}" style="vertical-align: -4px"/> efficiently, you can solve all the problems
in <img class="math" src="../../_images/math/e12ea0577ff0b662bec381b5f35dc3dbd9c3339f.png" alt="\text{NP}" style="vertical-align: -1px"/> efficiently!</p>
</li>
<li><p class="first">Several researchers (like for example Cook and Levin in the early &#8216;70s,
see <a class="reference external" href="https://en.wikipedia.org/wiki/Cook%27s_theorem">Wikipedia on the Cook-Levin Theorem</a>), were able to
prove that
all problems in <img class="math" src="../../_images/math/e12ea0577ff0b662bec381b5f35dc3dbd9c3339f.png" alt="\text{NP}" style="vertical-align: -1px"/> are reducible in polynomial time to the <em>Boolean satisfiability problem</em> (SAT).</p>
<p>Proving that the SAT problem is <img class="math" src="../../_images/math/6d7719cf28def4d9e4a88d9df1d5dffec1619935.png" alt="\text{NP-Complete}" style="vertical-align: -4px"/> is a major achievement in the complexity
theory (the proof is highly technical).</p>
</li>
</ol>
</div>
<table class="docutils footnote" frame="void" id="to-prove-np-completeness" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id14">[13]</a></td><td>If you want to prove that a problem <img class="math" src="../../_images/math/ce58e4af225c93d08606c26554caaa5ae32edeba.png" alt="Y" style="vertical-align: 0px"/> is <img class="math" src="../../_images/math/8ed27d32851b0b1fac3aa7982c862daf59f21d46.png" alt="\text{NP-Hard}" style="vertical-align: -1px"/> (see below),
take a problem that is <img class="math" src="../../_images/math/6d7719cf28def4d9e4a88d9df1d5dffec1619935.png" alt="\text{NP-Complete}" style="vertical-align: -4px"/>, like the HPP, and reduce it to your problem. This might sound easy
but it is not!</td></tr>
</tbody>
</table>
<p>Finally, if a problem is as hard as an <img class="math" src="../../_images/math/6d7719cf28def4d9e4a88d9df1d5dffec1619935.png" alt="\text{NP-Complete}" style="vertical-align: -4px"/> problem, it is called an <img class="math" src="../../_images/math/8ed27d32851b0b1fac3aa7982c862daf59f21d46.png" alt="\text{NP-Hard}" style="vertical-align: -1px"/> problem.
Optimization problems, whose decision version belong to <img class="math" src="../../_images/math/6d7719cf28def4d9e4a88d9df1d5dffec1619935.png" alt="\text{NP-Complete}" style="vertical-align: -4px"/>, fall into this category.</p>
<p>The next figure summarizes the relations between the complexity classes<a class="footnote-reference" href="#zoo-complexity-classes" id="id15">[14]</a> we have seen as most of the experts believe they stand, i.e. <img class="math" src="../../_images/math/ed4d62c5fa27cfbba79f8b58a2c8aba71c5d6d68.png" alt="\text{P} \neq \text{NP}" style="vertical-align: -4px"/>.</p>
<img alt="../../_images/complexity_classes.png" class="align-center" src="../../_images/complexity_classes.png" style="height: 250px;" />
<table class="docutils footnote" frame="void" id="zoo-complexity-classes" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id15">[14]</a></td><td>Be aware that there are many more complexity classes.</td></tr>
</tbody>
</table>
<div class="topic" id="thepvsnpquestion">
<p class="topic-title first">The <img class="math" src="../../_images/math/50401cce0057136c835ebbad1f6037f8bc8465a3.png" alt="P \stackrel{?}{=} NP" style="vertical-align: 0px"/> question</p>
<p>The P versus NP problem is a major unsolved problem in Computer Science. Informally, it asks whether every problem whose solution can be quickly verified by a computer (<img class="math" src="../../_images/math/71a2fd14e03e9dd7dc3ad58b450d7f56ab84bea2.png" alt="\in \text{NP}" style="vertical-align: -1px"/>) can also be quickly solved by a computer (<img class="math" src="../../_images/math/294fb5dad480e2dbd014ac72779885cad691fe0e.png" alt="\in \text{P}" style="vertical-align: -1px"/>). It is one of the seven Millennium Prize Problems selected by the Clay Mathematics Institute. The offered prize
to the first team to solve this question is $1,000,000!</p>
<p>In 2002 and 2012, W. I. Gasarch (see <a class="reference internal" href="#gasarch2002">[Gasarch2002]</a> and <a class="reference internal" href="#gasarch2012">[Gasarch2012]</a>) conducted a poll and asked his
colleagues what they thought
about the <img class="math" src="../../_images/math/50401cce0057136c835ebbad1f6037f8bc8465a3.png" alt="P \stackrel{?}{=} NP" style="vertical-align: 0px"/> question. Here are the results:</p>
<table border="1" class="docutils">
<colgroup>
<col width="59%" />
<col width="19%" />
<col width="22%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Outcome<a class="footnote-reference" href="#gasarch-more" id="id18">[15]</a></th>
<th class="head">% (2002)</th>
<th class="head">% (2012)</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><img class="math" src="../../_images/math/4811a569c64f4862145541b21ecdcff2798ad9bb.png" alt="P \neq NP" style="vertical-align: -4px"/></td>
<td>61</td>
<td>83</td>
</tr>
<tr class="row-odd"><td><img class="math" src="../../_images/math/e2dcb2b67c648906ad2d87fc1ef1ceb46ea6df7d.png" alt="P = NP" style="vertical-align: 0px"/></td>
<td>9</td>
<td>9</td>
</tr>
<tr class="row-even"><td>No idea</td>
<td>30</td>
<td>8</td>
</tr>
</tbody>
</table>
<p>One possible outcome - mentioned by very few - is that this question could be... undecidable, i.e. there is no
<em>yes</em> or <em>no</em> answer<a class="footnote-reference" href="#undecidable" id="id19">[16]</a>!</p>
</div>
<br><table class="docutils citation" frame="void" id="gasarch2002" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id16">[Gasarch2002]</a></td><td><ol class="first last upperalpha simple" start="23">
<li><ol class="first upperroman">
<li>Gasarch. <em>The P=?NP poll</em>, SIGACT News 33 (2), pp 34–47, 2002.</li>
</ol>
</li>
</ol>
</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="gasarch2012" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id17">[Gasarch2012]</a></td><td><ol class="first last upperalpha simple" start="23">
<li><ol class="first upperroman">
<li>Gasarch. <em>The second P =?NP poll</em>, SIGACT News 43(2), pp 53-77, 2012.</li>
</ol>
</li>
</ol>
</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="gasarch-more" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id18">[15]</a></td><td>We agglomerated all other answers into a category <em>No idea</em> although the poll
allowed people to fully express themselves (some answered &#8220;I don&#8217;t care&#8221; for instance). The first poll (2002)
involved 100 researchers while the second one involved 152 researchers.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="undecidable" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id19">[16]</a></td><td>See <a class="reference external" href="http://en.wikipedia.org/wiki/Undecidable_problem">Undecidable problem on Wikipedia</a>.</td></tr>
</tbody>
</table>
<p>If you are interested in this fascinating subject, we recommend that you read the classical book
<em>Computers and Intractability: A Guide to the Theory of NP-Completeness</em> from M. R. Garey and D. S. Johnson (see
<a class="reference internal" href="#garey1979">[Garey1979]</a><a class="footnote-reference" href="#garey-outdated" id="id21">[4]</a>).</p>
<table class="docutils citation" frame="void" id="garey1979" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id20">[Garey1979]</a></td><td>Garey, M. R. and Johnson D. S. <em>Computers and Intractability: A Guide to the Theory of NP-Completeness</em>,
1979, W. H. Freeman &amp; Co, New York, NY, USA, pp 338.</td></tr>
</tbody>
</table>
</div>
<div class="section" id="the-practical-aspect-of-intractability">
<h3>1.3.4.2. The practical aspect of intractability</h3>
<p>If you try to solve a problem that is proven to be <img class="math" src="../../_images/math/8ed27d32851b0b1fac3aa7982c862daf59f21d46.png" alt="\text{NP-Hard}" style="vertical-align: -1px"/>, you know that it is
probably an intractable problem (if <img class="math" src="../../_images/math/4811a569c64f4862145541b21ecdcff2798ad9bb.png" alt="P \neq NP" style="vertical-align: -4px"/>). At least, you know that no one could ever come with an efficient
algorithm to solve it and that it is unlikely to happen soon. Thus, you can not solve exactly &#8220;big&#8221; instances of your
problem. What can you do?</p>
<p>Maybe there are special cases that can be solved in polynomial time? If you are not interested in these cases and
your instances are too big to be solved exactly, even with parallel and/or decomposition algorithms, then there is only
one thing to do: approximate your problem and/or the solutions.</p>
<p>You could simplify your problem and/or be satisfied with an approximation, i.e. a solution that is not exact nor optimal.
One way to do this in CP is to relax the model by softening some constraints<a class="footnote-reference" href="#softening-constraints" id="id22">[17]</a>. In a nutshell,
you soften a constraint by allowing this constraint to be violated. In a approximate solution where the constraint is
violated, you penalize the objective function by a certain amount corresponding to the violation. The bigger the
violation, the bigger the penalty. The idea is to find a solution that doesn&#8217;t violate too much the soft constraints in
the hope that such approximate solution isn&#8217;t that different from an exact or optimal solution<a class="footnote-reference" href="#different-solution-optimization" id="id23">[18]</a>.</p>
<table class="docutils footnote" frame="void" id="softening-constraints" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id22">[17]</a></td><td>For MIP practitioners, this is equivalent to <em>Lagrangian Relaxation</em>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="different-solution-optimization" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id23">[18]</a></td><td>In the case of optimization, a solution that <em>isn&#8217;t that different</em> means a
solution that has a good objective value, preferably close to the optimum.</td></tr>
</tbody>
</table>
</div>
<div class="section" id="approximation-complexity">
<span id="id24"></span><h3>1.3.4.3. Approximation complexity</h3>
<p>[TO BE DONE]</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<table>
<tr>
<td width="60"><img src="../../_static/logo.png" width="50" height="50"  alt="" /></td>
<td><p class="library_name">Google <a href="http://code.google.com/p/or-tools/"><strong>or-tools</strong></a><br>open source library</p></td>
</tr>
</table>
<h1>User's Manual</h1>

  
   



<h3>Google search</h3>

<form method="get" action="http://www.google.com/search">

<div style="padding:-1px;width:15em;">
<table border="0" cellpadding="0">
<tr><td>
<input type="text"   name="q" size="25"
 maxlength="255" value="" />
<input type="submit" value="Go" /></td></tr>
<tr><td align="center" style="font-size:80%">
Search:
<select name="sitesearch" width="125" style="width: 125px">
<option value="http://or-tools.googlecode.com/svn/trunk/documentation/user_manual/" selected>user's manual</option>
<option value="http://or-tools.googlecode.com/svn/trunk/documentation/faq/">faq</option>
<option value="http://or-tools.googlecode.com/svn/trunk/documentation/reference_manual/or-tools/">reference manual</option>
<option value="http://or-tools.googlecode.com/svn/trunk/documentation/">All or-tools doc</option>
</select>
</td></tr>
</table>
</div>

</form>
</br>




  <h3>Welcome</h3>
  
  <ul>
  	<li><a href="../../index.html">Content and foreword</a></li>
  	<li><a href="http://or-tools.googlecode.com/svn/trunk/documentation/documentation_hub.html">Documentation's hub</a></li>
	<li><a href="http://code.google.com/p/or-tools/">The or-tools open source library</a></li></li>	
  </ul>
  
   
	


  <h3>Tutorial examples</h3>
  
  <ul>
	<li><a href="http://or-tools.googlecode.com/svn/trunk/documentation/documentation_hub.html#tutorial_C++">C++</a></li>
	<li><a href="http://or-tools.googlecode.com/svn/trunk/documentation/documentation_hub.html#tutorial_Python">Python</a></li>	
	<li><a href="http://or-tools.googlecode.com/svn/trunk/documentation/documentation_hub.html#tutorial_Java">Java</a></li>
	<li><a href="http://or-tools.googlecode.com/svn/trunk/documentation/documentation_hub.html#tutorial_Csharp">C#</a></li>
</ul>
  
   
	

  <h3>Current chapter</h3>
  <p class="topless"><a href="../introduction.html"
                        title="previous chapter">1. Introduction to constraint programming</a></p>
  <h3>Previous section</h3>
  <p class="topless"><a href="what_is_cp.html"
                        title="previous chapter">1.2. What is constraint programming?</a></p>
  <h3>Next section</h3>
  <p class="topless"><a href="real_examples.html"
                        title="next chapter">1.4. Real examples</a></p>
  <h3>Current section</a></h3>
  <ul>
<li><a class="reference internal" href="#">1.3. A little bit of theory</a><ul>
<li><a class="reference internal" href="#constraint-satisfaction-problems-csp-and-constraint-optimization-problems-cop">1.3.1. Constraint Satisfaction Problems (CSP) and Constraint Optimization Problems (COP)</a></li>
<li><a class="reference internal" href="#problems-instances-and-solutions">1.3.2. Problems, instances and solutions</a></li>
<li><a class="reference internal" href="#two-important-ideas-of-the-complexity-theory-for-the-hurried-reader">1.3.3. Two important ideas of the complexity theory for the hurried reader</a></li>
<li><a class="reference internal" href="#complexity-theory-in-a-few-lines">1.3.4. Complexity theory in a few lines</a><ul>
<li><a class="reference internal" href="#intractability">1.3.4.1. Intractability</a></li>
<li><a class="reference internal" href="#the-practical-aspect-of-intractability">1.3.4.2. The practical aspect of intractability</a></li>
<li><a class="reference internal" href="#approximation-complexity">1.3.4.3. Approximation complexity</a></li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="real_examples.html" title="1.4. Real examples"
             >next</a> |</li>
        <li class="right" >
          <a href="what_is_cp.html" title="1.2. What is constraint programming?"
             >previous</a> |</li>
        <li><a href="../../index.html">or-tools User&#39;s Manual</a> &raquo;</li>
          <li><a href="../introduction.html" >1. Introduction to constraint programming</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012-2013, Google.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>