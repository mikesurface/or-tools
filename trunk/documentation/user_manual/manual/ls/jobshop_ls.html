

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>6.7. The jobshop problem: and now with local search! &mdash; or-tools User&#39;s Manual</title>
    
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     'doc version 0.0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  false
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../../_static/logo.ico"/>
    <link rel="top" title="or-tools User&#39;s Manual" href="../../index.html" />
    <link rel="up" title="6. Local search: the job-shop problem" href="../LS.html" />
    <link rel="next" title="6.8. Filtering" href="ls_filtering.html" />
    <link rel="prev" title="6.6. Local Search Operators" href="ls_operators.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="ls_filtering.html" title="6.8. Filtering"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="ls_operators.html" title="6.6. Local Search Operators"
             accesskey="P">previous</a> |</li>
        <li><a href="../../index.html">or-tools User&#39;s Manual</a> &raquo;</li>
          <li><a href="../LS.html" accesskey="U">6. Local search: the job-shop problem</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="the-jobshop-problem-and-now-with-local-search">
<span id="jobshop-ls"></span><h1>6.7. The jobshop problem: and now with local search!</h1>
<div class="files-sidebar container">
<ol>
  <li>C++ code:
    <ol>
      <li><a href="../../../tutorials/cplusplus/chap6/jobshop_ls.h">jobshop_ls.h</a></li>
      <li><a href="../../../tutorials/cplusplus/chap6/jobshop_ls1.cc">jobshop_ls1.cc</a></li>
      <li><a href="../../../tutorials/cplusplus/chap6/jobshop_ls2.cc">jobshop_ls2.cc</a></li>
      <li><a href="../../../tutorials/cplusplus/chap6/jobshop_ls3.cc">jobshop_ls3.cc</a></li>
    </ol>
  </li>
  <li>Data files:
    <ol>
      <li><a href="../../../tutorials/cplusplus/chap6/first_example_jssp.txt">first_example_jssp.txt</a></li>
      <li><a href="../../../tutorials/cplusplus/chap6/abz9">abz9</a></li>
    </ol>
  </li>

</ol></div>
<p>We have seen in the previous section how to implement local search on our dummy example. This time, we apply
local search on a real problem and present the real thing: the <tt class="docutils literal"><span class="pre">MakeOneNeighbor()</span></tt> method, the
<tt class="docutils literal"><span class="pre">delta</span></tt> and <tt class="docutils literal"><span class="pre">deltadelta</span></tt> <tt class="docutils literal"><span class="pre">Assignment</span></tt>s and how to implement <em>incremental</em> <tt class="docutils literal"><span class="pre">LocalSearchOperator</span></tt>s.</p>
<p>To solve the job-shop problem, we&#8217;ll define two basic <tt class="docutils literal"><span class="pre">LocalSearchOperator</span></tt>s. First, we&#8217;ll apply them separately
and then we&#8217;ll combine them to get better results. In doing so, we will discover that local search
is very sensitive to the initial solution used to start it and that the search is path-dependent.</p>
<div class="section" id="localsearchoperators-the-real-thing">
<span id="local-search-operators-the-real-thing"></span><h2>6.7.1. <tt class="docutils literal"><span class="pre">LocalSearchOperator</span></tt>s: the real thing!</h2>
<p>Until now, we only have redefined the <tt class="docutils literal"><span class="pre">MakeOneNeighbor()</span></tt> method of a <tt class="docutils literal"><span class="pre">LocalSearchOperator</span></tt> but as we have seen
in the sub-section <a class="reference internal" href="basic_working_local_search.html#basic-local-search-algorithm-and-the-callback-hooks"><em>The basic local search algorithm and the callback hooks for the SearchMonitors  </em></a> , the <em>real</em> method
called by the <tt class="docutils literal"><span class="pre">MakeOneNeighbor</span></tt> <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> is <tt class="docutils literal"><span class="pre">MakeNextNeighbor()</span></tt>.</p>
<p>Before we dissect <tt class="docutils literal"><span class="pre">MakeNextNeighbor()</span></tt>, we quickly explain again what the <tt class="docutils literal"><span class="pre">delta</span></tt>s are.</p>
<div class="section" id="deltas-and-deltadeltas">
<h3>6.7.1.1. <tt class="docutils literal"><span class="pre">Delta</span></tt>s and <tt class="docutils literal"><span class="pre">DeltaDelta</span></tt>s</h3>
<p>The idea behind the <tt class="docutils literal"><span class="pre">Delta</span></tt>s and <tt class="docutils literal"><span class="pre">DeltaDelta</span></tt>s is really simple: efficiency. Only the modified part of
the solution is broadcast:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">Delta</span></tt>: the difference between the initial solution that defines the neighborhood and the current candidate solution.</li>
<li><tt class="docutils literal"><span class="pre">DeltaDelta</span></tt>: the difference between the current candidate solution and the previous candidate solution.</li>
</ul>
<p><tt class="docutils literal"><span class="pre">Delta</span></tt> and <tt class="docutils literal"><span class="pre">DeltaDelta</span></tt> are just <tt class="docutils literal"><span class="pre">Assignment</span></tt>s only containing the changes.</p>
</div>
<div class="section" id="makenextneighbor">
<h3>6.7.1.2. <tt class="docutils literal"><span class="pre">MakeNextNeighbor()</span></tt></h3>
<p>The signature of the <tt class="docutils literal"><span class="pre">MakeNextNeighbor()</span></tt> method is:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">bool</span> <span class="n">MakeNextNeighbor</span><span class="p">(</span><span class="n">Assignment</span><span class="o">*</span> <span class="n">delta</span><span class="p">,</span> <span class="n">Assignment</span><span class="o">*</span> <span class="n">deltadelta</span><span class="p">)</span>
</pre></div>
</div>
<p>This method constructs the <tt class="docutils literal"><span class="pre">delta</span></tt> and <tt class="docutils literal"><span class="pre">deltadelta</span></tt> corresponding to the new candidate solution
and returns <tt class="docutils literal"><span class="pre">true</span></tt>. If the neighborhood has been exhausted, i.e. the <tt class="docutils literal"><span class="pre">LocalSearchOperator</span></tt> cannot find another
candidate solution, this method returns <tt class="docutils literal"><span class="pre">false</span></tt>.</p>
<p>When you write your own <tt class="docutils literal"><span class="pre">MakeNextNeighbor()</span></tt> method, you <strong>have</strong> to provide the new <tt class="docutils literal"><span class="pre">delta</span></tt> but you can
skip the <tt class="docutils literal"><span class="pre">deltadelta</span></tt> if you prefer. This <tt class="docutils literal"><span class="pre">deltadelta</span></tt> can be convenient when you define your filters and
you can gain some efficiency over the sole use of <tt class="docutils literal"><span class="pre">delta</span></tt>s.</p>
<p>To help you construct these <tt class="docutils literal"><span class="pre">delta</span></tt>s, we provide an inner mechanism that constructs automatically these <tt class="docutils literal"><span class="pre">delta</span></tt>s
when you use the following self-explanatory setters:</p>
<ul class="simple">
<li>for <tt class="docutils literal"><span class="pre">IntVarLocalSearchOperator</span></tt>s only:<ul>
<li><tt class="docutils literal"><span class="pre">SetValue(int64</span> <span class="pre">index,</span> <span class="pre">int64</span> <span class="pre">value)</span></tt>;</li>
</ul>
</li>
<li>for <tt class="docutils literal"><span class="pre">SequenceVarLocalSearchOperator</span></tt>s only:<ul>
<li><tt class="docutils literal"><span class="pre">SetForwardSequence(int64</span> <span class="pre">index,</span> <span class="pre">const</span> <span class="pre">std::vector&lt;int&gt;&amp;</span> <span class="pre">value)</span></tt>;</li>
<li><tt class="docutils literal"><span class="pre">SetBackwardSequence(int64</span> <span class="pre">index,</span> <span class="pre">const</span> <span class="pre">std::vector&lt;int&gt;&amp;</span> <span class="pre">value)</span></tt>;</li>
</ul>
</li>
<li>for both:<ul>
<li><tt class="docutils literal"><span class="pre">Activate(int64</span> <span class="pre">index)</span></tt>;</li>
<li><tt class="docutils literal"><span class="pre">Deactivate(int64</span> <span class="pre">index)</span></tt>.</li>
</ul>
</li>
</ul>
<p>If you <strong>only</strong> use these methods to change the current solution, you then can automatically construct the <tt class="docutils literal"><span class="pre">delta</span></tt>s
by calling the <tt class="docutils literal"><span class="pre">ApplyChanges()</span></tt> method and revert these changes by calling the <tt class="docutils literal"><span class="pre">RevertChanges()</span></tt> method.</p>
<p>We recommend to use the following template to define your <tt class="docutils literal"><span class="pre">MakeNextNeighbor()</span></tt> method:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">MakeNextNeighbor</span><span class="p">(</span><span class="n">Assignment</span><span class="o">*</span> <span class="n">delta</span><span class="p">,</span>
                              <span class="n">Assignment</span><span class="o">*</span> <span class="n">deltadelta</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">CHECK_NOTNULL</span><span class="p">(</span><span class="n">delta</span><span class="p">);</span>
  <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">RevertChanges</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">NEIGHBORHOOD</span> <span class="n">EXHAUSTED</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// CONSTRUCT NEW CANDIDATE SOLUTION</span>
    <span class="p">...</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ApplyChanges</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">deltadelta</span><span class="p">))</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Currently, <tt class="docutils literal"><span class="pre">ApplyChanges()</span></tt> always returns <tt class="docutils literal"><span class="pre">true</span></tt> but this might change in the future and
then you might have to revert the changes, hence the <tt class="docutils literal"><span class="pre">while()</span></tt> loop.</p>
<p>We also provide several getters:</p>
<ul class="simple">
<li>for <tt class="docutils literal"><span class="pre">IntVarLocalSearchOperator</span></tt>s only:<ul>
<li><tt class="docutils literal"><span class="pre">int64</span> <span class="pre">Value(int64</span> <span class="pre">index)</span></tt>;</li>
<li><tt class="docutils literal"><span class="pre">IntVar*</span> <span class="pre">Var(int64</span> <span class="pre">index)</span></tt>;</li>
<li><tt class="docutils literal"><span class="pre">int64</span> <span class="pre">OldValue(int64</span> <span class="pre">index)</span></tt>;</li>
</ul>
</li>
<li>for <tt class="docutils literal"><span class="pre">SequenceVarLocalSearchOperator</span></tt>s only:<ul>
<li><tt class="docutils literal"><span class="pre">const</span> <span class="pre">std::vector&lt;int&gt;&amp;</span> <span class="pre">Sequence(int64</span> <span class="pre">index)</span></tt>;</li>
<li><tt class="docutils literal"><span class="pre">SequenceVar*</span> <span class="pre">Var(int64</span> <span class="pre">index)</span></tt>;</li>
<li><tt class="docutils literal"><span class="pre">const</span> <span class="pre">std::vector&lt;int&gt;&amp;</span> <span class="pre">OldSequence(int64</span> <span class="pre">index)</span></tt>;</li>
</ul>
</li>
<li>for both:<ul>
<li><tt class="docutils literal"><span class="pre">bool</span> <span class="pre">IsIncremental()</span></tt>;</li>
<li><tt class="docutils literal"><span class="pre">bool</span> <span class="pre">Activated(int64</span> <span class="pre">index)</span></tt>;</li>
</ul>
</li>
</ul>
<div class="topic">
<p class="topic-title first">Why would I want to use <tt class="docutils literal"><span class="pre">MakeNextNeighbor()</span></tt> instead of <tt class="docutils literal"><span class="pre">MakeOneNeighbor()</span></tt>?</p>
<p>One reason is efficiency: you skip one callback. But the real reason is that you might need
other methods than the ones that are provided to construct your candidate solution.
In this case, you have no other choice than to reimplement the <tt class="docutils literal"><span class="pre">MakeNextNeighbor()</span></tt> method.</p>
</div>
</div>
<div class="section" id="incrementality">
<h3>6.7.1.3. Incrementality</h3>
<p>[TO BE WRITTEN]</p>
</div>
</div>
<div class="section" id="the-initial-solution">
<h2>6.7.2. The initial solution</h2>
<p>We let the CP solver construct the initial solution for us. What about reusing the <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>
defined in the section <a class="reference internal" href="jobshop_implementation.html#jobshop-implementation-disjunctive-model"><em>An implementation of the disjunctive model</em></a> and grab its first feasible solution?</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// This decision builder will rank all tasks on all machines.</span>
<span class="n">DecisionBuilder</span><span class="o">*</span> <span class="k">const</span> <span class="n">sequence_phase</span> <span class="o">=</span>
    <span class="n">solver</span><span class="p">.</span><span class="n">MakePhase</span><span class="p">(</span><span class="n">all_sequences</span><span class="p">,</span> <span class="n">Solver</span><span class="o">::</span><span class="n">SEQUENCE_DEFAULT</span><span class="p">);</span>

<span class="c1">// After the ranking of tasks, the schedule is still loose and any</span>
<span class="c1">// task can be postponed at will. Fix the objective variable to its</span>
<span class="c1">// minimum value.</span>
<span class="n">DecisionBuilder</span><span class="o">*</span> <span class="k">const</span> <span class="n">obj_phase</span> <span class="o">=</span>
    <span class="n">solver</span><span class="p">.</span><span class="n">MakePhase</span><span class="p">(</span><span class="n">objective_var</span><span class="p">,</span>
                     <span class="n">Solver</span><span class="o">::</span><span class="n">CHOOSE_FIRST_UNBOUND</span><span class="p">,</span>
                     <span class="n">Solver</span><span class="o">::</span><span class="n">ASSIGN_MIN_VALUE</span><span class="p">);</span>

<span class="c1">// Initial solution for the Local Search.</span>
<span class="n">Assignment</span><span class="o">*</span> <span class="k">const</span> <span class="n">first_solution</span> <span class="o">=</span> <span class="n">solver</span><span class="p">.</span><span class="n">MakeAssignment</span><span class="p">();</span>
<span class="n">first_solution</span><span class="o">-&gt;</span><span class="n">Add</span><span class="p">(</span><span class="n">all_sequences</span><span class="p">);</span>
<span class="n">first_solution</span><span class="o">-&gt;</span><span class="n">AddObjective</span><span class="p">(</span><span class="n">objective_var</span><span class="p">);</span>

<span class="c1">// Store the first solution.</span>
<span class="n">DecisionBuilder</span><span class="o">*</span> <span class="k">const</span> <span class="n">store_db</span> <span class="o">=</span>
                       <span class="n">solver</span><span class="p">.</span><span class="n">MakeStoreAssignment</span><span class="p">(</span><span class="n">first_solution</span><span class="p">);</span>

<span class="c1">// The main decision builder (ranks all tasks, then fixes the</span>
<span class="c1">// objective_variable).</span>
<span class="n">DecisionBuilder</span><span class="o">*</span> <span class="k">const</span> <span class="n">first_solution_phase</span> <span class="o">=</span>
    <span class="n">solver</span><span class="p">.</span><span class="n">Compose</span><span class="p">(</span><span class="n">sequence_phase</span><span class="p">,</span> <span class="n">obj_phase</span><span class="p">,</span> <span class="n">store_db</span><span class="p">);</span>

<span class="n">LOG</span><span class="p">(</span><span class="n">INFO</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Looking for the first solution&quot;</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">bool</span> <span class="n">first_solution_found</span> <span class="o">=</span> <span class="n">solver</span><span class="p">.</span><span class="n">Solve</span><span class="p">(</span><span class="n">first_solution_phase</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">first_solution_found</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">LOG</span><span class="p">(</span><span class="n">INFO</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Solution found with makespan = &quot;</span>
            <span class="o">&lt;&lt;</span> <span class="n">first_solution</span><span class="o">-&gt;</span><span class="n">ObjectiveValue</span><span class="p">();</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="n">LOG</span><span class="p">(</span><span class="n">INFO</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;No initial solution found!&quot;</span><span class="p">;</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If you have some troubles to follow, go back to the section <a class="reference internal" href="jobshop_implementation.html#jobshop-implementation-disjunctive-model"><em>An implementation of the disjunctive model</em></a>
to understand the <tt class="docutils literal"><span class="pre">sequence_phase</span></tt> and <tt class="docutils literal"><span class="pre">obj_phase</span></tt> <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>s. Here, we simply add a
<tt class="docutils literal"><span class="pre">StoreAssignment</span></tt> <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> at the leaf of the search tree to collect the solutions with the
<tt class="docutils literal"><span class="pre">first_solution_phase</span></tt> <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>. Our initial solution will be stored in the <tt class="docutils literal"><span class="pre">first_solution</span></tt> <tt class="docutils literal"><span class="pre">Assignment</span></tt>.</p>
<p>Next, we define a first <tt class="docutils literal"><span class="pre">LocalSearchOperator</span></tt>.</p>
</div>
<div class="section" id="exchanging-two-intervalvars-on-a-sequencevar">
<h2>6.7.3. Exchanging two <tt class="docutils literal"><span class="pre">IntervalVar</span></tt>s on a <tt class="docutils literal"><span class="pre">SequenceVar</span></tt></h2>
<p>You&#8217;ll find the code in the file <tt class="file docutils literal"><span class="pre">jobshop_ls1.cc</span></tt> and the <tt class="docutils literal"><span class="pre">SwapIntervals</span></tt> operator in the file
<tt class="file docutils literal"><span class="pre">jobshop_ls</span></tt>.</p>
<p>The idea of exchanging two <tt class="docutils literal"><span class="pre">IntervalVar</span></tt>s on a <tt class="docutils literal"><span class="pre">SequenceVar</span></tt> is very common and the corresponding
operator is often referred to as the <tt class="docutils literal"><span class="pre">2-opt-</span></tt>, <tt class="docutils literal"><span class="pre">2-exchange-</span></tt> or <tt class="docutils literal"><span class="pre">swap-</span></tt> operator.</p>
<p>We implement a basic version that systematically exchanges all <tt class="docutils literal"><span class="pre">IntervalVar</span></tt>s for all <tt class="docutils literal"><span class="pre">SequenceVar</span></tt>s one after the
other in the order given by the <tt class="docutils literal"><span class="pre">std::vector</span></tt>s. We use three indices:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">int</span> <span class="pre">current_var_</span></tt>: the index of the processed <tt class="docutils literal"><span class="pre">SequenceVar</span></tt>;</li>
<li><tt class="docutils literal"><span class="pre">int</span> <span class="pre">current_first_</span></tt>: the index of the first <tt class="docutils literal"><span class="pre">IntervalVar</span></tt> variable to swap;</li>
<li><tt class="docutils literal"><span class="pre">int</span> <span class="pre">current_second_</span></tt>: the index of the second <tt class="docutils literal"><span class="pre">IntervalVar</span></tt> variable to swap.</li>
</ul>
<p>We proceed sequentially with the first <tt class="docutils literal"><span class="pre">SequenceVar</span></tt> (<tt class="docutils literal"><span class="pre">current_var_</span> <span class="pre">=</span> <span class="pre">0</span></tt>) and exchange the first and second <tt class="docutils literal"><span class="pre">IntervalVar</span></tt>s,
then the first and the third <tt class="docutils literal"><span class="pre">IntervalVar</span></tt>s and so on until exhaustion of all possibilities. Here is the code that
increments these indices to create each candidate solution:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">bool</span> <span class="nf">Increment</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">const</span> <span class="n">SequenceVar</span><span class="o">*</span> <span class="k">const</span> <span class="n">var</span> <span class="o">=</span> <span class="n">Var</span><span class="p">(</span><span class="n">current_var_</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">current_second_</span> <span class="o">&gt;=</span> <span class="n">var</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">current_first_</span> <span class="o">&gt;=</span> <span class="n">var</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">current_var_</span><span class="o">++</span><span class="p">;</span>
      <span class="n">current_first_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">current_second_</span> <span class="o">=</span> <span class="n">current_first_</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">current_var_</span> <span class="o">&lt;</span> <span class="n">Size</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This <tt class="docutils literal"><span class="pre">Increment()</span></tt> method returns a <tt class="docutils literal"><span class="pre">bool</span></tt> that indicates when the neighborhood is exhausted, i.e. it returns <tt class="docutils literal"><span class="pre">false</span></tt>
when there are no more candidate to construct. <tt class="docutils literal"><span class="pre">Size()</span></tt> and <tt class="docutils literal"><span class="pre">Var()</span></tt> are helper methods defined in the
<tt class="docutils literal"><span class="pre">SequenceVarLocalSearchOperator</span></tt> class. We start with <tt class="docutils literal"><span class="pre">current_var_</span></tt>, <tt class="docutils literal"><span class="pre">current_first_</span></tt> and <tt class="docutils literal"><span class="pre">current_second_</span></tt>
all set to <tt class="docutils literal"><span class="pre">0</span></tt>. Pay attention to
the fact that <tt class="docutils literal"><span class="pre">current_first_</span></tt>
and <tt class="docutils literal"><span class="pre">current_second_</span></tt> are also updated inside the <tt class="docutils literal"><span class="pre">if</span></tt> conditions.</p>
<p>We are now ready to define the <tt class="docutils literal"><span class="pre">OnStart()</span></tt> and <tt class="docutils literal"><span class="pre">MakeNextNeighbor()</span></tt> methods.</p>
<p>The <tt class="docutils literal"><span class="pre">OnStart()</span></tt> method is straightforward:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">virtual</span> <span class="kt">void</span> <span class="nf">OnStart</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">current_var_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">current_first_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">current_second_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>For the <tt class="docutils literal"><span class="pre">MakeNextNeighbor()</span></tt> method, we use our template:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">MakeNextNeighbor</span><span class="p">(</span><span class="n">Assignment</span><span class="o">*</span> <span class="n">delta</span><span class="p">,</span>
                              <span class="n">Assignment</span><span class="o">*</span> <span class="n">deltadelta</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">CHECK_NOTNULL</span><span class="p">(</span><span class="n">delta</span><span class="p">);</span>
  <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">RevertChanges</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Increment</span><span class="p">())</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">sequence</span> <span class="o">=</span> <span class="n">Sequence</span><span class="p">(</span><span class="n">current_var_</span><span class="p">);</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">sequence</span><span class="p">[</span><span class="n">current_first_</span><span class="p">];</span>
    <span class="n">sequence</span><span class="p">[</span><span class="n">current_first_</span><span class="p">]</span> <span class="o">=</span> <span class="n">sequence</span><span class="p">[</span><span class="n">current_second_</span><span class="p">];</span>
    <span class="n">sequence</span><span class="p">[</span><span class="n">current_second_</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
    <span class="n">SetForwardSequence</span><span class="p">(</span><span class="n">current_var_</span><span class="p">,</span> <span class="n">sequence</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">ApplyChanges</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">deltadelta</span><span class="p">))</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If <tt class="docutils literal"><span class="pre">Increment()</span></tt> returns <tt class="docutils literal"><span class="pre">false</span></tt>, we have exhausted the neighborhood and <tt class="docutils literal"><span class="pre">MakeNextNeighbor()</span></tt> must return
<tt class="docutils literal"><span class="pre">false</span></tt>. <tt class="docutils literal"><span class="pre">Sequence()</span></tt> and <tt class="docutils literal"><span class="pre">SetForwardSequence()</span></tt> are two helper methods from the <tt class="docutils literal"><span class="pre">SequenceVarLocalSearchOperator</span></tt>
class that allow us to use the <tt class="docutils literal"><span class="pre">ApplyChanges()``&nbsp;method</span> <span class="pre">to</span> <span class="pre">construct</span> <span class="pre">the</span> <span class="pre">``delta</span></tt>s.</p>
<p>And that&#8217;s it! Our <tt class="docutils literal"><span class="pre">LocalSearchOperator</span></tt> operator is completed. Let&#8217;s test it!</p>
<p>First, we need our <tt class="docutils literal"><span class="pre">LocalSearchOperator</span></tt>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">LocalSearchOperator</span><span class="o">*</span> <span class="k">const</span> <span class="n">swap_operator</span> <span class="o">=</span>
<span class="n">solver</span><span class="p">.</span><span class="n">RevAlloc</span><span class="p">(</span><span class="k">new</span> <span class="n">SwapIntervals</span><span class="p">(</span><span class="n">all_sequences</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span>
                                  <span class="n">all_sequences</span><span class="p">.</span><span class="n">size</span><span class="p">()));</span>
</pre></div>
</div>
<p>Then we need a complementary <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> to construct <em>feasible</em> candidate solutions. We don&#8217;t want to
spent too much time on the completion of our solutions. We will use the <tt class="docutils literal"><span class="pre">CHOOSE_RANDOM_RANK_FORWARD</span></tt> strategy:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">DecisionBuilder</span><span class="o">*</span> <span class="k">const</span> <span class="n">random_sequence_phase</span> <span class="o">=</span>
               <span class="n">solver</span><span class="p">.</span><span class="n">MakePhase</span><span class="p">(</span><span class="n">all_sequences</span><span class="p">,</span>
                                <span class="n">Solver</span><span class="o">::</span><span class="n">CHOOSE_RANDOM_RANK_FORWARD</span><span class="p">);</span>

<span class="n">DecisionBuilder</span><span class="o">*</span> <span class="k">const</span> <span class="n">complementary_ls_db</span> <span class="o">=</span>
          <span class="n">solver</span><span class="p">.</span><span class="n">MakeSolveOnce</span><span class="p">(</span><span class="n">solver</span><span class="p">.</span><span class="n">Compose</span><span class="p">(</span><span class="n">random_sequence_phase</span><span class="p">,</span>
                                              <span class="n">obj_phase</span><span class="p">));</span>
</pre></div>
</div>
<p>If we run the program <tt class="file docutils literal"><span class="pre">jobshop_ls1</span></tt> with our instance problem (file <tt class="file docutils literal"><span class="pre">first_example_jssp.txt</span></tt>),
we get the optimal solution. Always a good sign. With the instance in <tt class="file docutils literal"><span class="pre">abz9</span></tt> however, we only get a
solution with a cost of 1051 in 51,295 seconds:</p>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="25%" />
<col width="25%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Time (in s.)</th>
<th class="head">Value</th>
<th class="head">Candidates</th>
<th class="head">Solutions</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>51,295</td>
<td>1051</td>
<td>31172</td>
<td>26</td>
</tr>
</tbody>
</table>
<p>Not very satisfactory: <tt class="docutils literal"><span class="pre">1051</span></tt> is really far from the optimal value of <tt class="docutils literal"><span class="pre">679</span></tt>. Let&#8217;s try to generalize our operator. Instead of
just swapping two <tt class="docutils literal"><span class="pre">IntervalVar</span></tt>s, we&#8217;ll shuffle an arbitrary number of <tt class="docutils literal"><span class="pre">IntervalVar</span></tt>s per <tt class="docutils literal"><span class="pre">SequenceVar</span></tt>
in the next subsection.</p>
</div>
<div class="section" id="exchanging-an-arbitrary-number-of-contiguous-intervalvars-on-a-sequencevar">
<h2>6.7.4. Exchanging an arbitrary number of contiguous <tt class="docutils literal"><span class="pre">IntervalVar</span></tt>s on a <tt class="docutils literal"><span class="pre">SequenceVar</span></tt></h2>
<p>You&#8217;ll find the code in the file <tt class="file docutils literal"><span class="pre">jobshop_ls2.cc</span></tt> and the <tt class="docutils literal"><span class="pre">ShuffleIntervals</span></tt> operator in the file
<tt class="file docutils literal"><span class="pre">jobshop_ls</span></tt>.</p>
<p>After having implemented the <tt class="docutils literal"><span class="pre">SwapIntervals</span></tt> operator, the only real difficulty that remains is to implement
a permutation. This is not an easy task but we&#8217;ll elude this difficulty by only exchanging
contiguous <tt class="docutils literal"><span class="pre">IntervalVar</span></tt>s and using the <tt class="docutils literal"><span class="pre">std::next_permutation()</span></tt> function.
You can find the declaration of this function in the header <tt class="file docutils literal"><span class="pre">algorithm</span></tt>. Its customizable version reads like:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">BidirectionalIterator</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Compare</span><span class="o">&gt;</span>
<span class="kt">bool</span> <span class="n">next_permutation</span> <span class="p">(</span><span class="n">BidirectionalIterator</span> <span class="n">first</span><span class="p">,</span>
                       <span class="n">BidirectionalIterator</span> <span class="n">last</span><span class="p">,</span> <span class="n">Compare</span> <span class="n">comp</span><span class="p">);</span>
</pre></div>
</div>
<p>We accept the default values for the <tt class="docutils literal"><span class="pre">BidirectionalIterator</span></tt> and the <tt class="docutils literal"><span class="pre">Compare</span></tt> classes.
It will rearrange the elements in the range <tt class="docutils literal"><span class="pre">[first,last)</span></tt> into the next <em>lexicographically greater</em> permutation.
An example will clarify this jargon:</p>
<table border="1" class="docutils">
<colgroup>
<col width="24%" />
<col width="76%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">No</th>
<th class="head">Permutations</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>1</td>
<td>0 1 2</td>
</tr>
<tr class="row-odd"><td>2</td>
<td>0 2 1</td>
</tr>
<tr class="row-even"><td>3</td>
<td>1 0 2</td>
</tr>
<tr class="row-odd"><td>4</td>
<td>1 2 0</td>
</tr>
<tr class="row-even"><td>5</td>
<td>2 0 1</td>
</tr>
<tr class="row-odd"><td>6</td>
<td>2 1 0</td>
</tr>
</tbody>
</table>
<p>We have generated the permutations of <tt class="docutils literal"><span class="pre">0,1,2</span></tt> with <tt class="docutils literal"><span class="pre">std::next_permutation()</span></tt>.
There are <tt class="docutils literal"><span class="pre">3!</span> <span class="pre">=</span> <span class="pre">6</span></tt> permutations (the first permutation is given to <tt class="docutils literal"><span class="pre">std::next_permutation()</span></tt>
and is not generated by it) and you can see that the permutations are ordered by <em>value</em>, i.e.
<tt class="docutils literal"><span class="pre">0</span> <span class="pre">1</span> <span class="pre">2</span></tt> is smaller than <tt class="docutils literal"><span class="pre">0</span> <span class="pre">2</span> <span class="pre">1</span></tt> that itself is smaller than <tt class="docutils literal"><span class="pre">1</span> <span class="pre">0</span> <span class="pre">2</span></tt>, etc<a class="footnote-reference" href="#next-permutation-explanation" id="id1">[1]</a>.</p>
<table class="docutils footnote" frame="void" id="next-permutation-explanation" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>This explanation is not rigorous but it is simple and you can fill the gaps. What
happens if you start with <tt class="docutils literal"><span class="pre">1</span> <span class="pre">0</span> <span class="pre">2</span></tt>? The <tt class="docutils literal"><span class="pre">std::next_permutation()</span></tt> function simply &#8220;returns&#8221; <tt class="docutils literal"><span class="pre">1</span> <span class="pre">2</span> <span class="pre">0</span></tt> (oops,
there goes our rigour again!). If you give it <tt class="docutils literal"><span class="pre">2</span> <span class="pre">1</span> <span class="pre">0</span></tt>, this function returns <tt class="docutils literal"><span class="pre">false</span></tt> but there is a side effect as
the array will be ordered! Thus in our case, we&#8217;ll get <tt class="docutils literal"><span class="pre">0</span> <span class="pre">1</span> <span class="pre">2</span></tt>!</td></tr>
</tbody>
</table>
<p>As usual with the <tt class="docutils literal"><span class="pre">std</span></tt>, the <tt class="docutils literal"><span class="pre">last</span></tt> element is not involved in the permutation. There is only one more detail
we have to pay attention to. We ask the user to provide the length of the permutation with the <strong class="program">gflags</strong>
flag <tt class="docutils literal"><span class="pre">FLAGS_shuffle_length</span></tt>. First, we have to test if this length makes sense but we also have to adapt it to
each <tt class="docutils literal"><span class="pre">SequenceVar</span></tt> variable.</p>
<p>Without delay, we present the constructor of the <tt class="docutils literal"><span class="pre">ShuffleIntervals</span></tt> <tt class="docutils literal"><span class="pre">LocalSearchOperator</span></tt>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">ShuffleIntervals</span><span class="p">(</span><span class="k">const</span> <span class="n">SequenceVar</span><span class="o">*</span> <span class="k">const</span><span class="o">*</span> <span class="n">vars</span><span class="p">,</span>
                 <span class="kt">int</span> <span class="n">size</span><span class="p">,</span>
                 <span class="kt">int</span> <span class="n">max_length</span><span class="p">)</span> <span class="o">:</span>
  <span class="n">SequenceVarLocalSearchOperator</span><span class="p">(</span><span class="n">vars</span><span class="p">,</span> <span class="n">size</span><span class="p">),</span>
  <span class="n">max_length_</span><span class="p">(</span><span class="n">max_length</span><span class="p">),</span>
  <span class="n">current_var_</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span>
  <span class="n">current_first_</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span>
  <span class="n">current_length_</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{}</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">vars</span></tt> and <tt class="docutils literal"><span class="pre">size</span></tt> are just the array of <tt class="docutils literal"><span class="pre">SequenceVar</span></tt>s and its size. <tt class="docutils literal"><span class="pre">max_length</span></tt> is the length of the
sequence of <tt class="docutils literal"><span class="pre">IntervalVar</span></tt>s to shuffle. Because you can have less <tt class="docutils literal"><span class="pre">IntervalVar</span></tt>s for a given <tt class="docutils literal"><span class="pre">SequenceVar</span></tt>,
we have named it <tt class="docutils literal"><span class="pre">max_length</span></tt>.</p>
<p>The indices are very similar to the ones of the <tt class="docutils literal"><span class="pre">SwapIntervals</span></tt> operator:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">current_var_</span></tt>: the index of the processed <tt class="docutils literal"><span class="pre">SequenceVar</span></tt>;</li>
<li><tt class="docutils literal"><span class="pre">current_first_</span></tt>:  the index of the first <tt class="docutils literal"><span class="pre">IntervalVar</span></tt> variable to shuffle;</li>
<li><tt class="docutils literal"><span class="pre">current_length_</span></tt>: the length of the current sub-array of indices to shuffle. It must be smaller or equal to
the number of <tt class="docutils literal"><span class="pre">IntervalVar</span></tt>s in the <tt class="docutils literal"><span class="pre">SequenceVar</span></tt>.</li>
</ul>
<p>Here is the code to increment the next permutation:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">bool</span> <span class="nf">Increment</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">std</span><span class="o">::</span><span class="n">next_permutation</span><span class="p">(</span><span class="n">current_permutation_</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span>
                             <span class="n">current_permutation_</span><span class="p">.</span><span class="n">end</span><span class="p">()))</span> <span class="p">{</span>
    <span class="c1">// No permutation anymore -&gt; update indices</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">current_first_</span> <span class="o">&gt;</span>
                      <span class="n">Var</span><span class="p">(</span><span class="n">current_var_</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="n">current_length_</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">current_var_</span> <span class="o">&gt;=</span> <span class="n">Size</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">current_first_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="n">current_length_</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">Var</span><span class="p">(</span><span class="n">current_var_</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">(),</span>
                                 <span class="n">max_length_</span><span class="p">);</span>
      <span class="n">current_permutation_</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">current_length_</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// Reset first permutation in case we have to increase</span>
    <span class="c1">// the permutation.</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">current_length_</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">current_permutation_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// Start with the next permutation, not the identity</span>
    <span class="c1">// just constructed.</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">std</span><span class="o">::</span><span class="n">next_permutation</span><span class="p">(</span><span class="n">current_permutation_</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span>
                              <span class="n">current_permutation_</span><span class="p">.</span><span class="n">end</span><span class="p">()))</span> <span class="p">{</span>
      <span class="n">LOG</span><span class="p">(</span><span class="n">FATAL</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Should never happen!&quot;</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Thanks to the <tt class="docutils literal"><span class="pre">std::next_permutation()</span></tt> function, this is a breeze!
The <tt class="docutils literal"><span class="pre">OnStart()</span></tt> method is again straightforward:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">virtual</span> <span class="kt">void</span> <span class="nf">OnStart</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">current_var_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">current_first_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">current_length_</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">Var</span><span class="p">(</span><span class="n">current_var_</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">(),</span> <span class="n">max_length_</span><span class="p">);</span>
  <span class="n">current_permutation_</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">current_length_</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">current_length_</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">current_permutation_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We just have to pay attention to <tt class="docutils literal"><span class="pre">resize()</span></tt> the <tt class="docutils literal"><span class="pre">std::vector</span></tt> <tt class="docutils literal"><span class="pre">current_permutation_</span></tt> of indices
and we start with the same permutation: <tt class="docutils literal"><span class="pre">[0,</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">...]</span></tt>.</p>
<p>We again use our template for the <tt class="docutils literal"><span class="pre">MakeNextNeighbor()</span></tt> method:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">MakeNextNeighbor</span><span class="p">(</span><span class="n">Assignment</span><span class="o">*</span> <span class="n">delta</span><span class="p">,</span>
                              <span class="n">Assignment</span><span class="o">*</span> <span class="n">deltadelta</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">CHECK_NOTNULL</span><span class="p">(</span><span class="n">delta</span><span class="p">);</span>
  <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">RevertChanges</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Increment</span><span class="p">())</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">sequence</span> <span class="o">=</span> <span class="n">Sequence</span><span class="p">(</span><span class="n">current_var_</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">sequence_backup</span><span class="p">(</span><span class="n">current_length_</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">current_length_</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">sequence_backup</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sequence</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">current_first_</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">current_length_</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">sequence</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">current_first_</span><span class="p">]</span> <span class="o">=</span>
          <span class="n">sequence_backup</span><span class="p">[</span><span class="n">current_permutation_</span><span class="p">[</span><span class="n">i</span><span class="p">]];</span>
    <span class="p">}</span>
    <span class="n">SetForwardSequence</span><span class="p">(</span><span class="n">current_var_</span><span class="p">,</span> <span class="n">sequence</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ApplyChanges</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">deltadelta</span><span class="p">))</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If <tt class="docutils literal"><span class="pre">Increment()</span></tt> returns <tt class="docutils literal"><span class="pre">false</span></tt>, we have exhausted the neighborhood and <tt class="docutils literal"><span class="pre">MakeNextNeighbor()</span></tt> must return
<tt class="docutils literal"><span class="pre">false</span></tt>. After the call to <tt class="docutils literal"><span class="pre">Increment()</span></tt>, we simply copy the indices according to the new generated permutation
and call the helper method <tt class="docutils literal"><span class="pre">SetForwardSequence()</span></tt> to update the current <tt class="docutils literal"><span class="pre">SequenceVar</span></tt> variable. <tt class="docutils literal"><span class="pre">ApplyChanges()</span></tt>
constructs the <tt class="docutils literal"><span class="pre">delta</span></tt>s for us.</p>
<p>File <tt class="file docutils literal"><span class="pre">jobshop_ls2.cc</span></tt> is exactly the same as file <tt class="file docutils literal"><span class="pre">jobshop_ls1.cc</span></tt> except that we use the <tt class="docutils literal"><span class="pre">ShuffleIntervals</span></tt>
operator instead of the <tt class="docutils literal"><span class="pre">SwapIntervals</span></tt> operator.</p>
<p>We again obtain the optimal solution on our instance problem (file <tt class="file docutils literal"><span class="pre">first_example_jssp.txt</span></tt> whether <tt class="docutils literal"><span class="pre">shuffle_length=2</span></tt>
or <tt class="docutils literal"><span class="pre">shuffle_length=3</span></tt>). What about the <tt class="file docutils literal"><span class="pre">abz9</span></tt> instance? The next table summarize some tests with different values
for the <tt class="docutils literal"><span class="pre">suffle_length</span></tt> parameter:</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="20%" />
<col width="20%" />
<col width="20%" />
<col width="20%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><tt class="docutils literal"><span class="pre">suffle_length</span></tt></th>
<th class="head">Time (in s.)</th>
<th class="head">Value</th>
<th class="head">Candidates</th>
<th class="head">Solutions</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>2</td>
<td>12,301</td>
<td>1016</td>
<td>4302</td>
<td>32</td>
</tr>
<tr class="row-odd"><td>3</td>
<td>21,312</td>
<td>1087</td>
<td>7505</td>
<td>15</td>
</tr>
<tr class="row-even"><td>4</td>
<td>170,087</td>
<td>1034</td>
<td>70854</td>
<td>33</td>
</tr>
<tr class="row-odd"><td>5</td>
<td>584,173</td>
<td>1055</td>
<td>268478</td>
<td>27</td>
</tr>
</tbody>
</table>
<p>These results are typical for a local search operator. There certainly are several lessons to be drawn from these results,
but let&#8217;s focus on one of the most basic and important ones. The path taken to find the
local optimum is crucial.  Even if the neighborhoods (theoretically) constructed with <tt class="docutils literal"><span class="pre">suffle_length</span></tt> set
to <tt class="docutils literal"><span class="pre">2</span></tt> are all contained in the neighborhoods constructed with <tt class="docutils literal"><span class="pre">suffle_length</span></tt> set to <tt class="docutils literal"><span class="pre">3</span></tt>, we don&#8217;t reach the
same local optimum. This is very important to understand. The paths taken in both cases are different. The (practical)
construction of the neighbourhoods is <strong>dynamic</strong> and <strong>path-dependent</strong>. Good (meta-)heuristics are <em>path-aware</em>: these
heuristics take the path (and thus the history of the search) into account. Moreover, bigger neighbourhoods
(<tt class="docutils literal"><span class="pre">shuffle_length</span> <span class="pre">=</span> <span class="pre">3</span></tt>) aren&#8217;t necessarily better than smaller ones (<tt class="docutils literal"><span class="pre">shuffle_length</span> <span class="pre">=</span> <span class="pre">2</span></tt>). We obtain a better
solution quicker with <tt class="docutils literal"><span class="pre">shuffle_length=2</span></tt> than with <tt class="docutils literal"><span class="pre">suffle_length=3</span></tt>.</p>
<p>The best solution obtained so far has a value of <tt class="docutils literal"><span class="pre">1016</span></tt>. Can we do better? That&#8217;s the topic of next sub-section!</p>
</div>
<div class="section" id="can-we-do-better">
<span id="jobshop-ls-can-we-do-better"></span><h2>6.7.5. Can we do better?</h2>
<p>You&#8217;ll find the code in the file <tt class="file docutils literal"><span class="pre">jobshop_ls3.cc</span></tt>.</p>
<p>You should know by now that whenever we ask this question in this manual, the answer is <em>yes</em>. To find a better solution, we&#8217;ll first
investigate how important the initial solution is and then we&#8217;ll enlarge our definition of a neighborhood by combining
our two <tt class="docutils literal"><span class="pre">LocalSearchOperator</span></tt>s.</p>
<div class="section" id="id2">
<h3>6.7.5.1. The initial solution</h3>
<p>Local search is strongly dependent on the initial solution. Investing time in finding a good solution is a good idea.
We&#8217;ll use... local search to find an initial solution to get the real local search started!
The idea is that maybe we can
find an even better
solution in the vicinity of this initial solution. We don&#8217;t want to spend too much time to find it though and we&#8217;ll limit
ourselves to a custom-made <tt class="docutils literal"><span class="pre">SearchLimit</span></tt>. To define this <tt class="docutils literal"><span class="pre">SearchLimit</span></tt>, we construct a callback:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">LSInitialSolLimit</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ResultCallback</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="nl">public:</span>
    <span class="n">LSInitialSolLimit</span><span class="p">(</span><span class="n">Solver</span> <span class="o">*</span> <span class="n">solver</span><span class="p">,</span> <span class="n">int64</span> <span class="n">global_time_limit</span><span class="p">,</span>
                      <span class="kt">int</span> <span class="n">solution_nbr_tolerance</span><span class="p">)</span> <span class="o">:</span>
      <span class="n">solver_</span><span class="p">(</span><span class="n">solver</span><span class="p">),</span> <span class="n">global_time_limit_</span><span class="p">(</span><span class="n">global_time_limit</span><span class="p">),</span>
      <span class="n">solution_nbr_tolerance_</span><span class="p">(</span><span class="n">solution_nbr_tolerance</span><span class="p">),</span>
      <span class="n">time_at_beginning_</span><span class="p">(</span><span class="n">solver_</span><span class="o">-&gt;</span><span class="n">wall_time</span><span class="p">()),</span>
      <span class="n">solutions_at_beginning_</span><span class="p">(</span><span class="n">solver_</span><span class="o">-&gt;</span><span class="n">solutions</span><span class="p">()),</span>
      <span class="n">solutions_since_last_check_</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>

    <span class="c1">//  Returns true if limit is reached, false otherwise.</span>
    <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">Run</span><span class="p">()</span> <span class="p">{</span>
      <span class="kt">bool</span> <span class="n">limit_reached</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

      <span class="c1">//  Test if time limit is reached.</span>
      <span class="k">if</span> <span class="p">((</span><span class="n">solver_</span><span class="o">-&gt;</span><span class="n">wall_time</span><span class="p">()</span> <span class="o">-</span> <span class="n">time_at_beginning_</span><span class="p">)</span>
                                             <span class="o">&gt;</span> <span class="n">global_time_limit_</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">limit_reached</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="c1">//  Test if we continue despite time limit reached.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">solver_</span><span class="o">-&gt;</span><span class="n">solutions</span><span class="p">()</span> <span class="o">-</span> <span class="n">solutions_since_last_check_</span>
                                       <span class="o">&gt;=</span> <span class="n">solution_nbr_tolerance_</span><span class="p">)</span> <span class="p">{</span>
          <span class="c1">//  We continue because we produce enough new solutions.</span>
          <span class="n">limit_reached</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span>
      <span class="n">solutions_since_last_check_</span> <span class="o">=</span> <span class="n">solver_</span><span class="o">-&gt;</span><span class="n">solutions</span><span class="p">();</span>

      <span class="k">return</span> <span class="n">limit_reached</span><span class="p">;</span>
    <span class="p">}</span>

  <span class="nl">private:</span>
    <span class="n">Solver</span> <span class="o">*</span> <span class="n">solver_</span><span class="p">;</span>
    <span class="n">int64</span> <span class="n">global_time_limit_</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">solution_nbr_tolerance_</span><span class="p">;</span>

    <span class="n">int64</span> <span class="n">time_at_beginning_</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">solutions_at_beginning_</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">solutions_since_last_check_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The main method in this callback is the <tt class="docutils literal"><span class="pre">virtual</span> <span class="pre">bool</span> <span class="pre">Run()</span></tt> method. This method returns <tt class="docutils literal"><span class="pre">true</span></tt>
if our limit has been reached and <tt class="docutils literal"><span class="pre">false</span></tt> otherwise. The time limit in ms is given by <tt class="docutils literal"><span class="pre">global_time_limit</span></tt>.
<strong>If</strong> the <tt class="docutils literal"><span class="pre">Search</span></tt> is still producing a certain amount <tt class="docutils literal"><span class="pre">solution_nbr_tolerance</span></tt> of solutions, we
let the search continue.</p>
<p>To initialize our first local search that finds our initial
solution, we use the same code as in the file <tt class="file docutils literal"><span class="pre">jobshop_ls2.cc</span></tt> (we call this first solution <tt class="docutils literal"><span class="pre">first_solution</span></tt>).</p>
<p>To find an initial solution, we use local search and start form the <tt class="docutils literal"><span class="pre">first_solution</span></tt> found.
We only use a <tt class="docutils literal"><span class="pre">ShuffleIntervals</span></tt> operator with a shuffle length of <tt class="docutils literal"><span class="pre">2</span></tt>. This time, we limit this local
search with our custom limit:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">SearchLimit</span> <span class="o">*</span> <span class="n">initial_search_limit</span> <span class="o">=</span> <span class="n">solver</span><span class="p">.</span><span class="n">MakeCustomLimit</span><span class="p">(</span>
              <span class="k">new</span> <span class="n">LSInitialSolLimit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">solver</span><span class="p">,</span>
                                    <span class="n">FLAGS_initial_time_limit_in_ms</span><span class="p">,</span>
                                    <span class="n">FLAGS_solutions_nbr_tolerance</span><span class="p">));</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">FLAGS_initial_time_limit_in_ms</span></tt> and <tt class="docutils literal"><span class="pre">FLAGS_solutions_nbr_tolerance</span></tt> are the two <strong class="program">gflags</strong> flags
we use in the constructor of the callback <tt class="docutils literal"><span class="pre">LSInitialSolLimit</span></tt> described above to limit the search.</p>
<p>The initial solution is stored in an <tt class="docutils literal"><span class="pre">Assigment</span></tt> <tt class="docutils literal"><span class="pre">initial_solution</span></tt>.</p>
<p>Now, we are ready to prepare the local search with our two <tt class="docutils literal"><span class="pre">LocalSearchOperator</span></tt>s combined.</p>
</div>
<div class="section" id="combining-the-two-localsearchoperators">
<h3>6.7.5.2. Combining the two <tt class="docutils literal"><span class="pre">LocalSearchOperator</span></tt>s</h3>
<p>Often, one <tt class="docutils literal"><span class="pre">LocalSearchOperator</span></tt> isn&#8217;t enough to define a good neighborhood. Finding a good definition
of a neighborhood is an art and is really difficult. One way to diversify a neighborhood is to combine several
basic <tt class="docutils literal"><span class="pre">LocalSearchOperator</span></tt>s. Here, we combine <tt class="docutils literal"><span class="pre">SwapIntervals</span></tt> and <tt class="docutils literal"><span class="pre">ShuffleIntervals</span></tt>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">LocalSearchOperator</span><span class="o">*&gt;</span> <span class="n">operators</span><span class="p">;</span>
<span class="n">LocalSearchOperator</span><span class="o">*</span> <span class="k">const</span> <span class="n">swap_operator</span> <span class="o">=</span>
          <span class="n">solver</span><span class="p">.</span><span class="n">RevAlloc</span><span class="p">(</span><span class="k">new</span> <span class="n">SwapIntervals</span><span class="p">(</span><span class="n">all_sequences</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span>
                                            <span class="n">all_sequences</span><span class="p">.</span><span class="n">size</span><span class="p">()));</span>
<span class="n">operators</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">swap_operator</span><span class="p">);</span>

<span class="n">LocalSearchOperator</span><span class="o">*</span> <span class="k">const</span> <span class="n">shuffle_operator</span> <span class="o">=</span>
        <span class="n">solver</span><span class="p">.</span><span class="n">RevAlloc</span><span class="p">(</span><span class="k">new</span> <span class="n">ShuffleIntervals</span><span class="p">(</span><span class="n">all_sequences</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span>
                                             <span class="n">all_sequences</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span>
                                             <span class="n">FLAGS_shuffle_length</span><span class="p">));</span>
<span class="n">operators</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">shuffle_operator</span><span class="p">);</span>

<span class="n">LocalSearchOperator</span><span class="o">*</span> <span class="k">const</span> <span class="n">ls_concat</span> <span class="o">=</span>
                       <span class="n">solver</span><span class="p">.</span><span class="n">ConcatenateOperators</span><span class="p">(</span><span class="n">operators</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">ConcatenateOperators()</span></tt> method takes an <tt class="docutils literal"><span class="pre">std::vector</span></tt> of <tt class="docutils literal"><span class="pre">LocalSearchOperator</span></tt> and a <tt class="docutils literal"><span class="pre">bool</span></tt> that
indicates if we want to restart the operators one after the other in the order given by this vector once a
solution has been found.</p>
<p>The rest of the code is similar to that in the file <tt class="file docutils literal"><span class="pre">jobshop_ls2.cc</span></tt>.</p>
</div>
<div class="section" id="results">
<h3>6.7.5.3. Results</h3>
<p>If we solve our problem instance (file <tt class="file docutils literal"><span class="pre">first_example_jssp.txt</span></tt>), we still get
the optimal solution. No surprise here. What about the <tt class="file docutils literal"><span class="pre">abz9</span></tt> instance?</p>
<p>With our default value of</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">time_limit_in_ms</span> <span class="pre">=</span> <span class="pre">0</span></tt>, thus no time limit;</li>
<li><tt class="docutils literal"><span class="pre">shuffle_length</span> <span class="pre">=</span> <span class="pre">4</span></tt>;</li>
<li><tt class="docutils literal"><span class="pre">initial_time_limit_in_ms</span> <span class="pre">=</span> <span class="pre">20000</span></tt>, thus a time of <tt class="docutils literal"><span class="pre">20</span></tt> seconds to find an initial solution with local search
and the <tt class="docutils literal"><span class="pre">ShuffleIntervals</span></tt> operator with a shuffle length of <tt class="docutils literal"><span class="pre">2</span></tt> and;</li>
<li><tt class="docutils literal"><span class="pre">solutions_nbr_tolerance</span> <span class="pre">=</span> <span class="pre">1</span></tt>,</li>
</ul>
<p>we are not able to improve our best solution so far!</p>
<p>As we said, local search is very sensitive to the initial solution chosen. In the next table, we start with different
initial solutions:</p>
<table border="1" class="docutils">
<colgroup>
<col width="17%" />
<col width="17%" />
<col width="17%" />
<col width="17%" />
<col width="17%" />
<col width="17%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Initial time limit</th>
<th class="head">Initial sol. obj.</th>
<th class="head">Time</th>
<th class="head">Value</th>
<th class="head">Candidates</th>
<th class="head">Solutions</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>1,000</td>
<td>1114</td>
<td>81,603</td>
<td>983</td>
<td>49745</td>
<td>35</td>
</tr>
<tr class="row-odd"><td>2,000</td>
<td>1103</td>
<td>103,139</td>
<td>936</td>
<td>70944</td>
<td>59</td>
</tr>
<tr class="row-even"><td>3,000</td>
<td>1093</td>
<td>104,572</td>
<td>931</td>
<td>70035</td>
<td>60</td>
</tr>
<tr class="row-odd"><td>4,000</td>
<td>1089</td>
<td>102,860</td>
<td>931</td>
<td>68359</td>
<td>60</td>
</tr>
<tr class="row-even"><td>5,000</td>
<td>1073</td>
<td>84,555</td>
<td>931</td>
<td>63949</td>
<td>60</td>
</tr>
<tr class="row-odd"><td>6,000</td>
<td>1057</td>
<td>42,235</td>
<td>1012</td>
<td>29957</td>
<td>32</td>
</tr>
<tr class="row-even"><td>7,000</td>
<td>1042</td>
<td>36,935</td>
<td>1012</td>
<td>26515</td>
<td>32</td>
</tr>
<tr class="row-odd"><td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr class="row-even"><td>&gt;= 13,000</td>
<td>1016</td>
<td>19,229</td>
<td>1016</td>
<td>13017</td>
<td>32</td>
</tr>
</tbody>
</table>
<p>The first column lists the times allowed to find the initial solution with the <tt class="docutils literal"><span class="pre">ShuffleIntervals</span></tt> operator (with its
shuffle length set to <tt class="docutils literal"><span class="pre">2</span></tt>) and the second column collects the objective values of this initial solution.
The more time given to
the first local search, the better the objective values. The next four columns are the same as before.</p>
<p>You might think that starting from a better solution would give better results but it is no necessarily the case. Our best
result, <tt class="docutils literal"><span class="pre">931</span></tt> is obtained when we start from solutions with an average objective value. When we start with better solutions,
like the one with an objective value of <tt class="docutils literal"><span class="pre">1016</span></tt>, we completely miss the <tt class="docutils literal"><span class="pre">931</span></tt> solution!</p>
<p>This <tt class="docutils literal"><span class="pre">931</span></tt> solution seems to be a local optimum for our local search and it seems we can not escape it. In the chapter
<a class="reference internal" href="../metaheuristics.html#chapter-metaheuristics"><em>Meta-heuristics: several previous problems</em></a>, we&#8217;ll see how some meta-heuristics escape this local minimum. For now, we turn our attention
to another preoccupation: if you read the <em>Candidates</em> column and compare it with the <em>Solutions</em> column, you can see
that our algorithm produces lots of candidates and very few solutions. This is normal. Remember that every time
a candidate (a neighbor) is produced, the CP solver takes the time to verify if this candidate is a feasible solution.
This is costly. In the next section, we&#8217;ll see a mechanism to shortcut this verification and command the solver to
disregard some candidates without the need for the solver to test them explicitly.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<table>
<tr>
<td width="60"><img src="../../_static/logo.png" width="50" height="50"  alt="" /></td>
<td><p class="library_name">Google <a href="http://code.google.com/p/or-tools/"><strong>or-tools</strong></a><br>open source library</p></td>
</tr>
</table>
<h1>User's Manual</h1>

  
   



<h3>Google search</h3>

<form method="get" action="http://www.google.com/search">

<div style="padding:-1px;width:15em;">
<table border="0" cellpadding="0">
<tr><td>
<input type="text"   name="q" size="25"
 maxlength="255" value="" />
<input type="submit" value="Go" /></td></tr>
<tr><td align="center" style="font-size:80%">
Search:
<select name="sitesearch" width="125" style="width: 125px">
<option value="http://or-tools.googlecode.com/svn/trunk/documentation/user_manual/" selected>user's manual</option>
<option value="http://or-tools.googlecode.com/svn/trunk/documentation/faq/">faq</option>
<option value="http://or-tools.googlecode.com/svn/trunk/documentation/reference_manual/or-tools/">reference manual</option>
<option value="http://or-tools.googlecode.com/svn/trunk/documentation/">All or-tools doc</option>
</select>
</td></tr>
</table>
</div>

</form>
</br>




  <h3>Welcome</h3>
  
  <ul>
  	<li><a href="../../index.html">Content and foreword</a></li>
  	<li><a href="http://or-tools.googlecode.com/svn/trunk/documentation/documentation_hub.html">Documentation's hub</a></li>
	<li><a href="http://code.google.com/p/or-tools/">The or-tools open source library</a></li></li>	
  </ul>
  
   
	


  <h3>Tutorial examples</h3>
  
  <ul>
	<li><a href="http://or-tools.googlecode.com/svn/trunk/documentation/documentation_hub.html#tutorial_C++">C++</a></li>
	<li><a href="http://or-tools.googlecode.com/svn/trunk/documentation/documentation_hub.html#tutorial_Python">Python</a></li>	
	<li><a href="http://or-tools.googlecode.com/svn/trunk/documentation/documentation_hub.html#tutorial_Java">Java</a></li>
	<li><a href="http://or-tools.googlecode.com/svn/trunk/documentation/documentation_hub.html#tutorial_Csharp">C#</a></li>
</ul>
  
   
	

  <h3>Current chapter</h3>
  <p class="topless"><a href="../LS.html"
                        title="previous chapter">6. Local search: the job-shop problem</a></p>
  <h3>Previous section</h3>
  <p class="topless"><a href="ls_operators.html"
                        title="previous chapter">6.6. Local Search Operators</a></p>
  <h3>Next section</h3>
  <p class="topless"><a href="ls_filtering.html"
                        title="next chapter">6.8. Filtering</a></p>
  <h3>Current section</a></h3>
  <ul>
<li><a class="reference internal" href="#">6.7. The jobshop problem: and now with local search!</a><ul>
<li><a class="reference internal" href="#localsearchoperators-the-real-thing">6.7.1. <tt class="docutils literal"><span class="pre">LocalSearchOperator</span></tt>s: the real thing!</a><ul>
<li><a class="reference internal" href="#deltas-and-deltadeltas">6.7.1.1. <tt class="docutils literal"><span class="pre">Delta</span></tt>s and <tt class="docutils literal"><span class="pre">DeltaDelta</span></tt>s</a></li>
<li><a class="reference internal" href="#makenextneighbor">6.7.1.2. <tt class="docutils literal"><span class="pre">MakeNextNeighbor()</span></tt></a></li>
<li><a class="reference internal" href="#incrementality">6.7.1.3. Incrementality</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-initial-solution">6.7.2. The initial solution</a></li>
<li><a class="reference internal" href="#exchanging-two-intervalvars-on-a-sequencevar">6.7.3. Exchanging two <tt class="docutils literal"><span class="pre">IntervalVar</span></tt>s on a <tt class="docutils literal"><span class="pre">SequenceVar</span></tt></a></li>
<li><a class="reference internal" href="#exchanging-an-arbitrary-number-of-contiguous-intervalvars-on-a-sequencevar">6.7.4. Exchanging an arbitrary number of contiguous <tt class="docutils literal"><span class="pre">IntervalVar</span></tt>s on a <tt class="docutils literal"><span class="pre">SequenceVar</span></tt></a></li>
<li><a class="reference internal" href="#can-we-do-better">6.7.5. Can we do better?</a><ul>
<li><a class="reference internal" href="#id2">6.7.5.1. The initial solution</a></li>
<li><a class="reference internal" href="#combining-the-two-localsearchoperators">6.7.5.2. Combining the two <tt class="docutils literal"><span class="pre">LocalSearchOperator</span></tt>s</a></li>
<li><a class="reference internal" href="#results">6.7.5.3. Results</a></li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="ls_filtering.html" title="6.8. Filtering"
             >next</a> |</li>
        <li class="right" >
          <a href="ls_operators.html" title="6.6. Local Search Operators"
             >previous</a> |</li>
        <li><a href="../../index.html">or-tools User&#39;s Manual</a> &raquo;</li>
          <li><a href="../LS.html" >6. Local search: the job-shop problem</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012-2013, Google.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>