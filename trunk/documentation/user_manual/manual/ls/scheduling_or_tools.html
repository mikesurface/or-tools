

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>6.3. Scheduling in or-tools &mdash; or-tools User&#39;s Manual</title>
    
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     'doc version 0.0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  false
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../../_static/logo.ico"/>
    <link rel="top" title="or-tools User&#39;s Manual" href="../../index.html" />
    <link rel="up" title="6. Local search: the job-shop problem" href="../LS.html" />
    <link rel="next" title="6.4. What is local search (LS)?" href="local_search.html" />
    <link rel="prev" title="6.2. An implementation of the disjunctive model" href="jobshop_implementation.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="local_search.html" title="6.4. What is local search (LS)?"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="jobshop_implementation.html" title="6.2. An implementation of the disjunctive model"
             accesskey="P">previous</a> |</li>
        <li><a href="../../index.html">or-tools User&#39;s Manual</a> &raquo;</li>
          <li><a href="../LS.html" accesskey="U">6. Local search: the job-shop problem</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="scheduling-in-or-tools">
<span id="scheduling-or-tools"></span><h1>6.3. Scheduling in <em>or-tools</em></h1>
<p>Scheduling problems deal with the allocation of resources and the sequencing of
tasks to produce goods and services. The job-shop problem is a good example of such problems.</p>
<p>Constraint programming has been proved successful in solving some scheduling problems
with dedicated variables and strategies [ref]. In <em>or-tools</em>, the CP solver offers some
variable types (<tt class="docutils literal"><span class="pre">IntervalVar</span></tt>s
and <tt class="docutils literal"><span class="pre">SequenceVar</span></tt>s) and roughly one specialized search strategy with some variants.
This part of the CP solver is not quite as developed as the rest of the library and
expect more to come. We summarize most of the
<em>or-tools</em> features dealing with scheduling in this section.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This part of the CP Solver is not quite settled yet. In case of doubt, check the code.</p>
</div>
<div class="section" id="variables">
<h2>6.3.1. Variables</h2>
<p>Two new types of variables are added to our arsenal: <tt class="docutils literal"><span class="pre">IntervalVar</span></tt>s model tasks and <tt class="docutils literal"><span class="pre">SequenceVar</span></tt>s
model sequences of tasks on one machine. Once you master these variables, you can use them in a variety of
different contexts but for the moment keep in mind this modelling association.</p>
<div class="section" id="intervalvars">
<h3>6.3.1.1. <tt class="docutils literal"><span class="pre">IntervalVar</span></tt>s</h3>
<p>An <tt class="docutils literal"><span class="pre">IntervalVar</span></tt> variable represents an <em>integer interval variable</em>. It is often used in scheduling to
represent a <em>task</em> because it has:</p>
<blockquote>
<div><ul class="simple">
<li>a <em>starting time</em>: <img class="math" src="../../_images/math/f37bba504894945c07a32f5496d74299a37aa51c.png" alt="s" style="vertical-align: 0px"/>;</li>
<li>a <em>duration</em>: <img class="math" src="../../_images/math/96ab646de7704969b91c76a214126b45f2b07b25.png" alt="d" style="vertical-align: 0px"/> and</li>
<li>an <em>ending time</em>: <img class="math" src="../../_images/math/a3a59bb1293ee3f6dec19de4019a7178874219ae.png" alt="e" style="vertical-align: 0px"/>.</li>
</ul>
</div></blockquote>
<p><img class="math" src="../../_images/math/f37bba504894945c07a32f5496d74299a37aa51c.png" alt="s" style="vertical-align: 0px"/>, <img class="math" src="../../_images/math/96ab646de7704969b91c76a214126b45f2b07b25.png" alt="d" style="vertical-align: 0px"/> and <img class="math" src="../../_images/math/a3a59bb1293ee3f6dec19de4019a7178874219ae.png" alt="e" style="vertical-align: 0px"/> are <tt class="docutils literal"><span class="pre">IntVar</span></tt> expressions based on the ranges these items can have. You can
retrieve these expressions with the following methods:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">IntExpr*</span> <span class="pre">StartExpr();</span></tt></li>
<li><tt class="docutils literal"><span class="pre">IntExpr*</span> <span class="pre">DurationExpr();</span></tt></li>
<li><tt class="docutils literal"><span class="pre">IntExpr*</span> <span class="pre">EndExpr();</span></tt></li>
</ul>
<p>If the corresponding <tt class="docutils literal"><span class="pre">IntervalVar</span></tt> variable is <em>unperformed</em> (see next
sub-section), you cannot use these methods. Well, if you do, nothing bad will happen but you will get gibberish
as the <tt class="docutils literal"><span class="pre">IntervalVar</span></tt> is no longer updated. These methods have corresponding &#8220;safe&#8221; versions if you need them.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>Don&#8217;t use</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">IntExpr*</span> <span class="pre">StartExpr();</span></tt></li>
<li><tt class="docutils literal"><span class="pre">IntExpr*</span> <span class="pre">DurationExpr();</span></tt></li>
<li><tt class="docutils literal"><span class="pre">IntExpr*</span> <span class="pre">EndExpr();</span></tt></li>
</ul>
<p class="last">if the corresponding <tt class="docutils literal"><span class="pre">IntervalVar</span></tt> variable is <em>unperformed</em>!</p>
</div>
<p>The <tt class="docutils literal"><span class="pre">IntervalVar</span></tt> can be virtually conceptualized<a class="footnote-reference" href="#intervalvar-virtually-conceptualized" id="id1">[1]</a> as
in the next figure:</p>
<table class="docutils footnote" frame="void" id="intervalvar-virtually-conceptualized" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>The implementation optimizes different cases and
thus doesn&#8217;t necessarily correspond to the figure. Read on.</td></tr>
</tbody>
</table>
<img alt="../../_images/intervalvar.png" class="align-center" src="../../_images/intervalvar.png" style="width: 700px;" />
<p>and you have the following setters and getters:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">virtual</span> <span class="pre">int64</span> <span class="pre">StartMin()</span> <span class="pre">const</span> <span class="pre">=</span> <span class="pre">0;</span></tt></li>
<li><tt class="docutils literal"><span class="pre">virtual</span> <span class="pre">int64</span> <span class="pre">StartMax()</span> <span class="pre">const</span> <span class="pre">=</span> <span class="pre">0;</span></tt></li>
<li><tt class="docutils literal"><span class="pre">virtual</span> <span class="pre">void</span> <span class="pre">SetStartMin(int64</span> <span class="pre">m)</span> <span class="pre">=</span> <span class="pre">0;</span></tt></li>
<li><tt class="docutils literal"><span class="pre">virtual</span> <span class="pre">void</span> <span class="pre">SetStartMax(int64</span> <span class="pre">m)</span> <span class="pre">=</span> <span class="pre">0;</span></tt></li>
<li><tt class="docutils literal"><span class="pre">virtual</span> <span class="pre">void</span> <span class="pre">SetStartRange(int64</span> <span class="pre">mi,</span> <span class="pre">int64</span> <span class="pre">ma)</span> <span class="pre">=</span> <span class="pre">0;</span></tt></li>
<li><tt class="docutils literal"><span class="pre">virtual</span> <span class="pre">int64</span> <span class="pre">DurationMin()</span> <span class="pre">const</span> <span class="pre">=</span> <span class="pre">0;</span></tt></li>
<li><tt class="docutils literal"><span class="pre">virtual</span> <span class="pre">int64</span> <span class="pre">DurationMax()</span> <span class="pre">const</span> <span class="pre">=</span> <span class="pre">0;</span></tt></li>
<li><tt class="docutils literal"><span class="pre">virtual</span> <span class="pre">void</span> <span class="pre">SetDurationMin(int64</span> <span class="pre">m)</span> <span class="pre">=</span> <span class="pre">0;</span></tt></li>
<li><tt class="docutils literal"><span class="pre">virtual</span> <span class="pre">void</span> <span class="pre">SetDurationMax(int64</span> <span class="pre">m)</span> <span class="pre">=</span> <span class="pre">0;</span></tt></li>
<li><tt class="docutils literal"><span class="pre">virtual</span> <span class="pre">void</span> <span class="pre">SetDurationRange(int64</span> <span class="pre">mi,</span> <span class="pre">int64</span> <span class="pre">ma)</span> <span class="pre">=</span> <span class="pre">0;</span></tt></li>
<li><tt class="docutils literal"><span class="pre">virtual</span> <span class="pre">int64</span> <span class="pre">EndMin()</span> <span class="pre">const</span> <span class="pre">=</span> <span class="pre">0;</span></tt></li>
<li><tt class="docutils literal"><span class="pre">virtual</span> <span class="pre">int64</span> <span class="pre">EndMax</span> <span class="pre">()</span> <span class="pre">const</span> <span class="pre">=</span> <span class="pre">0;</span></tt></li>
<li><tt class="docutils literal"><span class="pre">virtual</span> <span class="pre">void</span> <span class="pre">SetEndMin</span> <span class="pre">(int64</span> <span class="pre">m)</span> <span class="pre">=</span> <span class="pre">0;</span></tt></li>
<li><tt class="docutils literal"><span class="pre">virtual</span> <span class="pre">void</span> <span class="pre">SetEndMax</span> <span class="pre">(int64</span> <span class="pre">m)</span> <span class="pre">=</span> <span class="pre">0;</span></tt></li>
<li><tt class="docutils literal"><span class="pre">virtual</span> <span class="pre">void</span> <span class="pre">SetEndRange</span> <span class="pre">(int64</span> <span class="pre">mi,</span> <span class="pre">int64</span> <span class="pre">ma)</span> <span class="pre">=</span> <span class="pre">0;</span></tt></li>
</ul>
<p>As usual, the <tt class="docutils literal"><span class="pre">IntervalVar</span></tt> class is an abstract base class and several specialized sub-classes exist. For instance, we saw
the <tt class="docutils literal"><span class="pre">FixedDurationPerformedIntervalVar</span></tt> class in the previous section (created with
<tt class="docutils literal"><span class="pre">MakeFixedDurationIntervalVar()</span></tt>).</p>
<p>To create <tt class="docutils literal"><span class="pre">IntervalVar</span></tt> variables, use the factory methods provided by the solver. For instance:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">IntervalVar</span><span class="o">*</span> <span class="n">Solver</span><span class="o">:</span><span class="n">MakeFixedInterval</span><span class="p">(</span><span class="n">int64</span> <span class="n">start</span><span class="p">,</span>
                                      <span class="n">int64</span> <span class="n">duration</span><span class="p">,</span>
                                      <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">);</span>

<span class="n">IntervalVar</span><span class="o">*</span> <span class="n">Solver</span><span class="o">::</span><span class="n">MakeFixedDurationIntervalVar</span><span class="p">(</span><span class="n">int64</span> <span class="n">start_min</span><span class="p">,</span>
                                          <span class="n">int64</span> <span class="n">start_max</span><span class="p">,</span>
                                          <span class="n">int64</span> <span class="n">duration</span><span class="p">,</span>
                                          <span class="kt">bool</span> <span class="n">optional</span><span class="p">,</span>
                                          <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">Solver</span><span class="o">::</span><span class="n">MakeFixedDurationIntervalVarArray</span><span class="p">(</span><span class="kt">int</span> <span class="n">count</span><span class="p">,</span>
                                  <span class="n">int64</span> <span class="n">start_min</span><span class="p">,</span>
                                  <span class="n">int64</span> <span class="n">start_max</span><span class="p">,</span>
                                  <span class="n">int64</span> <span class="n">duration</span><span class="p">,</span>
                                  <span class="kt">bool</span> <span class="n">optional</span><span class="p">,</span>
                                  <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span>
                                  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">IntervalVar</span><span class="o">*&gt;*</span> <span class="n">array</span><span class="p">);</span>
</pre></div>
</div>
<p>The first factory method creates a <tt class="docutils literal"><span class="pre">FixedInterval</span></tt>: its starting time, duration and ending time are all fixed.
<tt class="docutils literal"><span class="pre">MakeFixedDurationIntervalVar()</span></tt> and <tt class="docutils literal"><span class="pre">MakeFixedDurationIntervalVarArray()</span></tt> create respectively an <tt class="docutils literal"><span class="pre">IntervalVar</span></tt> and
an <tt class="docutils literal"><span class="pre">std::vector&lt;IntervalVar*&gt;</span></tt> with <tt class="docutils literal"><span class="pre">count</span></tt> elements. The <tt class="docutils literal"><span class="pre">start_min</span></tt> and <tt class="docutils literal"><span class="pre">start_max</span></tt> parameters give a range
for the <tt class="docutils literal"><span class="pre">IntervalVar</span></tt>s to start. The duration is fixed and equal to <tt class="docutils literal"><span class="pre">duration</span></tt> for all the variables.
The <tt class="docutils literal"><span class="pre">optional</span></tt> <tt class="docutils literal"><span class="pre">bool</span></tt> indicates
if the variables can be <em>unperformed</em> or not. When an array is created, the name of its elements are simply <tt class="docutils literal"><span class="pre">name</span></tt> with
their position in the array (<img class="math" src="../../_images/math/bc1f9d9bf8a1b606a4188b5ce9a2af1809e27a89.png" alt="0" style="vertical-align: 0px"/>, <img class="math" src="../../_images/math/dce34f4dfb2406144304ad0d6106c5382ddd1446.png" alt="1" style="vertical-align: -1px"/>, ..., <img class="math" src="../../_images/math/ae324ed5421b12732e7b9b153193add0de412ea3.png" alt="count - 1" style="vertical-align: -1px"/>) appended, like so:</p>
<div class="highlight-text"><div class="highlight"><pre>name0, name1, name2, ... .
</pre></div>
</div>
<p>Several other factory methods are defined in the file <tt class="file docutils literal"><span class="pre">interval.cc</span></tt>.</p>
</div>
<div class="section" id="variables-that-perform-or-not">
<h3>6.3.1.2. Variables that perform... or not</h3>
<p>An important aspect of <tt class="docutils literal"><span class="pre">IntervalVar</span></tt>s is optionality. An <tt class="docutils literal"><span class="pre">IntervalVar</span></tt> can be <em>performed</em> or not. If
<em>unperformed</em>, then it simply does not exist (and its characteristics are meaningless).
An <tt class="docutils literal"><span class="pre">IntervalVar</span></tt> is automatically marked
as <em>unperformed</em> when it is not consistent anymore (starting time greater
than ending time, duration &lt; 0...). You can get and set if an <tt class="docutils literal"><span class="pre">IntervalVar</span></tt> must, may or cannot be performed
with the following methods:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">virtual</span> <span class="kt">bool</span> <span class="n">MustBePerformed</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">virtual</span> <span class="kt">bool</span> <span class="n">MayBePerformed</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">bool</span> <span class="nf">CannotBePerformed</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="o">!</span><span class="n">MayBePerformed</span><span class="p">();</span> <span class="p">}</span>
<span class="kt">bool</span> <span class="n">IsPerformedBound</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">MustBePerformed</span><span class="p">()</span> <span class="o">==</span> <span class="n">MayBePerformed</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">virtual</span> <span class="kt">void</span> <span class="n">SetPerformed</span><span class="p">(</span><span class="kt">bool</span> <span class="n">val</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>As for the starting time, the ending time and the duration of an <tt class="docutils literal"><span class="pre">IntervalVar</span></tt> variable, its &#8220;performedness&#8221; is
encapsulated in an <tt class="docutils literal"><span class="pre">IntExpr</span></tt> you can query with:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">IntExpr</span><span class="o">*</span> <span class="nf">PerformedExpr</span><span class="p">();</span>
</pre></div>
</div>
<p>The corresponding <tt class="docutils literal"><span class="pre">IntExpr</span></tt> acts like a <img class="math" src="../../_images/math/016f10daec11b69c18d2bf68896ecd98339fe426.png" alt="0-1" style="vertical-align: -1px"/> <tt class="docutils literal"><span class="pre">IntervalVar</span></tt><a class="footnote-reference" href="#performed-intexpr-is-intervalvar" id="id2">[2]</a>.
If its minimum value is <img class="math" src="../../_images/math/dce34f4dfb2406144304ad0d6106c5382ddd1446.png" alt="1" style="vertical-align: -1px"/>, the corresponding <tt class="docutils literal"><span class="pre">IntervalVar</span></tt> variables must be performed. If its
maximal value is <img class="math" src="../../_images/math/bc1f9d9bf8a1b606a4188b5ce9a2af1809e27a89.png" alt="0" style="vertical-align: 0px"/>, the corresponding <tt class="docutils literal"><span class="pre">IntervalVar</span></tt> is unperformed and if <img class="math" src="../../_images/math/ce4b0697810792acb7da44ab5ef5c62c45917f4f.png" alt="\text{min} = 0" style="vertical-align: -1px"/>
and <img class="math" src="../../_images/math/c3c8f330093ec775717da39692935b7d17af3d62.png" alt="\text{max} = 1" style="vertical-align: -1px"/>, the corresponding <tt class="docutils literal"><span class="pre">IntervalVar</span></tt> might be performed.</p>
<table class="docutils footnote" frame="void" id="performed-intexpr-is-intervalvar" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>Actually, it is an <tt class="docutils literal"><span class="pre">IntervalVar</span></tt>!</td></tr>
</tbody>
</table>
<p>The use of an <tt class="docutils literal"><span class="pre">IntExpr</span></tt> allows expressiveness and the use of sophisticated constraints.</p>
<p>As we have seen, if the <tt class="docutils literal"><span class="pre">IntervalVar</span></tt> is <em>unperformed</em>, we cannot use <tt class="docutils literal"><span class="pre">StartExpr()</span></tt>, <tt class="docutils literal"><span class="pre">DurationExpr()</span></tt>
and <tt class="docutils literal"><span class="pre">EndExpr()</span></tt>. You can however call their <em>safe</em> versions:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">IntExpr*</span> <span class="pre">SafeStartExpr(int64</span> <span class="pre">unperformed_value);</span></tt></li>
<li><tt class="docutils literal"><span class="pre">IntExpr*</span> <span class="pre">SafeDurationExpr(int64</span> <span class="pre">unperformed_value);</span></tt></li>
<li><tt class="docutils literal"><span class="pre">IntExpr*</span> <span class="pre">SafeEndExpr(int64</span> <span class="pre">unperformed_value)</span></tt></li>
</ul>
<p>If the variable is performed, these expressions will return their exact values, otherwise they will return
&#8220;obvious&#8221; values (see the file <tt class="file docutils literal"><span class="pre">sched_expr.cc</span></tt> for more details). For instance:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">IntExpr</span> <span class="o">*</span> <span class="n">start_exp</span> <span class="o">=</span> <span class="n">interval_var</span><span class="o">-&gt;</span><span class="n">SafeStartExpr</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="n">IntVar</span> <span class="o">*</span> <span class="n">start_var</span> <span class="o">=</span> <span class="n">start_exp</span><span class="o">-&gt;</span><span class="n">Var</span><span class="p">();</span>
<span class="n">LG</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Minimum start value is &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">start_var</span><span class="o">-&gt;</span><span class="n">Min</span><span class="p">();</span>
</pre></div>
</div>
<p>will give you the exact minimal starting value if the variable is performed, the minimum between its minimal value
and <tt class="docutils literal"><span class="pre">-1</span></tt> if the variable may be performed and <tt class="docutils literal"><span class="pre">-1</span></tt> if the variable is unperformed.</p>
</div>
<div class="section" id="sequencevars">
<h3>6.3.1.3. <tt class="docutils literal"><span class="pre">SequenceVar</span></tt>s</h3>
<p>A <tt class="docutils literal"><span class="pre">SequenceVar</span></tt> variable is a variable which domain is a set of possible
orderings of <tt class="docutils literal"><span class="pre">IntervalVar</span></tt> variables. Because it allows the ordering of <tt class="docutils literal"><span class="pre">IntervalVar</span></tt> (tasks),
it is often used in scheduling. And for once it is <strong>not</strong> an abstract class! This is because these variables
are among the less refined variables in <em>or-tools</em>. They also have the least number of methods.</p>
<p>Basically, this class contains an array of <tt class="docutils literal"><span class="pre">IntervalVar</span></tt>s and a precedence matrix indicating how the <tt class="docutils literal"><span class="pre">IntervalVar</span></tt>s
are ranked. You can conceptualize<a class="footnote-reference" href="#sequencevar-virtually-conceptualized" id="id3">[3]</a> this class as depicted in the following figure:</p>
<img alt="../../_images/sequencevar.png" class="align-center" src="../../_images/sequencevar.png" style="width: 700px;" />
<p>where the precedence matrix <tt class="docutils literal"><span class="pre">mat</span></tt> is such that <tt class="docutils literal"><span class="pre">mat(i,j)</span> <span class="pre">=</span> <span class="pre">1</span></tt> if <tt class="docutils literal"><span class="pre">i</span></tt> is ranked before <tt class="docutils literal"><span class="pre">j</span></tt>.</p>
<p>The <tt class="docutils literal"><span class="pre">IntervalVar</span></tt> are often given by their indices in the array of <tt class="docutils literal"><span class="pre">IntervalVar</span></tt>s.</p>
<table class="docutils footnote" frame="void" id="sequencevar-virtually-conceptualized" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td>This looks very much like the actual implementation. The array is a
<tt class="docutils literal"><span class="pre">scoped_array&lt;IntervalVar*&gt;</span></tt> and the precedence matrix is given by a <tt class="docutils literal"><span class="pre">scoped_ptr&lt;RevBitMatrix&gt;</span></tt>. The actual class
contains some more data structures to facilitate and optimize the propagation.</td></tr>
</tbody>
</table>
</div>
<div class="section" id="ranked-intervalvars">
<h3>6.3.1.4. Ranked <tt class="docutils literal"><span class="pre">IntervalVar</span></tt>s</h3>
<p><em>Ranked</em> <tt class="docutils literal"><span class="pre">IntervalVar</span></tt>s are exactly that: already ranked variables in the sequence. <tt class="docutils literal"><span class="pre">IntervalVar</span></tt>s can be ranked
at the beginning or at the end of the sequence in the <tt class="docutils literal"><span class="pre">SequenceVar</span></tt> variable. <em>unperformed</em> <tt class="docutils literal"><span class="pre">IntervalVar</span></tt> can not
be ranked<a class="footnote-reference" href="#unranked-and-three-state" id="id4">[4]</a>. The next figure illustrates this:</p>
<img alt="../../_images/sequencevar_ranked.png" class="align-center" src="../../_images/sequencevar_ranked.png" style="width: 700px;" />
<p><tt class="docutils literal"><span class="pre">IntervalVar</span></tt> variables <tt class="docutils literal"><span class="pre">1</span></tt> and <tt class="docutils literal"><span class="pre">2</span></tt> are ranked (and <em>performed</em>) while <tt class="docutils literal"><span class="pre">IntervalVar</span></tt> variable <tt class="docutils literal"><span class="pre">0</span></tt>
may be <em>performed</em> but
is not <em>performed</em> yet and <tt class="docutils literal"><span class="pre">IntervalVar</span></tt> variable <tt class="docutils literal"><span class="pre">3</span></tt> is <em>unperformed</em> and thus doesn&#8217;t exist anymore.</p>
<p>To rank the <tt class="docutils literal"><span class="pre">IntervalVar</span></tt> variables, we say that we <em>rank</em> them <em>first</em> or <em>last</em>. <em>First</em> and <em>last</em>
<tt class="docutils literal"><span class="pre">IntervalVar</span></tt> variables must be understood with respect to the unranked variables:</p>
<img alt="../../_images/sequencevar_ranked_first_last.png" class="align-center" src="../../_images/sequencevar_ranked_first_last.png" style="width: 1100px;" />
<ul class="simple">
<li>to <em>rank first</em> an <tt class="docutils literal"><span class="pre">IntervalVar</span></tt> variable means that this variable will be ranked before <strong>all unranked</strong>
variables and</li>
<li>to <em>rank last</em> an <tt class="docutils literal"><span class="pre">IntervalVar</span></tt> variable means that this variable will be ranked after <strong>all unranked</strong>
variables.</li>
</ul>
<table class="docutils footnote" frame="void" id="unranked-and-three-state" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[4]</a></td><td>Thus, <em>unranked</em> variables are variables that <em>may</em> be <em>performed</em>. Yeah, three-states
situations that evolves with time are nastier than a good old Manichean one.</td></tr>
</tbody>
</table>
</div>
<div class="section" id="public-methods">
<h3>6.3.1.5. Public methods</h3>
<p>All the following methods are updated with the current values of the <tt class="docutils literal"><span class="pre">SequenceVar</span></tt>. <em>unperformed</em> variables - unless
explicitly stated in one of the arguments - are never considered.</p>
<p>First, you have the following <strong>getters</strong>:</p>
<ul>
<li><dl class="first docutils">
<dt><tt class="docutils literal"><span class="pre">void</span> <span class="pre">DurationRange(int64*</span> <span class="pre">const</span> <span class="pre">dmin,</span> <span class="pre">int64*</span> <span class="pre">const</span> <span class="pre">dmax)</span> <span class="pre">const</span></tt>:</dt>
<dd><p class="first">Returns the minimum and maximum duration of the <tt class="docutils literal"><span class="pre">IntervalVar</span></tt> variables:</p>
<ul class="last simple">
<li><tt class="docutils literal"><span class="pre">dmin</span></tt> is the total (minimum) duration of mandatory variables (those that <strong>must</strong> be performed) and</li>
<li><tt class="docutils literal"><span class="pre">dmax</span></tt> is the total (maximum) duration of variables that <strong>may</strong> be performed.</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><tt class="docutils literal"><span class="pre">void</span> <span class="pre">HorizonRange(int64*</span> <span class="pre">const</span> <span class="pre">hmin,</span> <span class="pre">int64*</span> <span class="pre">const</span> <span class="pre">hmax)</span> <span class="pre">const</span></tt>:</dt>
<dd><p class="first last">Returns the minimum starting time <tt class="docutils literal"><span class="pre">hmin</span></tt> and the maximum ending time <tt class="docutils literal"><span class="pre">hmax</span></tt> of <strong>all</strong>
<tt class="docutils literal"><span class="pre">IntervalVar</span></tt> variables that <strong>may</strong> be performed.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><tt class="docutils literal"><span class="pre">void</span> <span class="pre">ActiveHorizonRange(int64*</span> <span class="pre">const</span> <span class="pre">hmin,</span> <span class="pre">int64*</span> <span class="pre">const</span> <span class="pre">hmax)</span> <span class="pre">const</span></tt>:</dt>
<dd><p class="first last">Same as above but for all <em>unranked</em> <tt class="docutils literal"><span class="pre">IntervalVar</span></tt> variables.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><tt class="docutils literal"><span class="pre">int</span> <span class="pre">Ranked()</span> <span class="pre">const</span></tt>:</dt>
<dd><p class="first last">Returns the number of <tt class="docutils literal"><span class="pre">IntervalVar</span></tt> variables already ranked.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><tt class="docutils literal"><span class="pre">int</span> <span class="pre">NotRanked()</span> <span class="pre">const</span></tt>:</dt>
<dd><p class="first last">Returns the number of not-unperformed <tt class="docutils literal"><span class="pre">IntervalVar</span></tt> variables that may be
performed and that are not ranked yet.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><tt class="docutils literal"><span class="pre">void</span> <span class="pre">ComputeStatistics(...)</span></tt>:</dt>
<dd><p class="first">Computes the following statistics:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="n">ComputeStatistics</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="k">const</span> <span class="n">ranked</span><span class="p">,</span>
                       <span class="kt">int</span><span class="o">*</span> <span class="k">const</span> <span class="n">not_ranked</span><span class="p">,</span>
                       <span class="kt">int</span><span class="o">*</span> <span class="k">const</span> <span class="n">unperformed</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p class="last"><tt class="docutils literal"><span class="pre">ranked</span> <span class="pre">+</span> <span class="pre">not_ranked</span> <span class="pre">+</span> <span class="pre">unperformed</span></tt> is equal to <tt class="docutils literal"><span class="pre">size()</span></tt>.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><tt class="docutils literal"><span class="pre">IntervalVar*</span> <span class="pre">Interval(int</span> <span class="pre">index)</span> <span class="pre">const</span></tt>:</dt>
<dd><p class="first last">Returns the index <sup>th</sup> <tt class="docutils literal"><span class="pre">IntervalVar</span></tt> from the array of <tt class="docutils literal"><span class="pre">IntervalVar</span></tt>s.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><tt class="docutils literal"><span class="pre">IntVar*</span> <span class="pre">Next(int</span> <span class="pre">index)</span> <span class="pre">const</span></tt>:</dt>
<dd><p class="first">To each <tt class="docutils literal"><span class="pre">IntervalVar</span></tt> corresponds an associated <tt class="docutils literal"><span class="pre">IntVar</span></tt> that represents the &#8220;ranking&#8221; of the <tt class="docutils literal"><span class="pre">IntervalVar</span></tt> in
the ranked sequence. The <tt class="docutils literal"><span class="pre">Next()</span></tt> method returns this <tt class="docutils literal"><span class="pre">IntVar</span></tt> variable for the index <sup>th</sup> <tt class="docutils literal"><span class="pre">IntervalVar</span></tt>
in the array of <tt class="docutils literal"><span class="pre">IntervalVar</span></tt>s.</p>
<p>For instance, if you want to know what is the next <tt class="docutils literal"><span class="pre">IntervalVar</span></tt> after the 3 <sup>rd</sup> <tt class="docutils literal"><span class="pre">IntervalVar</span></tt>
in the sequence, use the following code:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">SequenceVar</span> <span class="o">*</span> <span class="n">seq</span> <span class="o">=</span> <span class="p">...;</span>
<span class="p">...</span>
<span class="n">IntVar</span> <span class="o">*</span> <span class="n">next_var</span> <span class="o">=</span> <span class="n">seq</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">next_var</span><span class="o">-&gt;</span><span class="n">Bound</span><span class="p">())</span> <span class="p">{</span>  <span class="c1">//  OK, ranked</span>
  <span class="n">LG</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;The next IntervalVar after the 3rd IntervalVar in &quot;</span> <span class="o">&lt;&lt;</span>
                    <span class="s">&quot;the sequence is &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">next_var</span><span class="o">-&gt;</span><span class="n">Value</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="last">As you can see, there is a difference of one between the returned value and the actual index of the <tt class="docutils literal"><span class="pre">IntervalVar</span></tt>
in the array of <tt class="docutils literal"><span class="pre">IntervalVar</span></tt>s variables.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><tt class="docutils literal"><span class="pre">int</span> <span class="pre">size()</span> <span class="pre">const</span></tt>:</dt>
<dd><p class="first last">Returns the number of <tt class="docutils literal"><span class="pre">IntervalVar</span></tt> variables.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><tt class="docutils literal"><span class="pre">void</span> <span class="pre">FillSequence(...)</span></tt>:</dt>
<dd><p class="first">a getter filling the three <tt class="docutils literal"><span class="pre">std::vector&lt;int&gt;</span></tt> of first ranked, last ranked and unperformed variables:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="n">FillSequence</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;*</span> <span class="k">const</span> <span class="n">rank_first</span><span class="p">,</span>
                  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;*</span> <span class="k">const</span> <span class="n">rank_lasts</span><span class="p">,</span>
                  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;*</span> <span class="k">const</span> <span class="n">unperformed</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p class="last">The method first clears the three <tt class="docutils literal"><span class="pre">std::vector</span></tt>s and fills them with the
<tt class="docutils literal"><span class="pre">IntervalVar</span></tt> number in the sequence order of ranked variables. If all variables are ranked,
<tt class="docutils literal"><span class="pre">rank_first</span></tt> will contain all variables and <tt class="docutils literal"><span class="pre">rank_last</span></tt> will contain none.
<tt class="docutils literal"><span class="pre">unperformed</span></tt> will contain all the <em>unperformed</em> <tt class="docutils literal"><span class="pre">IntervalVar</span></tt> variables.
<tt class="docutils literal"><span class="pre">rank_first[0]</span></tt> corresponds to the first <tt class="docutils literal"><span class="pre">IntervalVar</span></tt> of the sequence while
<tt class="docutils literal"><span class="pre">rank_last[0]</span></tt> corresponds to the last <tt class="docutils literal"><span class="pre">IntervalVar</span></tt> variable of the sequence, i.e. the <tt class="docutils literal"><span class="pre">IntervalVar</span></tt> variables
ranked last are given in the opposite order.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><tt class="docutils literal"><span class="pre">ComputePossibleFirstsAndLasts(...)</span></tt>:</dt>
<dd><p class="first">a getter giving the possibilities among <em>unranked</em> <tt class="docutils literal"><span class="pre">IntervalVar</span></tt> variables:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">ComputePossibleFirstsAndLasts</span><span class="p">(</span>
                       <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;*</span> <span class="k">const</span> <span class="n">possible_firsts</span><span class="p">,</span>
                       <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;*</span> <span class="k">const</span> <span class="n">possible_lasts</span><span class="p">);</span>
</pre></div>
</div>
<p class="last">This method computes the set of indices of <tt class="docutils literal"><span class="pre">IntervalVar</span></tt> variables that can be
ranked first or last in the set of unranked activities.</p>
</dd>
</dl>
</li>
</ul>
<p>Second, you have the following <strong>setters</strong>:</p>
<ul>
<li><dl class="first docutils">
<dt><tt class="docutils literal"><span class="pre">void</span> <span class="pre">RankFirst(int</span> <span class="pre">index)</span></tt>:</dt>
<dd><p class="first last">Ranks the index <sup>th</sup> <tt class="docutils literal"><span class="pre">IntervalVar</span></tt> variable in front of all unranked <tt class="docutils literal"><span class="pre">IntervalVar</span></tt> variables.
After the call of this method, the <tt class="docutils literal"><span class="pre">IntervalVar</span></tt> variable is considered <em>performed</em>.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><tt class="docutils literal"><span class="pre">void</span> <span class="pre">RankNotFirst(int</span> <span class="pre">index)</span></tt>:</dt>
<dd><p class="first last">Indicates that the index <sup>th</sup> <tt class="docutils literal"><span class="pre">IntervalVar</span></tt> variable will not be ranked first
among all currently unranked <tt class="docutils literal"><span class="pre">IntervalVar</span></tt> variables.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><tt class="docutils literal"><span class="pre">void</span> <span class="pre">RankLast(int</span> <span class="pre">index)</span></tt>:</dt>
<dd><p class="first last">Ranks the index <sup>th</sup> <tt class="docutils literal"><span class="pre">IntervalVar</span></tt> variable first among all unranked <tt class="docutils literal"><span class="pre">IntervalVar</span></tt>
variables. After the call of this method, the <tt class="docutils literal"><span class="pre">IntervalVar</span></tt> variable is considered <em>performed</em>.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><tt class="docutils literal"><span class="pre">void</span> <span class="pre">RankNotLast(int</span> <span class="pre">index)</span></tt>:</dt>
<dd><p class="first last">Indicates that the index <sup>th</sup> <tt class="docutils literal"><span class="pre">IntervalVar</span></tt> variable will not be ranked first
among all currently unranked <tt class="docutils literal"><span class="pre">IntervalVar</span></tt> variables.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><tt class="docutils literal"><span class="pre">void</span> <span class="pre">RankSequence(...)</span></tt>:</dt>
<dd><p class="first">a setter acting on three <tt class="docutils literal"><span class="pre">std::vector&lt;int&gt;</span></tt> of first, last and unperformed variables:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">RankSequence</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">rank_firsts</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">rank_lasts</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">unperformed</span><span class="p">);</span>
</pre></div>
</div>
<p class="last">Ranks the <tt class="docutils literal"><span class="pre">IntervalVar</span></tt>s in the given order.
Again, the <tt class="docutils literal"><span class="pre">rank_firsts</span></tt> <tt class="docutils literal"><span class="pre">std::vector&lt;int&gt;</span></tt> gives the <tt class="docutils literal"><span class="pre">IntervalVar</span></tt>s in order (<tt class="docutils literal"><span class="pre">rank_firsts[0]</span></tt>
if the first ranked <tt class="docutils literal"><span class="pre">IntervalVar</span></tt> and so on) and the <tt class="docutils literal"><span class="pre">rank_lasts</span></tt> <tt class="docutils literal"><span class="pre">std::vector&lt;int&gt;</span></tt> gives the
<tt class="docutils literal"><span class="pre">IntervalVar</span></tt> in the opposite order (<tt class="docutils literal"><span class="pre">rank_lasts[0]</span></tt> is the last <tt class="docutils literal"><span class="pre">IntervalVar</span></tt> and so on).
All <tt class="docutils literal"><span class="pre">IntervalVar</span></tt> variables in the <tt class="docutils literal"><span class="pre">unperformed</span></tt> <tt class="docutils literal"><span class="pre">std::vector&lt;int&gt;</span></tt> will be marked as such and all
<tt class="docutils literal"><span class="pre">IntervalVar</span></tt> variables in the <tt class="docutils literal"><span class="pre">rank_firsts</span></tt> and <tt class="docutils literal"><span class="pre">rank_lasts</span></tt> <tt class="docutils literal"><span class="pre">std::vector&lt;int&gt;</span></tt> will be marked
as <em>performed</em>.</p>
</dd>
</dl>
</li>
</ul>
</div>
</div>
<div class="section" id="constraints-on-intervalvars">
<span id="scheduling-constraints"></span><h2>6.3.2. Constraints on <tt class="docutils literal"><span class="pre">IntervalVar</span></tt>s</h2>
<p>Most of the common constraints on <tt class="docutils literal"><span class="pre">IntervalVar</span></tt>s are implemented in the library.</p>
<div class="section" id="intervalunaryrelation-constraints">
<h3>6.3.2.1. <tt class="docutils literal"><span class="pre">IntervalUnaryRelation</span></tt> constraints</h3>
<p>You can specify a temporal relation between an <tt class="docutils literal"><span class="pre">IntervalVar</span></tt> <tt class="docutils literal"><span class="pre">t</span></tt> and an integer <tt class="docutils literal"><span class="pre">d</span></tt>:</p>
<blockquote>
<div><ul class="simple">
<li><tt class="docutils literal"><span class="pre">ENDS_AFTER</span></tt>: <tt class="docutils literal"><span class="pre">t</span></tt> ends after <tt class="docutils literal"><span class="pre">d</span></tt>, i.e. <tt class="docutils literal"><span class="pre">End(t)</span> <span class="pre">&gt;=</span> <span class="pre">d</span></tt>;</li>
<li><tt class="docutils literal"><span class="pre">ENDS_AT</span></tt>: <tt class="docutils literal"><span class="pre">t</span></tt> ends at <tt class="docutils literal"><span class="pre">d</span></tt>, i.e. <tt class="docutils literal"><span class="pre">End(t)</span> <span class="pre">==</span> <span class="pre">d</span></tt>;</li>
<li><tt class="docutils literal"><span class="pre">ENDS_BEFORE</span></tt>: <tt class="docutils literal"><span class="pre">t</span></tt> ends before <tt class="docutils literal"><span class="pre">d</span></tt>, i.e. <tt class="docutils literal"><span class="pre">End(t)</span> <span class="pre">&lt;=</span> <span class="pre">d</span></tt>;</li>
<li><tt class="docutils literal"><span class="pre">STARTS_AFTER</span></tt>: <tt class="docutils literal"><span class="pre">t</span></tt> starts after <tt class="docutils literal"><span class="pre">d</span></tt>, i.e. <tt class="docutils literal"><span class="pre">Start(t)</span> <span class="pre">&gt;=</span> <span class="pre">d</span></tt>;</li>
<li><tt class="docutils literal"><span class="pre">STARTS_AT</span></tt>: <tt class="docutils literal"><span class="pre">t</span></tt> starts at <tt class="docutils literal"><span class="pre">d</span></tt>, i.e. <tt class="docutils literal"><span class="pre">Start(t)</span> <span class="pre">==</span> <span class="pre">d</span></tt>;</li>
<li><tt class="docutils literal"><span class="pre">STARTS_BEFORE</span></tt>: <tt class="docutils literal"><span class="pre">t</span></tt> starts before <tt class="docutils literal"><span class="pre">d</span></tt>, i.e. <tt class="docutils literal"><span class="pre">Start(t)</span> <span class="pre">&lt;=</span> <span class="pre">d</span></tt>;</li>
<li><tt class="docutils literal"><span class="pre">CROSS_DATE</span></tt>: <tt class="docutils literal"><span class="pre">STARTS_BEFORE</span></tt> and <tt class="docutils literal"><span class="pre">ENDS_AFTER</span></tt> at the same time, i.e. <tt class="docutils literal"><span class="pre">d</span></tt> is in <tt class="docutils literal"><span class="pre">t</span></tt>;</li>
<li><tt class="docutils literal"><span class="pre">AVOID_DATE</span></tt>: <tt class="docutils literal"><span class="pre">STARTS_AFTER</span></tt> or <tt class="docutils literal"><span class="pre">ENDS_BEFORE</span></tt>, i.e. <tt class="docutils literal"><span class="pre">d</span></tt> is not in <tt class="docutils literal"><span class="pre">t</span></tt>.</li>
</ul>
</div></blockquote>
<p>The possibilities are enclosed in the <tt class="docutils literal"><span class="pre">UnaryIntervalRelation</span></tt> <tt class="docutils literal"><span class="pre">enum</span></tt>. The corresponding constraints are
<tt class="docutils literal"><span class="pre">IntervalUnaryRelation</span></tt> constraints and the factory method is:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Constraint</span><span class="o">*</span> <span class="n">Solver</span><span class="o">::</span><span class="n">MakeIntervalVarRelation</span><span class="p">(</span><span class="n">IntervalVar</span><span class="o">*</span> <span class="k">const</span> <span class="n">t</span><span class="p">,</span>
                                     <span class="n">Solver</span><span class="o">::</span><span class="n">UnaryIntervalRelation</span> <span class="n">r</span><span class="p">,</span>
                                     <span class="n">int64</span> <span class="n">d</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="binaryintervalrelation-constraints">
<h3>6.3.2.2. <tt class="docutils literal"><span class="pre">BinaryIntervalRelation</span></tt> constraints</h3>
<p>You can specify a temporal relation between two <tt class="docutils literal"><span class="pre">IntervalVar</span></tt>s <tt class="docutils literal"><span class="pre">t1</span></tt> and <tt class="docutils literal"><span class="pre">t2</span></tt>:</p>
<blockquote>
<div><ul class="simple">
<li><tt class="docutils literal"><span class="pre">ENDS_AFTER_END</span></tt>: <tt class="docutils literal"><span class="pre">t1</span></tt> ends after <tt class="docutils literal"><span class="pre">t2</span></tt> ends, i.e. <tt class="docutils literal"><span class="pre">End(t1)</span> <span class="pre">&gt;=</span> <span class="pre">End(t2)</span></tt>;</li>
<li><tt class="docutils literal"><span class="pre">ENDS_AFTER_START</span></tt>: <tt class="docutils literal"><span class="pre">t1</span></tt> ends after t2 starts, i.e. <tt class="docutils literal"><span class="pre">End(t1)</span> <span class="pre">&gt;=</span> <span class="pre">Start(t2)</span></tt>;</li>
<li><tt class="docutils literal"><span class="pre">ENDS_AT_END</span></tt>: <tt class="docutils literal"><span class="pre">t1</span></tt> ends at the end of <tt class="docutils literal"><span class="pre">t2</span></tt>, i.e. <tt class="docutils literal"><span class="pre">End(t1)</span> <span class="pre">==</span> <span class="pre">End(t2)</span></tt>;</li>
<li><tt class="docutils literal"><span class="pre">ENDS_AT_START</span></tt>: <tt class="docutils literal"><span class="pre">t1</span></tt> ends at <tt class="docutils literal"><span class="pre">t2</span></tt>&#8216;s start, i.e. <tt class="docutils literal"><span class="pre">End(t1)</span> <span class="pre">==</span> <span class="pre">Start(t2)</span></tt>;</li>
<li><tt class="docutils literal"><span class="pre">STARTS_AFTER_START</span></tt>: <tt class="docutils literal"><span class="pre">t1</span></tt> starts after <tt class="docutils literal"><span class="pre">t2</span></tt> starts, i.e. <tt class="docutils literal"><span class="pre">Start(t1)</span> <span class="pre">&gt;=</span> <span class="pre">Start(t2)</span></tt>;</li>
<li><tt class="docutils literal"><span class="pre">STARTS_AFTER_END</span></tt>: <tt class="docutils literal"><span class="pre">t1</span></tt> starts after <tt class="docutils literal"><span class="pre">t2</span></tt> ends, i.e. <tt class="docutils literal"><span class="pre">Start(t1)</span> <span class="pre">&gt;=</span> <span class="pre">End(t2)</span></tt>;</li>
<li><tt class="docutils literal"><span class="pre">STARTS_AT_END</span></tt>: <tt class="docutils literal"><span class="pre">t1</span></tt> starts at <tt class="docutils literal"><span class="pre">t2</span></tt>&#8216;s end, i.e. <tt class="docutils literal"><span class="pre">Start(t1)</span> <span class="pre">==</span> <span class="pre">End(t2)</span></tt>;</li>
<li><tt class="docutils literal"><span class="pre">STARTS_AT_START</span></tt>: <tt class="docutils literal"><span class="pre">t1</span></tt> starts when <tt class="docutils literal"><span class="pre">t2</span></tt> starts, i.e. <tt class="docutils literal"><span class="pre">Start(t1)</span> <span class="pre">==</span> <span class="pre">Start(t2)</span></tt>;</li>
<li><tt class="docutils literal"><span class="pre">STAYS_IN_SYNC</span></tt>: <tt class="docutils literal"><span class="pre">STARTS_AT_START</span></tt> and <tt class="docutils literal"><span class="pre">ENDS_AT_END</span></tt> combined together.</li>
</ul>
</div></blockquote>
<p>These possibilities are enclosed in the <tt class="docutils literal"><span class="pre">BinaryIntervalRelation</span></tt> <tt class="docutils literal"><span class="pre">enum</span></tt> and the factory method is:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Constraint</span><span class="o">*</span> <span class="n">Solver</span><span class="o">::</span><span class="n">MakeIntervalVarRelation</span><span class="p">(</span><span class="n">IntervalVar</span><span class="o">*</span> <span class="k">const</span> <span class="n">t1</span><span class="p">,</span>
                                     <span class="n">Solver</span><span class="o">::</span><span class="n">BinaryIntervalRelation</span> <span class="n">r</span><span class="p">,</span>
                                     <span class="n">IntervalVar</span><span class="o">*</span> <span class="k">const</span> <span class="n">t2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="temporaldisjunction-constraints">
<h3>6.3.2.3. <tt class="docutils literal"><span class="pre">TemporalDisjunction</span></tt> constraints</h3>
<p><tt class="docutils literal"><span class="pre">TemporalDisjunction</span></tt> constraints ensure that two <cite>ÌntervalVar`</cite> variables are temporally disjoint, i.e.
they cannot be processed at the same time.</p>
<p>To create such a constraint, use:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">solver</span> <span class="o">=</span> <span class="p">...</span>
<span class="p">...</span>
<span class="n">IntervalVar</span> <span class="o">*</span> <span class="k">const</span> <span class="n">t1</span> <span class="o">=</span> <span class="p">...</span>
<span class="n">IntervalVar</span> <span class="o">*</span> <span class="k">const</span> <span class="n">t2</span> <span class="o">=</span> <span class="p">...</span>
<span class="p">...</span>
<span class="n">Constraint</span> <span class="o">*</span> <span class="n">ct</span> <span class="o">=</span> <span class="n">solver</span><span class="p">.</span><span class="n">MakeTemporalDisjunction</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">);</span>
</pre></div>
</div>
<p>Maybe you can relate the decision on what has to happen first to the value an <tt class="docutils literal"><span class="pre">IntVar</span></tt> takes:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="p">...</span>
<span class="n">IntVar</span> <span class="o">*</span> <span class="k">const</span> <span class="n">decider</span> <span class="o">=</span> <span class="p">...</span>
<span class="n">Constraint</span> <span class="o">*</span> <span class="n">ct</span> <span class="o">=</span> <span class="n">solver</span><span class="p">.</span><span class="n">MakeTemporalDisjunction</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">decider</span><span class="p">)</span>
</pre></div>
</div>
<p>If <tt class="docutils literal"><span class="pre">decider</span></tt> takes the value <tt class="docutils literal"><span class="pre">0</span></tt>, then <tt class="docutils literal"><span class="pre">t1</span></tt> has to happen before <tt class="docutils literal"><span class="pre">t2</span></tt>, otherwise it is the contrary.
This constraint works the other way around too: if <tt class="docutils literal"><span class="pre">t1</span></tt> happens before <tt class="docutils literal"><span class="pre">t2</span></tt>, then the <tt class="docutils literal"><span class="pre">IntVar</span></tt>
<tt class="docutils literal"><span class="pre">decider</span></tt>
is bound to <tt class="docutils literal"><span class="pre">0</span></tt> and else to a positive value (understand <tt class="docutils literal"><span class="pre">1</span></tt> in this case).</p>
</div>
<div class="section" id="disjunctiveconstraint-constraints">
<h3>6.3.2.4. <tt class="docutils literal"><span class="pre">DisjunctiveConstraint</span></tt> constraints</h3>
<p><tt class="docutils literal"><span class="pre">DisjunctiveConstraint</span></tt> constraints are like <tt class="docutils literal"><span class="pre">TemporalDisjunction</span></tt> constraints but for an unlimited number of <tt class="docutils literal"><span class="pre">IntervalVar</span></tt>
variables. Think of the <tt class="docutils literal"><span class="pre">DisjunctiveConstraint</span></tt> as
a kind of <tt class="docutils literal"><span class="pre">AllDifferent</span></tt> constraints but on <tt class="docutils literal"><span class="pre">IntervalVar</span></tt>s.</p>
<p>The factory method is:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Constraint</span> <span class="o">*</span>        <span class="nf">MakeDisjunctiveConstraint</span> <span class="p">(</span>
                    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">IntervalVar</span> <span class="o">*</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">intervals</span><span class="p">);</span>
</pre></div>
</div>
<p>In the current implementation, the created
constraint is a <tt class="docutils literal"><span class="pre">FullDisjunctiveConstraint</span></tt> which means that the <tt class="docutils literal"><span class="pre">IntervalVar</span></tt>s will be disjoint.</p>
<p>The <tt class="docutils literal"><span class="pre">DisjunctiveConstraint</span></tt> class itself is a pure abstract class. Subclasses must implement the following method:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">virtual</span> <span class="n">SequenceVar</span><span class="o">*</span> <span class="n">MakeSequenceVar</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>This method creates a <tt class="docutils literal"><span class="pre">SequenceVar</span></tt> containing the &#8220;rankable&#8221;<a class="footnote-reference" href="#what-rankable" id="id5">[5]</a> <tt class="docutils literal"><span class="pre">IntervalVar</span></tt>s given in
the <tt class="docutils literal"><span class="pre">intervals</span></tt> <tt class="docutils literal"><span class="pre">std::vector&lt;IntervalVar</span> <span class="pre">*&gt;</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">SequenceVar</span></tt> variables are so closely tied to a sequence of <tt class="docutils literal"><span class="pre">IntervalVar</span></tt>s that obeys a <tt class="docutils literal"><span class="pre">DisjunctiveConstraint</span></tt>
constraint that it is quite natural to find such a method. In the current implementation, it is the <strong>only</strong>
available method to create
a <tt class="docutils literal"><span class="pre">SequenceVar</span></tt> variable!</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The use of the <tt class="docutils literal"><span class="pre">MakeSequenceVar()</span></tt> method of a <tt class="docutils literal"><span class="pre">DisjunctiveConstraint</span></tt>  constraint is the only
way to create a <tt class="docutils literal"><span class="pre">SequenceVar</span></tt> variable in the current implementation. This might change in the future.</p>
</div>
<table class="docutils footnote" frame="void" id="what-rankable" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[5]</a></td><td>You remember that <em>unperformed</em> <tt class="docutils literal"><span class="pre">IntervalVar</span></tt>s are &#8220;non existing&#8221;, don&#8217;t you? And yes, we know
that the adjective &#8220;rankable&#8221; doesn&#8217;t exist...</td></tr>
</tbody>
</table>
</div>
<div class="section" id="cumulativeconstraint-constraints">
<h3>6.3.2.5. <tt class="docutils literal"><span class="pre">CumulativeConstraint</span></tt> constraints</h3>
<p>This constraint forces, for any integer <tt class="docutils literal"><span class="pre">t</span></tt>, the sum of the demands
corresponding to an interval containing <tt class="docutils literal"><span class="pre">t</span></tt> to not exceed the given
capacity.</p>
<p>Intervals and demands should be vectors of equal size.</p>
<p>Demands should only contain non-negative values. Zero values are supported,
and the corresponding intervals are filtered out, as they neither impact
nor are impacted by this constraint.</p>
<p>Here is one factory method with a limited static capacity:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Constraint</span><span class="o">*</span> <span class="nf">MakeCumulative</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">IntervalVar</span><span class="o">*&gt;&amp;</span> <span class="n">intervals</span><span class="p">,</span>
                           <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int64</span><span class="o">&gt;&amp;</span> <span class="n">demands</span><span class="p">,</span>
                           <span class="n">int64</span> <span class="n">capacity</span><span class="p">,</span>
                           <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">);</span>
</pre></div>
</div>
<p>If you need more flexibility, use the following factory method:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Constraint</span><span class="o">*</span> <span class="nf">MakeCumulative</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">IntervalVar</span><span class="o">*&gt;&amp;</span> <span class="n">intervals</span><span class="p">,</span>
                           <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int64</span><span class="o">&gt;&amp;</span> <span class="n">demands</span><span class="p">,</span>
                           <span class="n">IntVar</span><span class="o">*</span> <span class="k">const</span> <span class="n">capacity</span><span class="p">,</span>
                           <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">);</span>
</pre></div>
</div>
<p>Here the capacity is modelled by an <tt class="docutils literal"><span class="pre">IntVar</span></tt>. This variable is really a <em>capacity</em>
in the sense that it is this variable that determines the capacity and it will not be adjusted
to satisfy the <tt class="docutils literal"><span class="pre">CumulativeConstraint</span></tt> constraint.</p>
</div>
</div>
<div class="section" id="constraints-on-sequencevars">
<h2>6.3.3. Constraints on <tt class="docutils literal"><span class="pre">SequenceVar</span></tt>s</h2>
<p>There are none for the time being. Nobody prevents you from implementing one though.</p>
</div>
<div class="section" id="decisionbuilders-and-decisions-for-scheduling">
<span id="scheduling-decisionbuilders-decision"></span><h2>6.3.4. <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>s and <tt class="docutils literal"><span class="pre">Decision</span></tt>s for scheduling</h2>
<p>This sub-section is going to be very brief. Indeed, even if room has been made
in the code to welcome several alternative strategies, at the moment of writing
(<a class="reference external" href="http://code.google.com/p/or-tools/source/detail?r=2502">revision r2502</a>,
January 11 <sup>th</sup> 2013) there is &#8220;only one real&#8221; strategy implemented to deal with
<tt class="docutils literal"><span class="pre">IntervalVar</span></tt>s and <tt class="docutils literal"><span class="pre">SequenceVar</span></tt>s. The <tt class="docutils literal"><span class="pre">RankFirstIntervalVars</span></tt> <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> for <tt class="docutils literal"><span class="pre">SequenceVar</span></tt>s
and the <tt class="docutils literal"><span class="pre">SetTimesForward</span></tt> <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> for <tt class="docutils literal"><span class="pre">IntervalVar</span></tt>s both
try to rank the <tt class="docutils literal"><span class="pre">IntervalVar</span></tt>s
one after the other starting with the first &#8220;available&#8221; ones.</p>
<p>When we&#8217;ll implement different strategies, we will update the manual. If you&#8217;re curious about the implementation
details, we refer you to the code (mainly to the file <tt class="file docutils literal"><span class="pre">constraint_solver/sched_search.cc</span></tt>).</p>
<p>If you need specialized <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>s and <tt class="docutils literal"><span class="pre">Decision</span></tt>s, you now know the inner working of the CP solver
well enough to construct ones to suit your needs. Although nothing prevents you from creating tools that mix <tt class="docutils literal"><span class="pre">IntVar</span></tt>s,
<tt class="docutils literal"><span class="pre">IntervalVar</span></tt>s and <tt class="docutils literal"><span class="pre">SequenceVar</span></tt>s, we strongly advice you to keep
different types of variables separated and combine different phases together instead.</p>
<div class="section" id="id6">
<h3>6.3.4.1. <tt class="docutils literal"><span class="pre">IntervalVar</span></tt>s</h3>
<p>For <tt class="docutils literal"><span class="pre">IntervalVar</span></tt> variables, there is only one strategy implemented even if there are three entries
in the <tt class="docutils literal"><span class="pre">IntervalStrategy</span></tt> <tt class="docutils literal"><span class="pre">enum</span></tt>:</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">INTERVAL_DEFAULT</span></tt> <tt class="docutils literal"><span class="pre">=</span></tt> <tt class="docutils literal"><span class="pre">INTERVAL_SIMPLE</span></tt> <tt class="docutils literal"><span class="pre">=</span></tt> <tt class="docutils literal"><span class="pre">INTERVAL_SET_TIMES_FORWARD</span></tt>:</dt>
<dd>The CP solver simply schedules the <tt class="docutils literal"><span class="pre">IntervalVar</span></tt> with the lowest starting time (<tt class="docutils literal"><span class="pre">StartMin()</span></tt>) and
in case of a tie, the <tt class="docutils literal"><span class="pre">IntervalVar</span></tt> with the lowest ending time (<tt class="docutils literal"><span class="pre">StartMax()</span></tt>).</dd>
</dl>
<p>The <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> class is the <tt class="docutils literal"><span class="pre">SetTimesForward</span></tt> class. It returns a <tt class="docutils literal"><span class="pre">ScheduleOrPostpone</span></tt> <tt class="docutils literal"><span class="pre">Decision</span></tt> in its
<tt class="docutils literal"><span class="pre">Next()</span></tt> method. This <tt class="docutils literal"><span class="pre">Decision</span></tt> fixes the starting time of the <tt class="docutils literal"><span class="pre">IntervalVar</span></tt> to its minimum starting
time (<tt class="docutils literal"><span class="pre">StartMin()</span></tt>)
in its <tt class="docutils literal"><span class="pre">Apply()</span></tt> method and, in its <tt class="docutils literal"><span class="pre">Refute()</span></tt> method, delays the execution of the corresponding task by <tt class="docutils literal"><span class="pre">1</span></tt> unit
of time, i.e. the <tt class="docutils literal"><span class="pre">IntervalVar</span></tt> cannot be scheduled before <tt class="docutils literal"><span class="pre">StartMin()</span> <span class="pre">+</span> <span class="pre">1</span></tt>.</p>
<p>You create the corresponding phase with the good old <tt class="docutils literal"><span class="pre">MakePhase</span></tt> factory method:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">DecisionBuilder</span> <span class="o">*</span> <span class="nf">MakePhase</span> <span class="p">(</span>
                    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">IntervalVar</span> <span class="o">*</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">intervals</span><span class="p">,</span>
                    <span class="n">IntervalStrategy</span> <span class="n">str</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="id7">
<h3>6.3.4.2. <tt class="docutils literal"><span class="pre">SequenceVar</span></tt>s</h3>
<p>For <tt class="docutils literal"><span class="pre">SequenceVar</span></tt> variables, there are basically two ways of choosing the next <tt class="docutils literal"><span class="pre">SequenceVar</span></tt> to rank its
<tt class="docutils literal"><span class="pre">IntervalVar</span></tt>s:</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">SEQUENCE_DEFAULT</span></tt> <tt class="docutils literal"><span class="pre">=</span></tt> <tt class="docutils literal"><span class="pre">SEQUENCE_SIMPLE</span></tt> <tt class="docutils literal"><span class="pre">=</span></tt> <tt class="docutils literal"><span class="pre">CHOOSE_MIN_SLACK_RANK_FORWARD</span></tt>:</dt>
<dd><p class="first">The CP solver chooses the <tt class="docutils literal"><span class="pre">SequenceVar</span></tt> which has the fewest opportunities of manoeuvre, i.e.
the <tt class="docutils literal"><span class="pre">SequenceVar</span></tt> for which the <em>horizon range</em> (<tt class="docutils literal"><span class="pre">hmax</span> <span class="pre">-</span> <span class="pre">hmin</span></tt>, see the <tt class="docutils literal"><span class="pre">HorizonRange()</span></tt> method above)
is the closest to the total maximum duration of the <tt class="docutils literal"><span class="pre">IntervalVar</span></tt>s that may be performed (<tt class="docutils literal"><span class="pre">dmax</span></tt> in the
<tt class="docutils literal"><span class="pre">DurationRange()</span></tt> method above). In other words, we define the <em>slack</em> to be</p>
<div class="math">
<p><img src="../../_images/math/46c4b2a7860a2693a7eb0b452c0d368ffe318134.png" alt="\text{slack} = (\text{hmax} - \text{hmin}) - \text{dmax}"/></p>
</div><p>and we choose the <tt class="docutils literal"><span class="pre">SequenceVar</span></tt> with the minimum slack. In case of a tie, we choose the <tt class="docutils literal"><span class="pre">SequenceVar</span></tt>
with the smallest active horizon range (see <tt class="docutils literal"><span class="pre">ahmin</span></tt> in the <tt class="docutils literal"><span class="pre">ActiveHorizonRange()</span></tt> method above).</p>
<p class="last">Once the best <tt class="docutils literal"><span class="pre">SequenceVar</span></tt> variable is chosen, the CP solver takes the rankable <tt class="docutils literal"><span class="pre">IntervalVar</span></tt> with the
minimum starting time (<tt class="docutils literal"><span class="pre">StartMin()</span></tt>) and ranks it first.</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">CHOOSE_RANDOM_RANK_FORWARD</span></tt>:</dt>
<dd>Among the <tt class="docutils literal"><span class="pre">SequenceVar</span></tt>s for which there are still <tt class="docutils literal"><span class="pre">IntervalVar</span></tt>s to rank, the CP solver chooses
one randomly. Then it randomly
chooses  a rankable <tt class="docutils literal"><span class="pre">IntervalVar</span></tt> and ranks it first.</dd>
</dl>
<p><tt class="docutils literal"><span class="pre">SEQUENCE_DEFAULT</span></tt>, <tt class="docutils literal"><span class="pre">SEQUENCE_SIMPLE</span></tt>, <tt class="docutils literal"><span class="pre">CHOOSE_MIN_SLACK_RANK_FORWARD</span></tt> and <tt class="docutils literal"><span class="pre">CHOOSE_RANDOM_RANK_FORWARD</span></tt>
are given in the <tt class="docutils literal"><span class="pre">SequenceStrategy</span></tt> <tt class="docutils literal"><span class="pre">enum</span></tt>.</p>
<p>To create these search strategies, use the following factory method:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">DecisionBuilder</span><span class="o">*</span> <span class="n">Solver</span><span class="o">::</span><span class="n">MakePhase</span><span class="p">(</span>
                        <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SequenceVar</span><span class="o">*&gt;&amp;</span> <span class="n">sequences</span><span class="p">,</span>
                        <span class="n">SequenceStrategy</span> <span class="n">str</span><span class="p">);</span>
</pre></div>
</div>
<p>In both cases, we use the <tt class="docutils literal"><span class="pre">RankFirstIntervalVars</span></tt> class as <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>. Its <tt class="docutils literal"><span class="pre">Next()</span></tt> method returns
a <tt class="docutils literal"><span class="pre">RankFirst</span></tt> <tt class="docutils literal"><span class="pre">Decision</span></tt> that ranks first the selected <tt class="docutils literal"><span class="pre">IntervalVar</span></tt> in its <tt class="docutils literal"><span class="pre">Apply()</span></tt> method and
doesn&#8217;t rank it first in its <tt class="docutils literal"><span class="pre">Refute()</span></tt> method. We are thus assured to visit the complete search tree...
of solutions of ranked <tt class="docutils literal"><span class="pre">IntervalVar</span></tt>s if needed. After the ranking of <tt class="docutils literal"><span class="pre">IntervalVar</span></tt>s, the schedule is
still loose and any <tt class="docutils literal"><span class="pre">IntervalVar</span></tt> may have been unnecessarily postponed. This is so important that we use our warning
box:</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">After the ranking of <tt class="docutils literal"><span class="pre">IntervalVar</span></tt>s, the schedule is still loose and any <tt class="docutils literal"><span class="pre">IntervalVar</span></tt> may have been unnecessarily postponed</p>
</div>
<p>If for instance, you are interested in the <em>makespan</em>, you might want to
schedule each <tt class="docutils literal"><span class="pre">IntervalVar</span></tt> at its earliest start time. As we have seen in the previous section, this can
be accomplished by minimizing the objective function corresponding to the ending times of all <tt class="docutils literal"><span class="pre">IntervalVar</span></tt>s:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">IntVar</span> <span class="o">*</span> <span class="n">objective_var</span> <span class="o">=</span> <span class="p">...</span>
<span class="p">...</span>
<span class="n">DecisionBuilder</span><span class="o">*</span> <span class="k">const</span> <span class="n">sequence_phase</span> <span class="o">=</span> <span class="n">solver</span><span class="p">.</span><span class="n">MakePhase</span><span class="p">(</span>
                                         <span class="n">all_sequences</span><span class="p">,</span>
                                         <span class="n">Solver</span><span class="o">::</span><span class="n">SEQUENCE_DEFAULT</span><span class="p">);</span>
<span class="p">...</span>
<span class="n">DecisionBuilder</span><span class="o">*</span> <span class="k">const</span> <span class="n">obj_phase</span> <span class="o">=</span> <span class="n">solver</span><span class="p">.</span><span class="n">MakePhase</span><span class="p">(</span><span class="n">objective_var</span><span class="p">,</span>
                                   <span class="n">Solver</span><span class="o">::</span><span class="n">CHOOSE_FIRST_UNBOUND</span><span class="p">,</span>
                                   <span class="n">Solver</span><span class="o">::</span><span class="n">ASSIGN_MIN_VALUE</span><span class="p">);</span>
</pre></div>
</div>
<p>and then compose the two <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>s sequentially:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">DecisionBuilder</span><span class="o">*</span> <span class="k">const</span> <span class="n">main_phase</span> <span class="o">=</span> <span class="n">solver</span><span class="p">.</span><span class="n">Compose</span><span class="p">(</span><span class="n">sequence_phase</span><span class="p">,</span>
                                                   <span class="n">obj_phase</span><span class="p">);</span>
</pre></div>
</div>
<p>By the way, the <tt class="docutils literal"><span class="pre">MakePhase()</span></tt> method has been optimized when the phase only handles one or a few variables (up to 4),
like in the above example for the <tt class="docutils literal"><span class="pre">obj_phase</span></tt>.</p>
</div>
</div>
<div class="section" id="dependencygraph">
<h2>6.3.5. <tt class="docutils literal"><span class="pre">DependencyGraph</span></tt></h2>
<p>If you want to add more specific temporal constraints, you can use a data structure specialized for scheduling:
the <tt class="docutils literal"><span class="pre">DependencyGraph</span></tt>. It is meant to store simple temporal constraints and to propagate
efficiently on the nodes of this temporal graph. One node in this graph corresponds to an <tt class="docutils literal"><span class="pre">IntervalVar</span></tt> variable.
You can build constraints on the start or the ending time of the <tt class="docutils literal"><span class="pre">IntervalVar</span></tt> nodes.</p>
<p>Consider again our first example (<tt class="file docutils literal"><span class="pre">first_example_jssp.txt</span></tt>) and let&#8217;s say that for whatever reason we want to impose
that the first task of job 2 must start at least after one unit of time after the first task of job 1. We could add this
constraint in different ways but let&#8217;s use the <tt class="docutils literal"><span class="pre">DependencyGraph</span></tt>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">solver</span> <span class="o">=</span> <span class="p">...</span>
<span class="p">...</span>
<span class="n">DependencyGraph</span> <span class="o">*</span> <span class="n">graph</span> <span class="o">=</span> <span class="n">solver</span><span class="p">.</span><span class="n">Graph</span><span class="p">();</span>
<span class="n">graph</span><span class="o">-&gt;</span><span class="n">AddStartsAfterEndWithDelay</span><span class="p">(</span><span class="n">jobs_to_tasks</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                                  <span class="n">jobs_to_tasks</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">);</span>
</pre></div>
</div>
<p>That&#8217;s it!</p>
<p>Here is the output of an optimal solution found by the solver:</p>
<div class="highlight-text"><div class="highlight"><pre>Objective value: 13
Machine_0: Job 1 (0,2)  Job 0 (2,5)
Machine_1: Job 2 (3,7)  Job 0 (7,9)  Job 1 (9,13)
Machine_2: Job 1 (2,3)  Job 2 (7,10)  Job 0 (10,12)
</pre></div>
</div>
<p>As you can see, the first task of job 2 starts at 3 units of time and the first task of job 1 ends at 2 units of time.</p>
<p>Other methods of the <tt class="docutils literal"><span class="pre">DependencyGraph</span></tt> include:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">AddStartsAtEndWithDelay()</span></tt></li>
<li><tt class="docutils literal"><span class="pre">AddStartsAfterStartWithDelay()</span></tt></li>
<li><tt class="docutils literal"><span class="pre">AddStartsAtStartWithDelay()</span></tt></li>
</ul>
<p>The <tt class="docutils literal"><span class="pre">DependencyGraph</span></tt> and the <tt class="docutils literal"><span class="pre">DependencyGraphNode</span></tt> classes are declared in the
<tt class="file docutils literal"><span class="pre">constraint_solver/constraint_solveri.h</span></tt> header.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<table>
<tr>
<td width="60"><img src="../../_static/logo.png" width="50" height="50"  alt="" /></td>
<td><p class="library_name">Google <a href="http://code.google.com/p/or-tools/"><strong>or-tools</strong></a><br>open source library</p></td>
</tr>
</table>
<h1>User's Manual</h1>

  
   



<h3>Google search</h3>

<form method="get" action="http://www.google.com/search">

<div style="padding:-1px;width:15em;">
<table border="0" cellpadding="0">
<tr><td>
<input type="text"   name="q" size="25"
 maxlength="255" value="" />
<input type="submit" value="Go" /></td></tr>
<tr><td align="center" style="font-size:80%">
Search:
<select name="sitesearch" width="125" style="width: 125px">
<option value="http://or-tools.googlecode.com/svn/trunk/documentation/user_manual/" selected>user's manual</option>
<option value="http://or-tools.googlecode.com/svn/trunk/documentation/faq/">faq</option>
<option value="http://or-tools.googlecode.com/svn/trunk/documentation/reference_manual/or-tools/">reference manual</option>
<option value="http://or-tools.googlecode.com/svn/trunk/documentation/">All or-tools doc</option>
</select>
</td></tr>
</table>
</div>

</form>
</br>




  <h3>Welcome</h3>
  
  <ul>
  	<li><a href="../../index.html">Content and foreword</a></li>
  	<li><a href="http://or-tools.googlecode.com/svn/trunk/documentation/documentation_hub.html">Documentation's hub</a></li>
	<li><a href="http://code.google.com/p/or-tools/">The or-tools open source library</a></li></li>	
  </ul>
  
   
	


  <h3>Tutorial examples</h3>
  
  <ul>
	<li><a href="http://or-tools.googlecode.com/svn/trunk/documentation/documentation_hub.html#tutorial_C++">C++</a></li>
	<li><a href="http://or-tools.googlecode.com/svn/trunk/documentation/documentation_hub.html#tutorial_Python">Python</a></li>	
	<li><a href="http://or-tools.googlecode.com/svn/trunk/documentation/documentation_hub.html#tutorial_Java">Java</a></li>
	<li><a href="http://or-tools.googlecode.com/svn/trunk/documentation/documentation_hub.html#tutorial_Csharp">C#</a></li>
</ul>
  
   
	

  <h3>Current chapter</h3>
  <p class="topless"><a href="../LS.html"
                        title="previous chapter">6. Local search: the job-shop problem</a></p>
  <h3>Previous section</h3>
  <p class="topless"><a href="jobshop_implementation.html"
                        title="previous chapter">6.2. An implementation of the disjunctive model</a></p>
  <h3>Next section</h3>
  <p class="topless"><a href="local_search.html"
                        title="next chapter">6.4. What is local search (LS)?</a></p>
  <h3>Current section</a></h3>
  <ul>
<li><a class="reference internal" href="#">6.3. Scheduling in <em>or-tools</em></a><ul>
<li><a class="reference internal" href="#variables">6.3.1. Variables</a><ul>
<li><a class="reference internal" href="#intervalvars">6.3.1.1. <tt class="docutils literal"><span class="pre">IntervalVar</span></tt>s</a></li>
<li><a class="reference internal" href="#variables-that-perform-or-not">6.3.1.2. Variables that perform... or not</a></li>
<li><a class="reference internal" href="#sequencevars">6.3.1.3. <tt class="docutils literal"><span class="pre">SequenceVar</span></tt>s</a></li>
<li><a class="reference internal" href="#ranked-intervalvars">6.3.1.4. Ranked <tt class="docutils literal"><span class="pre">IntervalVar</span></tt>s</a></li>
<li><a class="reference internal" href="#public-methods">6.3.1.5. Public methods</a></li>
</ul>
</li>
<li><a class="reference internal" href="#constraints-on-intervalvars">6.3.2. Constraints on <tt class="docutils literal"><span class="pre">IntervalVar</span></tt>s</a><ul>
<li><a class="reference internal" href="#intervalunaryrelation-constraints">6.3.2.1. <tt class="docutils literal"><span class="pre">IntervalUnaryRelation</span></tt> constraints</a></li>
<li><a class="reference internal" href="#binaryintervalrelation-constraints">6.3.2.2. <tt class="docutils literal"><span class="pre">BinaryIntervalRelation</span></tt> constraints</a></li>
<li><a class="reference internal" href="#temporaldisjunction-constraints">6.3.2.3. <tt class="docutils literal"><span class="pre">TemporalDisjunction</span></tt> constraints</a></li>
<li><a class="reference internal" href="#disjunctiveconstraint-constraints">6.3.2.4. <tt class="docutils literal"><span class="pre">DisjunctiveConstraint</span></tt> constraints</a></li>
<li><a class="reference internal" href="#cumulativeconstraint-constraints">6.3.2.5. <tt class="docutils literal"><span class="pre">CumulativeConstraint</span></tt> constraints</a></li>
</ul>
</li>
<li><a class="reference internal" href="#constraints-on-sequencevars">6.3.3. Constraints on <tt class="docutils literal"><span class="pre">SequenceVar</span></tt>s</a></li>
<li><a class="reference internal" href="#decisionbuilders-and-decisions-for-scheduling">6.3.4. <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>s and <tt class="docutils literal"><span class="pre">Decision</span></tt>s for scheduling</a><ul>
<li><a class="reference internal" href="#id6">6.3.4.1. <tt class="docutils literal"><span class="pre">IntervalVar</span></tt>s</a></li>
<li><a class="reference internal" href="#id7">6.3.4.2. <tt class="docutils literal"><span class="pre">SequenceVar</span></tt>s</a></li>
</ul>
</li>
<li><a class="reference internal" href="#dependencygraph">6.3.5. <tt class="docutils literal"><span class="pre">DependencyGraph</span></tt></a></li>
</ul>
</li>
</ul>

        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="local_search.html" title="6.4. What is local search (LS)?"
             >next</a> |</li>
        <li class="right" >
          <a href="jobshop_implementation.html" title="6.2. An implementation of the disjunctive model"
             >previous</a> |</li>
        <li><a href="../../index.html">or-tools User&#39;s Manual</a> &raquo;</li>
          <li><a href="../LS.html" >6. Local search: the job-shop problem</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012-2013, Google.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>