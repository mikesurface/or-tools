

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>6.6. Local Search Operators &mdash; or-tools User&#39;s Manual</title>
    
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     'doc version 0.0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  false
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../../_static/logo.ico"/>
    <link rel="top" title="or-tools User&#39;s Manual" href="../../index.html" />
    <link rel="up" title="6. Local search: the job-shop problem" href="../LS.html" />
    <link rel="next" title="6.7. The jobshop problem: and now with local search!" href="jobshop_ls.html" />
    <link rel="prev" title="6.5. Basic working of the solver: Local Search" href="basic_working_local_search.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="jobshop_ls.html" title="6.7. The jobshop problem: and now with local search!"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="basic_working_local_search.html" title="6.5. Basic working of the solver: Local Search"
             accesskey="P">previous</a> |</li>
        <li><a href="../../index.html">or-tools User&#39;s Manual</a> &raquo;</li>
          <li><a href="../LS.html" accesskey="U">6. Local search: the job-shop problem</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="local-search-operators">
<span id="local-search-neighborhood-operators"></span><h1>6.6. Local Search Operators</h1>
<div class="files-sidebar container">
<ol>
  <li>C++ code:
    <ol>
      <li><a href="../../../tutorials/cplusplus/chap6/dummy_ls.cc">dummy_ls.cc</a></li>
    </ol>
  </li>
</ol></div>
<p>We will use a dummy example throughout this section so
we can solely focus on the basic ingredients provided by the <em>or-tools</em>
library to do the local search.</p>
<p>Our fictive example consists in minimizing the sum of <img class="math" src="../../_images/math/174fadd07fd54c9afe288e96558c92e0c1da733a.png" alt="n" style="vertical-align: 0px"/> <tt class="docutils literal"><span class="pre">IntVar</span></tt>s
<img class="math" src="../../_images/math/5255e13997098334c00b0a0914f78560aca93663.png" alt="\{x_0, \ldots, x_{n - 1}\}" style="vertical-align: -5px"/> each with domain <img class="math" src="../../_images/math/a84dc802efb57b155d24b907ce9e7bae8caa359a.png" alt="[0, n - 1]" style="vertical-align: -5px"/>.
We add the fictive constraint <img class="math" src="../../_images/math/3998581fe70d99938ee529064f9a325d816b0584.png" alt="x_0 \geqslant 1" style="vertical-align: -3px"/> (and thus ask for <img class="math" src="../../_images/math/d99c7df79fdcf28896abb2668e7ca622e9355c40.png" alt="n \geqslant 2" style="vertical-align: -3px"/>):</p>
<div class="math">
<p><img src="../../_images/math/2226db382f1803bbaff328788dbc0c9b06e7dfaf.png" alt="\begin{aligned}
&amp; \underset{x_0, ..., x_{n-1}}{\text{min}}
&amp; &amp; x_0 + x_1 + ... + x_{n-1} \\
&amp; \text{subject to:}
&amp; &amp; x_0 \geqslant 1.\\
&amp; &amp; &amp; x_i \in \{0,\ldots, n-1\} \, \text{for} \,  i = 0 \ldots n-1.
\end{aligned}"/></p>
</div><p>Of course, we already know the optimal solution. Can we find it by local search?</p>
<div class="section" id="localsearchoperators">
<h2>6.6.1. <tt class="docutils literal"><span class="pre">LocalSearchOperator</span></tt>s</h2>
<p>The base class for all local search operators is <tt class="docutils literal"><span class="pre">LocalSearchOperator</span></tt>.
The behaviour of this class is similar to that of an iterator.
The operator is synchronized with a feasible solution (an <tt class="docutils literal"><span class="pre">Assignment</span></tt> that gives the
current values of the variables). This is done in the <tt class="docutils literal"><span class="pre">Start()</span></tt> method.
Then one can iterate over the candidate solutions (the neighbors) using the <tt class="docutils literal"><span class="pre">MakeNextNeighbor()</span></tt> method.
Only the modified part of the solution (an <tt class="docutils literal"><span class="pre">Assignment</span></tt> called <tt class="docutils literal"><span class="pre">delta</span></tt>) is broadcast. You can also
define a second <tt class="docutils literal"><span class="pre">Assignment</span></tt> representing the changes to the
last candidate solution defined by the local search operator (an <tt class="docutils literal"><span class="pre">Assignment</span></tt> called <tt class="docutils literal"><span class="pre">deltadelta</span></tt>).</p>
<p>The CP solver takes care of these <em>delta</em>s and other hassles for the most common cases<a class="footnote-reference" href="#deltadelta-more-in-depth" id="id1">[1]</a>.</p>
<table class="docutils footnote" frame="void" id="deltadelta-more-in-depth" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><p class="first"><tt class="docutils literal"><span class="pre">delta</span></tt>s and <tt class="docutils literal"><span class="pre">deltadelta</span></tt>s are explained in more details in the section <a class="reference internal" href="ls_filtering.html#local-search-filtering"><em>Filtering</em></a>.</p>
</td></tr>
</tbody>
</table>
<p>The next figure shows the
LS Operators hierarchy.</p>
<img alt="../../_images/lsn_hierarchy.png" class="align-center" src="../../_images/lsn_hierarchy.png" style="width: 400pt;" />
<p>These classes are declared in the header <tt class="file docutils literal"><span class="pre">constraint_solver/constraint_solveri.h</span></tt>.</p>
<p>The <tt class="docutils literal"><span class="pre">PathOperator</span></tt> class is itself the base class of several other path specialized
LS Operators. We will review them in the subsection <a class="reference internal" href="../tsp/two_phases_approaches.html#local-search-pathoperators"><em>Local Search PathOperators</em></a>.</p>
<p><tt class="docutils literal"><span class="pre">IntVarLocalSearchOperator</span></tt> is a specialization of <tt class="docutils literal"><span class="pre">LocalSearchOperator</span></tt> built for an array of <tt class="docutils literal"><span class="pre">IntVar</span></tt>s while
<tt class="docutils literal"><span class="pre">SequenceVarLocalSearchOperator</span></tt> is a specialization of <tt class="docutils literal"><span class="pre">LocalSearchOperator</span></tt> built for an array
of <tt class="docutils literal"><span class="pre">SequenceVar</span></tt>s<a class="footnote-reference" href="#no-ls-operators-for-interval-vars" id="id2">[2]</a>.</p>
<table class="docutils footnote" frame="void" id="no-ls-operators-for-interval-vars" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>At the time of writing, there are no <tt class="docutils literal"><span class="pre">LocalSearchOperator</span></tt>s defined for
<tt class="docutils literal"><span class="pre">IntervalVar</span></tt>s. See subsection XXX for a workaround.</td></tr>
</tbody>
</table>
</div>
<div class="section" id="defining-a-custom-ls-operator">
<h2>6.6.2. Defining a custom LS operator</h2>
<p>We will construct an LS Operator for an array of <tt class="docutils literal"><span class="pre">IntVar</span></tt>s but the API for an array of <tt class="docutils literal"><span class="pre">SequenceVar</span></tt>s is similar<a class="footnote-reference" href="#similar-api-intvar-localsearch-operator" id="id3">[3]</a>.</p>
<p>There are two methods to overwrite:</p>
<blockquote>
<div><ul class="simple">
<li><tt class="docutils literal"><span class="pre">OnStart()</span></tt>: this <tt class="docutils literal"><span class="pre">private</span></tt> method is called each time the operator is synced with a new feasible solution;</li>
<li><tt class="docutils literal"><span class="pre">MakeOneNeighbor()</span></tt>: this <tt class="docutils literal"><span class="pre">protected</span></tt> method creates a new feasible solution. As long as there are new solutions constructed
it returns <tt class="docutils literal"><span class="pre">true</span></tt>, <tt class="docutils literal"><span class="pre">false</span></tt> otherwise.</li>
</ul>
</div></blockquote>
<p>Some helper methods are provided:</p>
<blockquote>
<div><ul class="simple">
<li><tt class="docutils literal"><span class="pre">int64</span> <span class="pre">Value(int64</span> <span class="pre">index)</span></tt>: returns the value in the current <tt class="docutils literal"><span class="pre">Assignment</span></tt> of the variable of given index;</li>
<li><tt class="docutils literal"><span class="pre">int64</span> <span class="pre">OldValue(int64</span> <span class="pre">index)</span></tt>: returns the value in the last <tt class="docutils literal"><span class="pre">Assignment</span></tt> (the initial solution or the last
accepted solution) of the variable of given index;</li>
<li><tt class="docutils literal"><span class="pre">SetValue(int64</span> <span class="pre">i,</span> <span class="pre">int64</span> <span class="pre">value)</span></tt>: sets the value of the <tt class="docutils literal"><span class="pre">i</span></tt> <sup>th</sup> variable to <tt class="docutils literal"><span class="pre">value</span></tt> in the current <tt class="docutils literal"><span class="pre">Assignment</span></tt>
and allows to construct a new feasible solution;</li>
<li><tt class="docutils literal"><span class="pre">Size()</span></tt>: returns the size of the array of <tt class="docutils literal"><span class="pre">IntVar</span></tt>s;</li>
<li><tt class="docutils literal"><span class="pre">IntVar*</span> <span class="pre">Var(int64</span> <span class="pre">index)</span></tt>: returns the variable of given index.</li>
</ul>
</div></blockquote>
<p>To construct a new feasible solution, just redefine <tt class="docutils literal"><span class="pre">MakeOneNeighbor()</span></tt>. What are the issues you need to pay attention to?
First, you have to be sure to visit the neighborhood, i.e. to iterate among the (feasible) candidate solutions of this neighborhood. If you
return the same solution(s) again and again or if you don&#8217;t provide any solution, the solver will not detect it (in the second
case, the solver will enter an infinite loop). You are responsible to scour correctly the neighborhood. Second, you have
to be sure the variables you want to change do exist (i.e. beware of going out of bounds on arrays).</p>
<p>Now the good news is that you don&#8217;t have to test for feasibility: it&#8217;s the job of the solver.
You are even allowed to assign out of domain values to the variables.
Again, the solver will discard such solutions (you can also <em>filter</em> these solutions <em>out</em>, see the section <a class="reference internal" href="ls_filtering.html#local-search-filtering"><em>Filtering</em></a>).</p>
<table class="docutils footnote" frame="void" id="similar-api-intvar-localsearch-operator" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td>For instance, the <tt class="docutils literal"><span class="pre">SetValue()</span></tt> method is replaced by the <tt class="docutils literal"><span class="pre">SetForwardSequence()</span></tt>
and <tt class="docutils literal"><span class="pre">SetBackwardSequence()</span></tt> methods.</td></tr>
</tbody>
</table>
<p>Without further delay, here is the code for our custom LSO:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">DecreaseOneVar</span><span class="o">:</span> <span class="k">public</span> <span class="n">IntVarLocalSearchOperator</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">DecreaseOneVar</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">IntVar</span><span class="o">*&gt;&amp;</span> <span class="n">variables</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">IntVarLocalSearchOperator</span><span class="p">(</span><span class="n">variables</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">variables</span><span class="p">.</span><span class="n">size</span><span class="p">()),</span>
      <span class="n">variable_index_</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">MoveOneVar</span><span class="p">()</span> <span class="p">{}</span>

<span class="nl">protected:</span>
  <span class="c1">// Make a neighbor assigning one variable to its target value.</span>
  <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">MakeOneNeighbor</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">variable_index_</span> <span class="o">==</span>  <span class="n">Size</span><span class="p">())</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">const</span> <span class="n">int64</span> <span class="n">current_value</span> <span class="o">=</span> <span class="n">Value</span><span class="p">(</span><span class="n">variable_index_</span><span class="p">);</span>
    <span class="n">SetValue</span><span class="p">(</span><span class="n">variable_index_</span><span class="p">,</span> <span class="n">current_value</span>  <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">variable_index_</span> <span class="o">=</span> <span class="n">variable_index_</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>

<span class="nl">private:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">OnStart</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">variable_index_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">int64</span> <span class="n">variable_index_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Our custom LS Operator simply takes one variable at a time and decrease its value by <img class="math" src="../../_images/math/dce34f4dfb2406144304ad0d6106c5382ddd1446.png" alt="1" style="vertical-align: -1px"/>.
The neighborhood visited from a given solution <img class="math" src="../../_images/math/3f428b34b36ed9d2a1f51ea35548d9d8201af573.png" alt="[x_0, x_1, \ldots, x_{n-1}]" style="vertical-align: -5px"/>
is made of the following solutions (when feasible):</p>
<div class="math">
<p><img src="../../_images/math/e0104c7a800138aa4ab911ba3ad97729b6f3eadc.png" alt="\{[x_0, x_1, \ldots, x_{n-1}], [x_0 - 1, x_1, \ldots, x_{n-1}],
[x_0, x_1 - 1, \ldots, x_{n-1}], \ldots, [x_0, x_1, \ldots, x_{n-1} - 1]\}"/></p>
</div><p>The given initial solution is also part of the neighborhood.</p>
<p>We have rewritten the <tt class="docutils literal"><span class="pre">protected</span></tt> method  <tt class="docutils literal"><span class="pre">MakeOneNeighbor()</span></tt> to construct the next solutions. The variable
<tt class="docutils literal"><span class="pre">variable_index_</span></tt> indicates the current variable we are decreasing in the current solution. As long as there are
remaining variables to decrease, <tt class="docutils literal"><span class="pre">MakeNextNeighbor()</span></tt> returns <tt class="docutils literal"><span class="pre">true</span></tt>. Once we have decreased the last variable (<tt class="docutils literal"><span class="pre">variable_index_</span></tt>
is then equal to <tt class="docutils literal"><span class="pre">Size()</span></tt>), it returns <tt class="docutils literal"><span class="pre">false</span></tt>.</p>
<p>The <tt class="docutils literal"><span class="pre">private</span></tt> method <tt class="docutils literal"><span class="pre">OnStart()</span></tt> that is used whenever we start again with a new feasible solution, simply resets
the variable index to <img class="math" src="../../_images/math/bc1f9d9bf8a1b606a4188b5ce9a2af1809e27a89.png" alt="0" style="vertical-align: 0px"/> to be able to decrease the first variable <img class="math" src="../../_images/math/17f1249ad95b7682b8316ad21de8ce4ee9fdcf93.png" alt="x_0" style="vertical-align: -3px"/> by <img class="math" src="../../_images/math/dce34f4dfb2406144304ad0d6106c5382ddd1446.png" alt="1" style="vertical-align: -1px"/>.</p>
<p>We use the LS Operator <tt class="docutils literal"><span class="pre">DecreaseOneVar</span></tt> in the function <tt class="docutils literal"><span class="pre">SimpleLS()</span></tt> that starts as follow:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">SimpleLS</span><span class="p">(</span><span class="k">const</span> <span class="n">int64</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="kt">bool</span> <span class="n">init_phase</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">CHECK_GE</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;size of problem (n) must be &gt;= 2&quot;</span><span class="p">;</span>
  <span class="n">LOG</span><span class="p">(</span><span class="n">INFO</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Simple LS &quot;</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">init_phase</span> <span class="o">?</span> <span class="s">&quot;with initial phase&quot;</span> <span class="o">:</span>
                              <span class="s">&quot;with initial solution&quot;</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

  <span class="n">Solver</span> <span class="n">s</span><span class="p">(</span><span class="s">&quot;Simple LS&quot;</span><span class="p">);</span>
  <span class="n">vector</span><span class="o">&lt;</span><span class="n">IntVar</span><span class="o">*&gt;</span> <span class="n">vars</span><span class="p">;</span>
  <span class="n">s</span><span class="p">.</span><span class="n">MakeIntVarArray</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vars</span><span class="p">);</span>
  <span class="n">IntVar</span><span class="o">*</span> <span class="k">const</span> <span class="n">sum_var</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">MakeSum</span><span class="p">(</span><span class="n">vars</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">Var</span><span class="p">();</span>
  <span class="n">OptimizeVar</span><span class="o">*</span> <span class="k">const</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">MakeMinimize</span><span class="p">(</span><span class="n">sum_var</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

  <span class="c1">// unique constraint x_0 &gt;= 1</span>
  <span class="n">s</span><span class="p">.</span><span class="n">AddConstraint</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">MakeGreaterOrEqual</span><span class="p">(</span><span class="n">vars</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">));</span>
  <span class="p">...</span>
</pre></div>
</div>
<p><img class="math" src="../../_images/math/174fadd07fd54c9afe288e96558c92e0c1da733a.png" alt="n" style="vertical-align: 0px"/> must be greater or equal to 2 as we ask for <img class="math" src="../../_images/math/3998581fe70d99938ee529064f9a325d816b0584.png" alt="x_0 \geqslant 1" style="vertical-align: -3px"/>.</p>
<p>The <tt class="docutils literal"><span class="pre">OptimizeVar</span></tt> <tt class="docutils literal"><span class="pre">SearchMonitor</span></tt> is very important as it will give the direction to follow for the local search algorithm.
Without it, the local search would walk randomly wihout knowing where to go.</p>
<p>Next, based on the Boolean variable <tt class="docutils literal"><span class="pre">FLAG_initial_phase</span></tt>, we create a
<tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> to find an initial solution or we construct an initial <tt class="docutils literal"><span class="pre">Assignment</span></tt>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// initial phase builder</span>
<span class="n">DecisionBuilder</span> <span class="o">*</span> <span class="n">db</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="c1">// initial solution</span>
<span class="n">Assignment</span> <span class="o">*</span> <span class="k">const</span> <span class="n">initial_solution</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">MakeAssignment</span><span class="p">();</span>

<span class="k">if</span> <span class="p">(</span><span class="n">init_phase</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">db</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">MakePhase</span><span class="p">(</span><span class="n">vars</span><span class="p">,</span>
                   <span class="n">Solver</span><span class="o">::</span><span class="n">CHOOSE_FIRST_UNBOUND</span><span class="p">,</span>
                   <span class="n">Solver</span><span class="o">::</span><span class="n">ASSIGN_MAX_VALUE</span><span class="p">);</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="n">initial_solution</span><span class="o">-&gt;</span><span class="n">Add</span><span class="p">(</span><span class="n">vars</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">initial_solution</span><span class="o">-&gt;</span><span class="n">SetValue</span><span class="p">(</span><span class="n">vars</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">initial_solution</span><span class="o">-&gt;</span><span class="n">SetValue</span><span class="p">(</span><span class="n">vars</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>As we assign the biggest value (<tt class="docutils literal"><span class="pre">ASSIGN_MAX_VALUE</span></tt>) to the first unbound
variables (<tt class="docutils literal"><span class="pre">CHOOSE_FIRST_UNBOUND</span></tt>), the initial solution constructed by the
<tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> will be</p>
<div class="math">
<p><img src="../../_images/math/2be9aa425b3ca246dfdaa8dd56ee3201e8b96cce.png" alt="[n-1, n-1, \ldots, n-1]."/></p>
</div><p>To have some variation, we construct the following initial solution by hand:</p>
<div class="math">
<p><img src="../../_images/math/b4e5cf10fc1ec58d46345124793309058d344100.png" alt="[n-1, n-2, n -1, n - 2,  \ldots, n-\left\{1 + (n+1) \, \textrm{mod} \, 2\right\}]"/></p>
</div><p>where the value for <img class="math" src="../../_images/math/50d4b9ad2bdffcfcc00b960cf271a20d87ba85e7.png" alt="x_{n-1}" style="vertical-align: -4px"/> is <img class="math" src="../../_images/math/ef9b02e32cfba0db0f9038a8d077596720f62e91.png" alt="n-2" style="vertical-align: 0px"/> if <img class="math" src="../../_images/math/174fadd07fd54c9afe288e96558c92e0c1da733a.png" alt="n" style="vertical-align: 0px"/> is even and
<img class="math" src="../../_images/math/4bdca93962a2beaffc172ca394e04fe05bd74ffd.png" alt="n-1" style="vertical-align: -1px"/> otherwise<a class="footnote-reference" href="#mod-operator" id="id4">[4]</a>.</p>
<table class="docutils footnote" frame="void" id="mod-operator" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[4]</a></td><td>The modulo operator (<img class="math" src="../../_images/math/ae1b3ca6a1430f398f07d78477c28f056e1f0bd0.png" alt="\textrm{mod}" style="vertical-align: -1px"/>) finds the remainder of the division of one (integer)
number by another:
For instance, <img class="math" src="../../_images/math/201480fa827ded31b844d2259ff776a72599a7a7.png" alt="11 \, \textrm{mod} \, 5 = 1" style="vertical-align: -1px"/> because <img class="math" src="../../_images/math/eced53adb889a595997102ef1747d7773b1d54fd.png" alt="11 = 2 \times 5 + 1" style="vertical-align: -1px"/>. When you want to test a
<strong>positive</strong> number <img class="math" src="../../_images/math/174fadd07fd54c9afe288e96558c92e0c1da733a.png" alt="n" style="vertical-align: 0px"/> for parity, you can test <img class="math" src="../../_images/math/b13b147a230a2323db5b90e0abb18fe621366302.png" alt="n \, \textrm{mod} \, 2" style="vertical-align: -1px"/>.
If  <img class="math" src="../../_images/math/ad21c2a70404673bca763879d05445a15169d316.png" alt="n \, \textrm{mod} \, 2 = 0" style="vertical-align: -1px"/>
then <img class="math" src="../../_images/math/174fadd07fd54c9afe288e96558c92e0c1da733a.png" alt="n" style="vertical-align: 0px"/> is even, otherwise it is odd. In <tt class="docutils literal"><span class="pre">C++</span></tt>, the <img class="math" src="../../_images/math/ae1b3ca6a1430f398f07d78477c28f056e1f0bd0.png" alt="\textrm{mod}" style="vertical-align: -1px"/> operator is <tt class="docutils literal"><span class="pre">%</span></tt>.</td></tr>
</tbody>
</table>
<p>The search phase using the LS Operator is given by a... <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>
which shouldn&#8217;t surprise you by now:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//  IntVarLocalSearchOperator</span>
<span class="n">DecreaseOneVar</span> <span class="nf">one_var_ls</span><span class="p">(</span><span class="n">vars</span><span class="p">);</span>
<span class="n">LocalSearchPhaseParameters</span><span class="o">*</span> <span class="n">ls_params</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="n">DecisionBuilder</span><span class="o">*</span> <span class="n">ls</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="n">init_phase</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">ls_params</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">MakeLocalSearchPhaseParameters</span><span class="p">(</span><span class="o">&amp;</span><span class="n">one_var_ls</span><span class="p">,</span> <span class="n">db</span><span class="p">);</span>
  <span class="n">ls</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">MakeLocalSearchPhase</span><span class="p">(</span><span class="n">vars</span><span class="p">,</span> <span class="n">db</span><span class="p">,</span> <span class="n">ls_params</span><span class="p">);</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
  <span class="n">ls_params</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">MakeLocalSearchPhaseParameters</span><span class="p">(</span><span class="o">&amp;</span><span class="n">one_var_ls</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="n">ls</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">MakeLocalSearchPhase</span><span class="p">(</span><span class="n">initial_solution</span><span class="p">,</span> <span class="n">ls_params</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Notice how the LS Operator is passed to the <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> by means of the
<tt class="docutils literal"><span class="pre">LocalSearchPhaseParameters</span></tt>.</p>
<p>We collect the best and last solution:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">SolutionCollector</span><span class="o">*</span> <span class="k">const</span> <span class="n">collector</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">MakeLastSolutionCollector</span><span class="p">();</span>
<span class="n">collector</span><span class="o">-&gt;</span><span class="n">Add</span><span class="p">(</span><span class="n">vars</span><span class="p">);</span>
<span class="n">collector</span><span class="o">-&gt;</span><span class="n">AddObjective</span><span class="p">(</span><span class="n">sum_var</span><span class="p">);</span>
</pre></div>
</div>
<p>and log the search whenever a new feasible solution is found:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">SearchMonitor</span><span class="o">*</span> <span class="k">const</span> <span class="n">log</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">MakeSearchLog</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="n">obj</span><span class="p">);</span>
</pre></div>
</div>
<p>This log will print the objective value and some other interesting statistics every time a better feasible solution is found or
whenever we reach a 1000 more branches in the search tree.</p>
<p>Finally, we launch the search and print the objective value of the last feasible solution found:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">s</span><span class="p">.</span><span class="n">Solve</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">collector</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">log</span><span class="p">);</span>
<span class="n">LOG</span><span class="p">(</span><span class="n">INFO</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Objective value = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">collector</span><span class="o">-&gt;</span><span class="n">objective_value</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</pre></div>
</div>
<p>If we limit ourselves to 4 variables and construct an initial solution by hand:</p>
<div class="highlight-bash"><div class="highlight"><pre>./dummy_ls -n<span class="o">=</span>4 -initial_phase<span class="o">=</span><span class="nb">false</span>
</pre></div>
</div>
<p>we obtain the following partial output:</p>
<div class="highlight-bash"><div class="highlight"><pre>Simple LS with initial solution

Start search, memory <span class="nv">used</span> <span class="o">=</span> 15.09 MB
Root node processed <span class="o">(</span><span class="nb">time</span> <span class="o">=</span> 0 ms, <span class="nv">constraints</span> <span class="o">=</span> 2, memory <span class="nv">used</span> <span class="o">=</span>
                                                           15.09 MB<span class="o">)</span>
Solution <span class="c">#0 (objective value = 10, ...)</span>
Solution <span class="c">#1 (objective value = 9, ...)</span>
Solution <span class="c">#2 (objective value = 8, ...)</span>
Solution <span class="c">#3 (objective value = 7, ...)</span>
Solution <span class="c">#4 (objective value = 6, ...)</span>
Solution <span class="c">#5 (objective value = 5, ...)</span>
Solution <span class="c">#6 (objective value = 4, ...)</span>
Solution <span class="c">#7 (objective value = 3, ...)</span>
Solution <span class="c">#8 (objective value = 2, ...)</span>
Solution <span class="c">#9 (objective value = 1, ...)</span>
Finished search tree, ..., <span class="nv">neighbors</span> <span class="o">=</span> 23, filtered <span class="nv">neighbors</span> <span class="o">=</span> 23,
                                         accepted <span class="nv">neigbors</span> <span class="o">=</span> 9, ...<span class="o">)</span>
End search <span class="o">(</span><span class="nb">time</span> <span class="o">=</span> 1 ms, <span class="nv">branches</span> <span class="o">=</span> 67, <span class="nv">failures</span> <span class="o">=</span> 64, memory <span class="nv">used</span> <span class="o">=</span>
                                 15.13 MB, <span class="nv">speed</span> <span class="o">=</span> 67000 branches/s<span class="o">)</span>
Objective <span class="nv">value</span> <span class="o">=</span> 1
</pre></div>
</div>
<p>As you can see, 10 solutions were generated with decreased objective
values. <tt class="docutils literal"><span class="pre">Solution</span> <span class="pre">#0</span></tt> is the initial solution given:
<img class="math" src="../../_images/math/9daf9afdc97f1d521ca2f4ca32e905f8e9edfc53.png" alt="[3, 2, 3, 2]" style="vertical-align: -5px"/>. Then as expected, 9 neighborhoods were visited and
each time a better solution was chosen:</p>
<dl class="docutils">
<dt>neighborhood 1 around <img class="math" src="../../_images/math/175328140da77805addf7d969f61c9e0df20f3dc.png" alt="[3,2,3,2]" style="vertical-align: -5px"/>:</dt>
<dd><img class="math" src="../../_images/math/e6a5d5e41ded75573652f6ed77411e8a35065f11.png" alt="[2,2,3,2]" style="vertical-align: -5px"/> is immediately taken as it is a better solution with value 9;</dd>
<dt>neighborhood 2  around <img class="math" src="../../_images/math/e6a5d5e41ded75573652f6ed77411e8a35065f11.png" alt="[2,2,3,2]" style="vertical-align: -5px"/>:</dt>
<dd><img class="math" src="../../_images/math/a2e155dc4c6d34c0c8b209dfa1b702bd96840256.png" alt="[1,2,3,2]" style="vertical-align: -5px"/> is a new better solution with value 8;</dd>
<dt>neighborhood 3 around <img class="math" src="../../_images/math/a2e155dc4c6d34c0c8b209dfa1b702bd96840256.png" alt="[1,2,3,2]" style="vertical-align: -5px"/>:</dt>
<dd><img class="math" src="../../_images/math/0173a41a8bb3223bf8b8d771390fe72b6f489041.png" alt="[0,2,3,2]" style="vertical-align: -5px"/> is rejected as infeasible, <img class="math" src="../../_images/math/8b6b54e14a4de89bf2ea30c8a9061a57a5a19e4b.png" alt="[1,1,3,2]" style="vertical-align: -5px"/> is a new better solution with value 7;</dd>
<dt>neighborhood 4 around <img class="math" src="../../_images/math/8b6b54e14a4de89bf2ea30c8a9061a57a5a19e4b.png" alt="[1,1,3,2]" style="vertical-align: -5px"/>:</dt>
<dd><img class="math" src="../../_images/math/9310ab32ab9a1df218a18c13d0eda3623d3144ed.png" alt="[0,1,3,2]" style="vertical-align: -5px"/> is rejected as infeasible, <img class="math" src="../../_images/math/9aa199506aa73098f3645c97321d46ff830e0520.png" alt="[1,0,3,2]" style="vertical-align: -5px"/> is a new better solution with value 6;</dd>
<dt>neighborhood 5 around <img class="math" src="../../_images/math/9aa199506aa73098f3645c97321d46ff830e0520.png" alt="[1,0,3,2]" style="vertical-align: -5px"/>:</dt>
<dd><img class="math" src="../../_images/math/d6ce14fcec48b7c8202c5bc704367847d59d6ee5.png" alt="[0,0,3,2]" style="vertical-align: -5px"/>, <img class="math" src="../../_images/math/ca9bce0510c2e3ca3279856c99ca8bfd85b1664b.png" alt="[0,-1,3,2]" style="vertical-align: -5px"/> are rejected as infeasible, <img class="math" src="../../_images/math/35b5503fa6e931410c1f52d2295902b65fc77762.png" alt="[1,0,2,2]" style="vertical-align: -5px"/> is a new better solution with value 5;</dd>
<dt>neighborhood 6 around <img class="math" src="../../_images/math/35b5503fa6e931410c1f52d2295902b65fc77762.png" alt="[1,0,2,2]" style="vertical-align: -5px"/>:</dt>
<dd><img class="math" src="../../_images/math/099e77cd830df15edd27264671e1046a8b5004d7.png" alt="[0,1,2,2]" style="vertical-align: -5px"/>, <img class="math" src="../../_images/math/4926393d253a3838a717466983f72a19db829a89.png" alt="[1,-1,2,2]" style="vertical-align: -5px"/> are rejected as infeasible, <img class="math" src="../../_images/math/d07f48eda6556f42a31ab60e4d5f7afa94b0869f.png" alt="[1,0,1,2]" style="vertical-align: -5px"/> is a new better solution with value 4;</dd>
<dt>neighborhood 7 around <img class="math" src="../../_images/math/d07f48eda6556f42a31ab60e4d5f7afa94b0869f.png" alt="[1,0,1,2]" style="vertical-align: -5px"/>:</dt>
<dd><img class="math" src="../../_images/math/341b0880e2fbb86eebcbb5877a8cb9395ca17c6d.png" alt="[0,0,1,2]" style="vertical-align: -5px"/>, <img class="math" src="../../_images/math/41df22b966ac9bd9434c318564c40166b125a845.png" alt="[1,-1,1,2]" style="vertical-align: -5px"/> are rejected as infeasible, <img class="math" src="../../_images/math/16a64b20b673f9d47a80a721f659a4e7726bb6e1.png" alt="[1,0,0,2]" style="vertical-align: -5px"/> is a new better solution with value 3;</dd>
<dt>neighborhood 8 around <img class="math" src="../../_images/math/16a64b20b673f9d47a80a721f659a4e7726bb6e1.png" alt="[1,0,0,2]" style="vertical-align: -5px"/>:</dt>
<dd><img class="math" src="../../_images/math/01b406504be034b72d2a93c4ad2274d569690626.png" alt="[0,0,0,2]" style="vertical-align: -5px"/>, <img class="math" src="../../_images/math/05426aed02fe08b2463e82e675e45defcb109284.png" alt="[1,-1,0,2]" style="vertical-align: -5px"/>, <img class="math" src="../../_images/math/728584283c6ce373fec50c48006132f89a59c5f8.png" alt="[1,0,-1,2]" style="vertical-align: -5px"/> are rejected as infeasible, <img class="math" src="../../_images/math/f87941714030b18f5272b8ed79cf7fe391284c24.png" alt="[1,0,0,1]" style="vertical-align: -5px"/> is a new better solution with value 2;</dd>
<dt>neighborhood 9 around <img class="math" src="../../_images/math/f87941714030b18f5272b8ed79cf7fe391284c24.png" alt="[1,0,0,1]" style="vertical-align: -5px"/>:</dt>
<dd><img class="math" src="../../_images/math/025ce967cda85c75594baf23479beb1b1c49d84e.png" alt="[0,0,0,1]" style="vertical-align: -5px"/>, <img class="math" src="../../_images/math/3bde95465a7a41d705711c9137d09690e5854b97.png" alt="[1,-1,0,1]" style="vertical-align: -5px"/>, <img class="math" src="../../_images/math/832173fd4753baf7fad06d8de210835136aa9d57.png" alt="[1,0,-1,1]" style="vertical-align: -5px"/> are rejected as infeasible, <img class="math" src="../../_images/math/e8e1d5ff72c593aab7d4938dbbc39be2e7f2e958.png" alt="[1,0,0,0]" style="vertical-align: -5px"/> is a new better solution with value 1;</dd>
</dl>
<p>At this point, the solver is able to recognize that there are no more possibilities.
The two last lines printed
by the <tt class="docutils literal"><span class="pre">SearchLog</span></tt> summarize the local search:</p>
<div class="highlight-bash"><div class="highlight"><pre>Finished search tree, ..., <span class="nv">neighbors</span> <span class="o">=</span> 23, filtered <span class="nv">neighbors</span> <span class="o">=</span> 23,
                                         accepted <span class="nv">neighbors</span> <span class="o">=</span> 9, ...<span class="o">)</span>
End search <span class="o">(</span><span class="nb">time</span> <span class="o">=</span> 1 ms, <span class="nv">branches</span> <span class="o">=</span> 67, <span class="nv">failures</span> <span class="o">=</span> 64, memory <span class="nv">used</span> <span class="o">=</span>
                                 15.13 MB, <span class="nv">speed</span> <span class="o">=</span> 67000 branches/s<span class="o">)</span>
</pre></div>
</div>
<p>There were indeed 23 constructed candidate solutions among which 23 (filtered neighbors)
were accepted after filtering and 9 (accepted neighbors) were improving solutions.</p>
<p>If you take the last visited neighborhood (neighborhood 9), you might wonder
if it was really necessary to construct &#8220;solutions&#8221; <img class="math" src="../../_images/math/025ce967cda85c75594baf23479beb1b1c49d84e.png" alt="[0,0,0,1]" style="vertical-align: -5px"/>, <img class="math" src="../../_images/math/3bde95465a7a41d705711c9137d09690e5854b97.png" alt="[1,-1,0,1]" style="vertical-align: -5px"/> and <img class="math" src="../../_images/math/832173fd4753baf7fad06d8de210835136aa9d57.png" alt="[1,0,-1,1]" style="vertical-align: -5px"/> and let the solver
decide if they were interesting or not. The answer is no. We could have filtered those solutions out and told the solver
to disregard them. We didn&#8217;t filter out any solution (and this is the reason why the number of constructed neighbors is equal
to the number of filtered neighbors). You can learn more about filtering in the section <a class="reference internal" href="ls_filtering.html#local-search-filtering"><em>Filtering</em></a>.</p>
<p>If you want, you can try to start with the solution provided by the <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> (<img class="math" src="../../_images/math/1a433c0bc194b94780feb312bc5848cf454829b1.png" alt="[3,3,3,3]" style="vertical-align: -5px"/> when <img class="math" src="../../_images/math/39cf3e35a4981583288d2a7c4b34989916fb7360.png" alt="n=4" style="vertical-align: -1px"/>)
and see if you can figure out
what the 29 constructed candidate solutions (neighbors)  and 11 accepted solutions are.</p>
</div>
<div class="section" id="combining-ls-operators">
<h2>6.6.3. Combining LS operators</h2>
<p>Often, you want to combine several <tt class="docutils literal"><span class="pre">LocalSearchOperator</span></tt>s. This can be done with the <tt class="docutils literal"><span class="pre">ConcatenateOperators()</span></tt> method:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">LocalSearchOperator</span><span class="o">*</span> <span class="nf">ConcatenateOperators</span><span class="p">(</span>
                      <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">LocalSearchOperator</span><span class="o">*&gt;&amp;</span> <span class="n">ops</span><span class="p">);</span>
</pre></div>
</div>
<p>This creates a <tt class="docutils literal"><span class="pre">LocalSearchOperator</span></tt> which concatenates a vector of operators.
Each operator from the vector is called sequentially. By default, when a
candidate solution is accepted, the neighborhood exploration restarts from the <strong>last</strong>
active operator (the one which produced this candidate solution).</p>
<p>This can be overriden by setting <tt class="docutils literal"><span class="pre">restart</span></tt> to <tt class="docutils literal"><span class="pre">true</span></tt> to force the exploration
to start from the first operator in the vector:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">LocalSearchOperator</span><span class="o">*</span> <span class="n">Solver</span><span class="o">::</span><span class="n">ConcatenateOperators</span><span class="p">(</span>
       <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">LocalSearchOperator</span><span class="o">*&gt;&amp;</span> <span class="n">ops</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">restart</span><span class="p">);</span>
</pre></div>
</div>
<p>You can also use an evaluation callback to set the order in which the operators are explored
(the callback is called in <tt class="docutils literal"><span class="pre">LocalSearchOperator::Start()</span></tt>). The first argument of the callback is
the index of the operator which produced the last move, the second
argument is the index of the operator to be evaluated.
Ownership of the callback is taken by the solver.</p>
<p>Here is an example:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">const</span> <span class="kt">int</span> <span class="n">kPriorities</span> <span class="o">=</span> <span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
<span class="n">int64</span> <span class="nf">Evaluate</span><span class="p">(</span><span class="kt">int</span> <span class="n">active_operator</span><span class="p">,</span> <span class="kt">int</span> <span class="n">current_operator</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">kPriorities</span><span class="p">[</span><span class="n">current_operator</span><span class="p">];</span>
<span class="p">}</span>

<span class="n">LocalSearchOperator</span><span class="o">*</span> <span class="n">concat</span> <span class="o">=</span>
                            <span class="n">solver</span><span class="p">.</span><span class="n">ConcatenateOperators</span><span class="p">(</span><span class="n">operators</span><span class="p">,</span>
                            <span class="n">NewPermanentCallback</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Evaluate</span><span class="p">));</span>
</pre></div>
</div>
<p>The elements of the operators&#8217; <tt class="docutils literal"><span class="pre">vector</span></tt> will be sorted by increasing priority
and explored in that order (tie-breaks are handled by keeping the relative
operator order in the vector). This would result in the following order:</p>
<p><tt class="docutils literal"><span class="pre">operators[3],</span> <span class="pre">operators[0],</span> <span class="pre">operators[2],</span> <span class="pre">operators[1]</span></tt>.</p>
<p>Sometimes you don&#8217;t know in what order to proceed. Then the following method might help you:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">LocalSearchOperator</span><span class="o">*</span> <span class="n">Solver</span><span class="o">::</span><span class="n">RandomConcatenateOperators</span><span class="p">(</span>
                      <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">LocalSearchOperator</span><span class="o">*&gt;&amp;</span> <span class="n">ops</span><span class="p">);</span>
</pre></div>
</div>
<p>This <tt class="docutils literal"><span class="pre">LocalSearchOperator</span></tt> calls a random operator at each call to <tt class="docutils literal"><span class="pre">MakeNextNeighbor()</span></tt>.
You can provide the seed that is used to initialize the random number generator:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">LocalSearchOperator</span><span class="o">*</span> <span class="n">Solver</span><span class="o">::</span><span class="n">RandomConcatenateOperators</span><span class="p">(</span>
          <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">LocalSearchOperator</span><span class="o">*&gt;&amp;</span> <span class="n">ops</span><span class="p">,</span> <span class="n">int32</span> <span class="n">seed</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="interesting-ls-operators">
<h2>6.6.4. Interesting LS operators</h2>
<p>Several existing <tt class="docutils literal"><span class="pre">LocalSearchOperator</span></tt>s can be of great help. Combine these operators with your own customized
operators.</p>
<p><tt class="docutils literal"><span class="pre">PathOperator</span></tt>s will be reviewed in the subsection <a class="reference internal" href="../tsp/two_phases_approaches.html#local-search-pathoperators"><em>Local Search PathOperators</em></a>.</p>
<div class="section" id="neighborhoodlimit">
<h3>6.6.4.1. <tt class="docutils literal"><span class="pre">NeighborhoodLimit</span></tt></h3>
<p>This <tt class="docutils literal"><span class="pre">LocalSearchOperator</span></tt> creates a <tt class="docutils literal"><span class="pre">LocalSearchOperator</span></tt> that wraps another <tt class="docutils literal"><span class="pre">LocalSearchOperator</span></tt>
and limits the number of candidate solutions explored (i.e. calls
to <tt class="docutils literal"><span class="pre">MakeNextNeighbor()</span></tt> from the current solution (between two calls
to <tt class="docutils literal"><span class="pre">Start()</span></tt>). When this limit is reached, <tt class="docutils literal"><span class="pre">MakeNextNeighbor()</span></tt>
returns <tt class="docutils literal"><span class="pre">false</span></tt>. The counter is cleared when <tt class="docutils literal"><span class="pre">Start()</span></tt> is called.</p>
<p>Here is the factory method:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">LocalSearchOperator</span><span class="o">*</span> <span class="n">Solver</span><span class="o">::</span><span class="n">MakeNeighborhoodLimit</span><span class="p">(</span>
                                     <span class="n">LocalSearchOperator</span><span class="o">*</span> <span class="k">const</span> <span class="n">op</span><span class="p">,</span>
                                     <span class="n">int64</span> <span class="n">limit</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="movetowardtargetls">
<h3>6.6.4.2. <tt class="docutils literal"><span class="pre">MoveTowardTargetLS</span></tt></h3>
<p>Creates a local search operator that tries to move the assignment of some
variables toward a target. The target is given as an <tt class="docutils literal"><span class="pre">Assignment</span></tt>. This
operator generates candidate solutions which only have one variable that belongs to the target <tt class="docutils literal"><span class="pre">Assignment</span></tt>
set to its target value.</p>
<p>There are two factory methods to create a <tt class="docutils literal"><span class="pre">MoveTowardTargetLS</span></tt> operator:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">LocalSearchOperator</span><span class="o">*</span> <span class="n">Solver</span><span class="o">::</span><span class="n">MakeMoveTowardTargetOperator</span><span class="p">(</span>
                                          <span class="k">const</span> <span class="n">Assignment</span><span class="o">&amp;</span> <span class="n">target</span><span class="p">);</span>
</pre></div>
</div>
<p>and</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">LocalSearchOperator</span><span class="o">*</span> <span class="n">Solver</span><span class="o">::</span><span class="n">MakeMoveTowardTargetOperator</span><span class="p">(</span>
                            <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">IntVar</span><span class="o">*&gt;&amp;</span> <span class="n">variables</span><span class="p">,</span>
                            <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">int64</span><span class="o">&gt;&amp;</span> <span class="n">target_values</span><span class="p">);</span>
</pre></div>
</div>
<p>The target is here given by two <tt class="docutils literal"><span class="pre">std::vector</span></tt>s: a
vector of variables and a vector of associated target values. The two
vectors should be of the same length and the variables and values are ordered in the same way.</p>
<p>The variables are changed one after the other in the order given by the <tt class="docutils literal"><span class="pre">Assignment</span></tt> or the vector of
variables. When we restart from a new feasible solution, we don&#8217;t start all over again from the first variable but
keep changing variables from the last change.</p>
</div>
<div class="section" id="decrementvalue-and-incrementvalue">
<h3>6.6.4.3. <tt class="docutils literal"><span class="pre">DecrementValue</span></tt> and <tt class="docutils literal"><span class="pre">IncrementValue</span></tt></h3>
<p>These operators do exactly what their names say: they decrement and increment by 1 the value of each
variable one after the other.</p>
<p>To create them, use the generic factory method</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">LocalSearchOperator</span><span class="o">*</span> <span class="n">Solver</span><span class="o">::</span><span class="n">MakeOperator</span><span class="p">(</span>
                                  <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">IntVar</span><span class="o">*&gt;&amp;</span> <span class="n">vars</span><span class="p">,</span>
                                  <span class="n">Solver</span><span class="o">::</span><span class="n">LocalSearchOperators</span> <span class="n">op</span><span class="p">);</span>
</pre></div>
</div>
<p>where <tt class="docutils literal"><span class="pre">op</span></tt> is an <tt class="docutils literal"><span class="pre">LocalSearchOperators</span></tt> <tt class="docutils literal"><span class="pre">enum</span></tt>. The values for <tt class="docutils literal"><span class="pre">DecrementValue</span></tt> and <tt class="docutils literal"><span class="pre">IncrementValue</span></tt>
are respectively <tt class="docutils literal"><span class="pre">Solver::DECREMENT</span></tt> and <tt class="docutils literal"><span class="pre">Solver::INCREMENT</span></tt>.</p>
<p>The variables are changed in the order given by the <tt class="docutils literal"><span class="pre">std::vector</span></tt>. Whenever we start to explore a new neighborhood,
the variables are changed from the beginning of the vector anew.</p>
</div>
<div class="section" id="large-neighborhood-search-lns">
<h3>6.6.4.4. Large Neighborhood Search (LNS)</h3>
<p>And last but not least, in <em>or-tools</em>, Large Neighborhood Search is implemented with <tt class="docutils literal"><span class="pre">LocalSearchOperator</span></tt>s but
this is the topic of the section <a class="reference internal" href="../metaheuristics/jobshop_lns.html#large-neighborhood-search"><em>Large neighborhood search (LNS): the job-shop problem</em></a>.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<table>
<tr>
<td width="60"><img src="../../_static/logo.png" width="50" height="50"  alt="" /></td>
<td><p class="library_name">Google <a href="http://code.google.com/p/or-tools/"><strong>or-tools</strong></a><br>open source library</p></td>
</tr>
</table>
<h1>User's Manual</h1>

  
   



<h3>Google search</h3>

<form method="get" action="http://www.google.com/search">

<div style="padding:-1px;width:15em;">
<table border="0" cellpadding="0">
<tr><td>
<input type="text"   name="q" size="25"
 maxlength="255" value="" />
<input type="submit" value="Go" /></td></tr>
<tr><td align="center" style="font-size:80%">
Search:
<select name="sitesearch" width="125" style="width: 125px">
<option value="http://or-tools.googlecode.com/svn/trunk/documentation/user_manual/" selected>user's manual</option>
<option value="http://or-tools.googlecode.com/svn/trunk/documentation/faq/">faq</option>
<option value="http://or-tools.googlecode.com/svn/trunk/documentation/reference_manual/or-tools/">reference manual</option>
<option value="http://or-tools.googlecode.com/svn/trunk/documentation/">All or-tools doc</option>
</select>
</td></tr>
</table>
</div>

</form>
</br>




  <h3>Welcome</h3>
  
  <ul>
  	<li><a href="../../index.html">Content and foreword</a></li>
  	<li><a href="http://or-tools.googlecode.com/svn/trunk/documentation/documentation_hub.html">Documentation's hub</a></li>
	<li><a href="http://code.google.com/p/or-tools/">The or-tools open source library</a></li></li>	
  </ul>
  
   
	


  <h3>Tutorial examples</h3>
  
  <ul>
	<li><a href="http://or-tools.googlecode.com/svn/trunk/documentation/documentation_hub.html#tutorial_C++">C++</a></li>
	<li><a href="http://or-tools.googlecode.com/svn/trunk/documentation/documentation_hub.html#tutorial_Python">Python</a></li>	
	<li><a href="http://or-tools.googlecode.com/svn/trunk/documentation/documentation_hub.html#tutorial_Java">Java</a></li>
	<li><a href="http://or-tools.googlecode.com/svn/trunk/documentation/documentation_hub.html#tutorial_Csharp">C#</a></li>
</ul>
  
   
	

  <h3>Current chapter</h3>
  <p class="topless"><a href="../LS.html"
                        title="previous chapter">6. Local search: the job-shop problem</a></p>
  <h3>Previous section</h3>
  <p class="topless"><a href="basic_working_local_search.html"
                        title="previous chapter">6.5. Basic working of the solver: Local Search</a></p>
  <h3>Next section</h3>
  <p class="topless"><a href="jobshop_ls.html"
                        title="next chapter">6.7. The jobshop problem: and now with local search!</a></p>
  <h3>Current section</a></h3>
  <ul>
<li><a class="reference internal" href="#">6.6. Local Search Operators</a><ul>
<li><a class="reference internal" href="#localsearchoperators">6.6.1. <tt class="docutils literal"><span class="pre">LocalSearchOperator</span></tt>s</a></li>
<li><a class="reference internal" href="#defining-a-custom-ls-operator">6.6.2. Defining a custom LS operator</a></li>
<li><a class="reference internal" href="#combining-ls-operators">6.6.3. Combining LS operators</a></li>
<li><a class="reference internal" href="#interesting-ls-operators">6.6.4. Interesting LS operators</a><ul>
<li><a class="reference internal" href="#neighborhoodlimit">6.6.4.1. <tt class="docutils literal"><span class="pre">NeighborhoodLimit</span></tt></a></li>
<li><a class="reference internal" href="#movetowardtargetls">6.6.4.2. <tt class="docutils literal"><span class="pre">MoveTowardTargetLS</span></tt></a></li>
<li><a class="reference internal" href="#decrementvalue-and-incrementvalue">6.6.4.3. <tt class="docutils literal"><span class="pre">DecrementValue</span></tt> and <tt class="docutils literal"><span class="pre">IncrementValue</span></tt></a></li>
<li><a class="reference internal" href="#large-neighborhood-search-lns">6.6.4.4. Large Neighborhood Search (LNS)</a></li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="jobshop_ls.html" title="6.7. The jobshop problem: and now with local search!"
             >next</a> |</li>
        <li class="right" >
          <a href="basic_working_local_search.html" title="6.5. Basic working of the solver: Local Search"
             >previous</a> |</li>
        <li><a href="../../index.html">or-tools User&#39;s Manual</a> &raquo;</li>
          <li><a href="../LS.html" >6. Local search: the job-shop problem</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012-2013, Google.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>